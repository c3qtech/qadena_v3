// Code generated by protoc-gen-go-pulsar. DO NOT EDIT.
package qadena

import (
	_ "cosmossdk.io/api/amino"
	v1beta1 "cosmossdk.io/api/cosmos/base/v1beta1"
	_ "cosmossdk.io/api/cosmos/msg/v1"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	runtime "github.com/cosmos/cosmos-proto/runtime"
	_ "github.com/cosmos/gogoproto/gogoproto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoiface "google.golang.org/protobuf/runtime/protoiface"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	reflect "reflect"
	sort "sort"
	sync "sync"
)

var (
	md_EncryptableString       protoreflect.MessageDescriptor
	fd_EncryptableString_Value protoreflect.FieldDescriptor
)

func init() {
	file_qadena_qadena_encryptable_proto_init()
	md_EncryptableString = File_qadena_qadena_encryptable_proto.Messages().ByName("EncryptableString")
	fd_EncryptableString_Value = md_EncryptableString.Fields().ByName("Value")
}

var _ protoreflect.Message = (*fastReflection_EncryptableString)(nil)

type fastReflection_EncryptableString EncryptableString

func (x *EncryptableString) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EncryptableString)(x)
}

func (x *EncryptableString) slowProtoReflect() protoreflect.Message {
	mi := &file_qadena_qadena_encryptable_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EncryptableString_messageType fastReflection_EncryptableString_messageType
var _ protoreflect.MessageType = fastReflection_EncryptableString_messageType{}

type fastReflection_EncryptableString_messageType struct{}

func (x fastReflection_EncryptableString_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EncryptableString)(nil)
}
func (x fastReflection_EncryptableString_messageType) New() protoreflect.Message {
	return new(fastReflection_EncryptableString)
}
func (x fastReflection_EncryptableString_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableString
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EncryptableString) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableString
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EncryptableString) Type() protoreflect.MessageType {
	return _fastReflection_EncryptableString_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EncryptableString) New() protoreflect.Message {
	return new(fastReflection_EncryptableString)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EncryptableString) Interface() protoreflect.ProtoMessage {
	return (*EncryptableString)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EncryptableString) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Value != "" {
		value := protoreflect.ValueOfString(x.Value)
		if !f(fd_EncryptableString_Value, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EncryptableString) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableString.Value":
		return x.Value != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableString"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableString does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableString) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableString.Value":
		x.Value = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableString"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableString does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EncryptableString) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "qadena.qadena.EncryptableString.Value":
		value := x.Value
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableString"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableString does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableString) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableString.Value":
		x.Value = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableString"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableString does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableString) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableString.Value":
		panic(fmt.Errorf("field Value of message qadena.qadena.EncryptableString is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableString"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableString does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EncryptableString) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableString.Value":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableString"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableString does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EncryptableString) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in qadena.qadena.EncryptableString", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EncryptableString) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableString) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EncryptableString) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EncryptableString) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EncryptableString)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Value)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableString)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Value) > 0 {
			i -= len(x.Value)
			copy(dAtA[i:], x.Value)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Value)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableString)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableString: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableString: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Value = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EncryptableClaimCredentialExtraParms                          protoreflect.MessageDescriptor
	fd_EncryptableClaimCredentialExtraParms_EncCredentialInfoVShare  protoreflect.FieldDescriptor
	fd_EncryptableClaimCredentialExtraParms_CredentialInfoVShareBind protoreflect.FieldDescriptor
	fd_EncryptableClaimCredentialExtraParms_WalletID                 protoreflect.FieldDescriptor
	fd_EncryptableClaimCredentialExtraParms_FindCredentialPC         protoreflect.FieldDescriptor
	fd_EncryptableClaimCredentialExtraParms_NewCredentialPC          protoreflect.FieldDescriptor
	fd_EncryptableClaimCredentialExtraParms_EncWalletIDVShare        protoreflect.FieldDescriptor
	fd_EncryptableClaimCredentialExtraParms_WalletIDVShareBind       protoreflect.FieldDescriptor
	fd_EncryptableClaimCredentialExtraParms_EncCredentialHashVShare  protoreflect.FieldDescriptor
	fd_EncryptableClaimCredentialExtraParms_CredentialHashVShareBind protoreflect.FieldDescriptor
	fd_EncryptableClaimCredentialExtraParms_ZeroPC                   protoreflect.FieldDescriptor
	fd_EncryptableClaimCredentialExtraParms_ClaimPC                  protoreflect.FieldDescriptor
)

func init() {
	file_qadena_qadena_encryptable_proto_init()
	md_EncryptableClaimCredentialExtraParms = File_qadena_qadena_encryptable_proto.Messages().ByName("EncryptableClaimCredentialExtraParms")
	fd_EncryptableClaimCredentialExtraParms_EncCredentialInfoVShare = md_EncryptableClaimCredentialExtraParms.Fields().ByName("EncCredentialInfoVShare")
	fd_EncryptableClaimCredentialExtraParms_CredentialInfoVShareBind = md_EncryptableClaimCredentialExtraParms.Fields().ByName("CredentialInfoVShareBind")
	fd_EncryptableClaimCredentialExtraParms_WalletID = md_EncryptableClaimCredentialExtraParms.Fields().ByName("WalletID")
	fd_EncryptableClaimCredentialExtraParms_FindCredentialPC = md_EncryptableClaimCredentialExtraParms.Fields().ByName("FindCredentialPC")
	fd_EncryptableClaimCredentialExtraParms_NewCredentialPC = md_EncryptableClaimCredentialExtraParms.Fields().ByName("NewCredentialPC")
	fd_EncryptableClaimCredentialExtraParms_EncWalletIDVShare = md_EncryptableClaimCredentialExtraParms.Fields().ByName("EncWalletIDVShare")
	fd_EncryptableClaimCredentialExtraParms_WalletIDVShareBind = md_EncryptableClaimCredentialExtraParms.Fields().ByName("WalletIDVShareBind")
	fd_EncryptableClaimCredentialExtraParms_EncCredentialHashVShare = md_EncryptableClaimCredentialExtraParms.Fields().ByName("EncCredentialHashVShare")
	fd_EncryptableClaimCredentialExtraParms_CredentialHashVShareBind = md_EncryptableClaimCredentialExtraParms.Fields().ByName("CredentialHashVShareBind")
	fd_EncryptableClaimCredentialExtraParms_ZeroPC = md_EncryptableClaimCredentialExtraParms.Fields().ByName("ZeroPC")
	fd_EncryptableClaimCredentialExtraParms_ClaimPC = md_EncryptableClaimCredentialExtraParms.Fields().ByName("ClaimPC")
}

var _ protoreflect.Message = (*fastReflection_EncryptableClaimCredentialExtraParms)(nil)

type fastReflection_EncryptableClaimCredentialExtraParms EncryptableClaimCredentialExtraParms

func (x *EncryptableClaimCredentialExtraParms) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EncryptableClaimCredentialExtraParms)(x)
}

func (x *EncryptableClaimCredentialExtraParms) slowProtoReflect() protoreflect.Message {
	mi := &file_qadena_qadena_encryptable_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EncryptableClaimCredentialExtraParms_messageType fastReflection_EncryptableClaimCredentialExtraParms_messageType
var _ protoreflect.MessageType = fastReflection_EncryptableClaimCredentialExtraParms_messageType{}

type fastReflection_EncryptableClaimCredentialExtraParms_messageType struct{}

func (x fastReflection_EncryptableClaimCredentialExtraParms_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EncryptableClaimCredentialExtraParms)(nil)
}
func (x fastReflection_EncryptableClaimCredentialExtraParms_messageType) New() protoreflect.Message {
	return new(fastReflection_EncryptableClaimCredentialExtraParms)
}
func (x fastReflection_EncryptableClaimCredentialExtraParms_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableClaimCredentialExtraParms
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EncryptableClaimCredentialExtraParms) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableClaimCredentialExtraParms
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EncryptableClaimCredentialExtraParms) Type() protoreflect.MessageType {
	return _fastReflection_EncryptableClaimCredentialExtraParms_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EncryptableClaimCredentialExtraParms) New() protoreflect.Message {
	return new(fastReflection_EncryptableClaimCredentialExtraParms)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EncryptableClaimCredentialExtraParms) Interface() protoreflect.ProtoMessage {
	return (*EncryptableClaimCredentialExtraParms)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EncryptableClaimCredentialExtraParms) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.EncCredentialInfoVShare) != 0 {
		value := protoreflect.ValueOfBytes(x.EncCredentialInfoVShare)
		if !f(fd_EncryptableClaimCredentialExtraParms_EncCredentialInfoVShare, value) {
			return
		}
	}
	if x.CredentialInfoVShareBind != nil {
		value := protoreflect.ValueOfMessage(x.CredentialInfoVShareBind.ProtoReflect())
		if !f(fd_EncryptableClaimCredentialExtraParms_CredentialInfoVShareBind, value) {
			return
		}
	}
	if x.WalletID != "" {
		value := protoreflect.ValueOfString(x.WalletID)
		if !f(fd_EncryptableClaimCredentialExtraParms_WalletID, value) {
			return
		}
	}
	if x.FindCredentialPC != nil {
		value := protoreflect.ValueOfMessage(x.FindCredentialPC.ProtoReflect())
		if !f(fd_EncryptableClaimCredentialExtraParms_FindCredentialPC, value) {
			return
		}
	}
	if x.NewCredentialPC != nil {
		value := protoreflect.ValueOfMessage(x.NewCredentialPC.ProtoReflect())
		if !f(fd_EncryptableClaimCredentialExtraParms_NewCredentialPC, value) {
			return
		}
	}
	if len(x.EncWalletIDVShare) != 0 {
		value := protoreflect.ValueOfBytes(x.EncWalletIDVShare)
		if !f(fd_EncryptableClaimCredentialExtraParms_EncWalletIDVShare, value) {
			return
		}
	}
	if x.WalletIDVShareBind != nil {
		value := protoreflect.ValueOfMessage(x.WalletIDVShareBind.ProtoReflect())
		if !f(fd_EncryptableClaimCredentialExtraParms_WalletIDVShareBind, value) {
			return
		}
	}
	if len(x.EncCredentialHashVShare) != 0 {
		value := protoreflect.ValueOfBytes(x.EncCredentialHashVShare)
		if !f(fd_EncryptableClaimCredentialExtraParms_EncCredentialHashVShare, value) {
			return
		}
	}
	if x.CredentialHashVShareBind != nil {
		value := protoreflect.ValueOfMessage(x.CredentialHashVShareBind.ProtoReflect())
		if !f(fd_EncryptableClaimCredentialExtraParms_CredentialHashVShareBind, value) {
			return
		}
	}
	if x.ZeroPC != nil {
		value := protoreflect.ValueOfMessage(x.ZeroPC.ProtoReflect())
		if !f(fd_EncryptableClaimCredentialExtraParms_ZeroPC, value) {
			return
		}
	}
	if x.ClaimPC != nil {
		value := protoreflect.ValueOfMessage(x.ClaimPC.ProtoReflect())
		if !f(fd_EncryptableClaimCredentialExtraParms_ClaimPC, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EncryptableClaimCredentialExtraParms) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.EncCredentialInfoVShare":
		return len(x.EncCredentialInfoVShare) != 0
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.CredentialInfoVShareBind":
		return x.CredentialInfoVShareBind != nil
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.WalletID":
		return x.WalletID != ""
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.FindCredentialPC":
		return x.FindCredentialPC != nil
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.NewCredentialPC":
		return x.NewCredentialPC != nil
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.EncWalletIDVShare":
		return len(x.EncWalletIDVShare) != 0
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.WalletIDVShareBind":
		return x.WalletIDVShareBind != nil
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.EncCredentialHashVShare":
		return len(x.EncCredentialHashVShare) != 0
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.CredentialHashVShareBind":
		return x.CredentialHashVShareBind != nil
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.ZeroPC":
		return x.ZeroPC != nil
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.ClaimPC":
		return x.ClaimPC != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableClaimCredentialExtraParms"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableClaimCredentialExtraParms does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableClaimCredentialExtraParms) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.EncCredentialInfoVShare":
		x.EncCredentialInfoVShare = nil
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.CredentialInfoVShareBind":
		x.CredentialInfoVShareBind = nil
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.WalletID":
		x.WalletID = ""
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.FindCredentialPC":
		x.FindCredentialPC = nil
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.NewCredentialPC":
		x.NewCredentialPC = nil
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.EncWalletIDVShare":
		x.EncWalletIDVShare = nil
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.WalletIDVShareBind":
		x.WalletIDVShareBind = nil
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.EncCredentialHashVShare":
		x.EncCredentialHashVShare = nil
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.CredentialHashVShareBind":
		x.CredentialHashVShareBind = nil
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.ZeroPC":
		x.ZeroPC = nil
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.ClaimPC":
		x.ClaimPC = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableClaimCredentialExtraParms"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableClaimCredentialExtraParms does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EncryptableClaimCredentialExtraParms) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.EncCredentialInfoVShare":
		value := x.EncCredentialInfoVShare
		return protoreflect.ValueOfBytes(value)
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.CredentialInfoVShareBind":
		value := x.CredentialInfoVShareBind
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.WalletID":
		value := x.WalletID
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.FindCredentialPC":
		value := x.FindCredentialPC
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.NewCredentialPC":
		value := x.NewCredentialPC
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.EncWalletIDVShare":
		value := x.EncWalletIDVShare
		return protoreflect.ValueOfBytes(value)
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.WalletIDVShareBind":
		value := x.WalletIDVShareBind
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.EncCredentialHashVShare":
		value := x.EncCredentialHashVShare
		return protoreflect.ValueOfBytes(value)
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.CredentialHashVShareBind":
		value := x.CredentialHashVShareBind
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.ZeroPC":
		value := x.ZeroPC
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.ClaimPC":
		value := x.ClaimPC
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableClaimCredentialExtraParms"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableClaimCredentialExtraParms does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableClaimCredentialExtraParms) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.EncCredentialInfoVShare":
		x.EncCredentialInfoVShare = value.Bytes()
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.CredentialInfoVShareBind":
		x.CredentialInfoVShareBind = value.Message().Interface().(*VShareBindData)
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.WalletID":
		x.WalletID = value.Interface().(string)
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.FindCredentialPC":
		x.FindCredentialPC = value.Message().Interface().(*BPedersenCommit)
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.NewCredentialPC":
		x.NewCredentialPC = value.Message().Interface().(*BPedersenCommit)
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.EncWalletIDVShare":
		x.EncWalletIDVShare = value.Bytes()
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.WalletIDVShareBind":
		x.WalletIDVShareBind = value.Message().Interface().(*VShareBindData)
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.EncCredentialHashVShare":
		x.EncCredentialHashVShare = value.Bytes()
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.CredentialHashVShareBind":
		x.CredentialHashVShareBind = value.Message().Interface().(*VShareBindData)
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.ZeroPC":
		x.ZeroPC = value.Message().Interface().(*EncryptablePedersenCommit)
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.ClaimPC":
		x.ClaimPC = value.Message().Interface().(*BPedersenCommit)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableClaimCredentialExtraParms"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableClaimCredentialExtraParms does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableClaimCredentialExtraParms) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.CredentialInfoVShareBind":
		if x.CredentialInfoVShareBind == nil {
			x.CredentialInfoVShareBind = new(VShareBindData)
		}
		return protoreflect.ValueOfMessage(x.CredentialInfoVShareBind.ProtoReflect())
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.FindCredentialPC":
		if x.FindCredentialPC == nil {
			x.FindCredentialPC = new(BPedersenCommit)
		}
		return protoreflect.ValueOfMessage(x.FindCredentialPC.ProtoReflect())
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.NewCredentialPC":
		if x.NewCredentialPC == nil {
			x.NewCredentialPC = new(BPedersenCommit)
		}
		return protoreflect.ValueOfMessage(x.NewCredentialPC.ProtoReflect())
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.WalletIDVShareBind":
		if x.WalletIDVShareBind == nil {
			x.WalletIDVShareBind = new(VShareBindData)
		}
		return protoreflect.ValueOfMessage(x.WalletIDVShareBind.ProtoReflect())
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.CredentialHashVShareBind":
		if x.CredentialHashVShareBind == nil {
			x.CredentialHashVShareBind = new(VShareBindData)
		}
		return protoreflect.ValueOfMessage(x.CredentialHashVShareBind.ProtoReflect())
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.ZeroPC":
		if x.ZeroPC == nil {
			x.ZeroPC = new(EncryptablePedersenCommit)
		}
		return protoreflect.ValueOfMessage(x.ZeroPC.ProtoReflect())
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.ClaimPC":
		if x.ClaimPC == nil {
			x.ClaimPC = new(BPedersenCommit)
		}
		return protoreflect.ValueOfMessage(x.ClaimPC.ProtoReflect())
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.EncCredentialInfoVShare":
		panic(fmt.Errorf("field EncCredentialInfoVShare of message qadena.qadena.EncryptableClaimCredentialExtraParms is not mutable"))
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.WalletID":
		panic(fmt.Errorf("field WalletID of message qadena.qadena.EncryptableClaimCredentialExtraParms is not mutable"))
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.EncWalletIDVShare":
		panic(fmt.Errorf("field EncWalletIDVShare of message qadena.qadena.EncryptableClaimCredentialExtraParms is not mutable"))
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.EncCredentialHashVShare":
		panic(fmt.Errorf("field EncCredentialHashVShare of message qadena.qadena.EncryptableClaimCredentialExtraParms is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableClaimCredentialExtraParms"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableClaimCredentialExtraParms does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EncryptableClaimCredentialExtraParms) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.EncCredentialInfoVShare":
		return protoreflect.ValueOfBytes(nil)
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.CredentialInfoVShareBind":
		m := new(VShareBindData)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.WalletID":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.FindCredentialPC":
		m := new(BPedersenCommit)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.NewCredentialPC":
		m := new(BPedersenCommit)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.EncWalletIDVShare":
		return protoreflect.ValueOfBytes(nil)
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.WalletIDVShareBind":
		m := new(VShareBindData)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.EncCredentialHashVShare":
		return protoreflect.ValueOfBytes(nil)
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.CredentialHashVShareBind":
		m := new(VShareBindData)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.ZeroPC":
		m := new(EncryptablePedersenCommit)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "qadena.qadena.EncryptableClaimCredentialExtraParms.ClaimPC":
		m := new(BPedersenCommit)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableClaimCredentialExtraParms"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableClaimCredentialExtraParms does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EncryptableClaimCredentialExtraParms) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in qadena.qadena.EncryptableClaimCredentialExtraParms", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EncryptableClaimCredentialExtraParms) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableClaimCredentialExtraParms) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EncryptableClaimCredentialExtraParms) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EncryptableClaimCredentialExtraParms) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EncryptableClaimCredentialExtraParms)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.EncCredentialInfoVShare)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.CredentialInfoVShareBind != nil {
			l = options.Size(x.CredentialInfoVShareBind)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.WalletID)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.FindCredentialPC != nil {
			l = options.Size(x.FindCredentialPC)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.NewCredentialPC != nil {
			l = options.Size(x.NewCredentialPC)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.EncWalletIDVShare)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.WalletIDVShareBind != nil {
			l = options.Size(x.WalletIDVShareBind)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.EncCredentialHashVShare)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.CredentialHashVShareBind != nil {
			l = options.Size(x.CredentialHashVShareBind)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.ZeroPC != nil {
			l = options.Size(x.ZeroPC)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.ClaimPC != nil {
			l = options.Size(x.ClaimPC)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableClaimCredentialExtraParms)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.ClaimPC != nil {
			encoded, err := options.Marshal(x.ClaimPC)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x5a
		}
		if x.ZeroPC != nil {
			encoded, err := options.Marshal(x.ZeroPC)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x52
		}
		if x.CredentialHashVShareBind != nil {
			encoded, err := options.Marshal(x.CredentialHashVShareBind)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x4a
		}
		if len(x.EncCredentialHashVShare) > 0 {
			i -= len(x.EncCredentialHashVShare)
			copy(dAtA[i:], x.EncCredentialHashVShare)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.EncCredentialHashVShare)))
			i--
			dAtA[i] = 0x42
		}
		if x.WalletIDVShareBind != nil {
			encoded, err := options.Marshal(x.WalletIDVShareBind)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x3a
		}
		if len(x.EncWalletIDVShare) > 0 {
			i -= len(x.EncWalletIDVShare)
			copy(dAtA[i:], x.EncWalletIDVShare)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.EncWalletIDVShare)))
			i--
			dAtA[i] = 0x32
		}
		if x.NewCredentialPC != nil {
			encoded, err := options.Marshal(x.NewCredentialPC)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x2a
		}
		if x.FindCredentialPC != nil {
			encoded, err := options.Marshal(x.FindCredentialPC)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.WalletID) > 0 {
			i -= len(x.WalletID)
			copy(dAtA[i:], x.WalletID)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.WalletID)))
			i--
			dAtA[i] = 0x1a
		}
		if x.CredentialInfoVShareBind != nil {
			encoded, err := options.Marshal(x.CredentialInfoVShareBind)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.EncCredentialInfoVShare) > 0 {
			i -= len(x.EncCredentialInfoVShare)
			copy(dAtA[i:], x.EncCredentialInfoVShare)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.EncCredentialInfoVShare)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableClaimCredentialExtraParms)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableClaimCredentialExtraParms: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableClaimCredentialExtraParms: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field EncCredentialInfoVShare", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.EncCredentialInfoVShare = append(x.EncCredentialInfoVShare[:0], dAtA[iNdEx:postIndex]...)
				if x.EncCredentialInfoVShare == nil {
					x.EncCredentialInfoVShare = []byte{}
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CredentialInfoVShareBind", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.CredentialInfoVShareBind == nil {
					x.CredentialInfoVShareBind = &VShareBindData{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.CredentialInfoVShareBind); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field WalletID", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.WalletID = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field FindCredentialPC", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.FindCredentialPC == nil {
					x.FindCredentialPC = &BPedersenCommit{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.FindCredentialPC); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NewCredentialPC", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.NewCredentialPC == nil {
					x.NewCredentialPC = &BPedersenCommit{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.NewCredentialPC); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field EncWalletIDVShare", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.EncWalletIDVShare = append(x.EncWalletIDVShare[:0], dAtA[iNdEx:postIndex]...)
				if x.EncWalletIDVShare == nil {
					x.EncWalletIDVShare = []byte{}
				}
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field WalletIDVShareBind", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.WalletIDVShareBind == nil {
					x.WalletIDVShareBind = &VShareBindData{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.WalletIDVShareBind); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 8:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field EncCredentialHashVShare", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.EncCredentialHashVShare = append(x.EncCredentialHashVShare[:0], dAtA[iNdEx:postIndex]...)
				if x.EncCredentialHashVShare == nil {
					x.EncCredentialHashVShare = []byte{}
				}
				iNdEx = postIndex
			case 9:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CredentialHashVShareBind", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.CredentialHashVShareBind == nil {
					x.CredentialHashVShareBind = &VShareBindData{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.CredentialHashVShareBind); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 10:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ZeroPC", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.ZeroPC == nil {
					x.ZeroPC = &EncryptablePedersenCommit{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ZeroPC); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 11:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ClaimPC", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.ClaimPC == nil {
					x.ClaimPC = &BPedersenCommit{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ClaimPC); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EncryptableAuthorizedSignatory          protoreflect.MessageDescriptor
	fd_EncryptableAuthorizedSignatory_Nonce    protoreflect.FieldDescriptor
	fd_EncryptableAuthorizedSignatory_WalletID protoreflect.FieldDescriptor
)

func init() {
	file_qadena_qadena_encryptable_proto_init()
	md_EncryptableAuthorizedSignatory = File_qadena_qadena_encryptable_proto.Messages().ByName("EncryptableAuthorizedSignatory")
	fd_EncryptableAuthorizedSignatory_Nonce = md_EncryptableAuthorizedSignatory.Fields().ByName("Nonce")
	fd_EncryptableAuthorizedSignatory_WalletID = md_EncryptableAuthorizedSignatory.Fields().ByName("WalletID")
}

var _ protoreflect.Message = (*fastReflection_EncryptableAuthorizedSignatory)(nil)

type fastReflection_EncryptableAuthorizedSignatory EncryptableAuthorizedSignatory

func (x *EncryptableAuthorizedSignatory) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EncryptableAuthorizedSignatory)(x)
}

func (x *EncryptableAuthorizedSignatory) slowProtoReflect() protoreflect.Message {
	mi := &file_qadena_qadena_encryptable_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EncryptableAuthorizedSignatory_messageType fastReflection_EncryptableAuthorizedSignatory_messageType
var _ protoreflect.MessageType = fastReflection_EncryptableAuthorizedSignatory_messageType{}

type fastReflection_EncryptableAuthorizedSignatory_messageType struct{}

func (x fastReflection_EncryptableAuthorizedSignatory_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EncryptableAuthorizedSignatory)(nil)
}
func (x fastReflection_EncryptableAuthorizedSignatory_messageType) New() protoreflect.Message {
	return new(fastReflection_EncryptableAuthorizedSignatory)
}
func (x fastReflection_EncryptableAuthorizedSignatory_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableAuthorizedSignatory
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EncryptableAuthorizedSignatory) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableAuthorizedSignatory
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EncryptableAuthorizedSignatory) Type() protoreflect.MessageType {
	return _fastReflection_EncryptableAuthorizedSignatory_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EncryptableAuthorizedSignatory) New() protoreflect.Message {
	return new(fastReflection_EncryptableAuthorizedSignatory)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EncryptableAuthorizedSignatory) Interface() protoreflect.ProtoMessage {
	return (*EncryptableAuthorizedSignatory)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EncryptableAuthorizedSignatory) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Nonce != "" {
		value := protoreflect.ValueOfString(x.Nonce)
		if !f(fd_EncryptableAuthorizedSignatory_Nonce, value) {
			return
		}
	}
	if x.WalletID != "" {
		value := protoreflect.ValueOfString(x.WalletID)
		if !f(fd_EncryptableAuthorizedSignatory_WalletID, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EncryptableAuthorizedSignatory) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableAuthorizedSignatory.Nonce":
		return x.Nonce != ""
	case "qadena.qadena.EncryptableAuthorizedSignatory.WalletID":
		return x.WalletID != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableAuthorizedSignatory"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableAuthorizedSignatory does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableAuthorizedSignatory) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableAuthorizedSignatory.Nonce":
		x.Nonce = ""
	case "qadena.qadena.EncryptableAuthorizedSignatory.WalletID":
		x.WalletID = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableAuthorizedSignatory"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableAuthorizedSignatory does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EncryptableAuthorizedSignatory) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "qadena.qadena.EncryptableAuthorizedSignatory.Nonce":
		value := x.Nonce
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableAuthorizedSignatory.WalletID":
		value := x.WalletID
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableAuthorizedSignatory"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableAuthorizedSignatory does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableAuthorizedSignatory) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableAuthorizedSignatory.Nonce":
		x.Nonce = value.Interface().(string)
	case "qadena.qadena.EncryptableAuthorizedSignatory.WalletID":
		x.WalletID = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableAuthorizedSignatory"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableAuthorizedSignatory does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableAuthorizedSignatory) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableAuthorizedSignatory.Nonce":
		panic(fmt.Errorf("field Nonce of message qadena.qadena.EncryptableAuthorizedSignatory is not mutable"))
	case "qadena.qadena.EncryptableAuthorizedSignatory.WalletID":
		panic(fmt.Errorf("field WalletID of message qadena.qadena.EncryptableAuthorizedSignatory is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableAuthorizedSignatory"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableAuthorizedSignatory does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EncryptableAuthorizedSignatory) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableAuthorizedSignatory.Nonce":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableAuthorizedSignatory.WalletID":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableAuthorizedSignatory"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableAuthorizedSignatory does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EncryptableAuthorizedSignatory) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in qadena.qadena.EncryptableAuthorizedSignatory", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EncryptableAuthorizedSignatory) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableAuthorizedSignatory) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EncryptableAuthorizedSignatory) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EncryptableAuthorizedSignatory) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EncryptableAuthorizedSignatory)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Nonce)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.WalletID)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableAuthorizedSignatory)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.WalletID) > 0 {
			i -= len(x.WalletID)
			copy(dAtA[i:], x.WalletID)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.WalletID)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Nonce) > 0 {
			i -= len(x.Nonce)
			copy(dAtA[i:], x.Nonce)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Nonce)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableAuthorizedSignatory)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableAuthorizedSignatory: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableAuthorizedSignatory: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Nonce = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field WalletID", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.WalletID = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EncryptableSignatory             protoreflect.MessageDescriptor
	fd_EncryptableSignatory_Nonce       protoreflect.FieldDescriptor
	fd_EncryptableSignatory_Email       protoreflect.FieldDescriptor
	fd_EncryptableSignatory_PhoneNumber protoreflect.FieldDescriptor
)

func init() {
	file_qadena_qadena_encryptable_proto_init()
	md_EncryptableSignatory = File_qadena_qadena_encryptable_proto.Messages().ByName("EncryptableSignatory")
	fd_EncryptableSignatory_Nonce = md_EncryptableSignatory.Fields().ByName("Nonce")
	fd_EncryptableSignatory_Email = md_EncryptableSignatory.Fields().ByName("Email")
	fd_EncryptableSignatory_PhoneNumber = md_EncryptableSignatory.Fields().ByName("PhoneNumber")
}

var _ protoreflect.Message = (*fastReflection_EncryptableSignatory)(nil)

type fastReflection_EncryptableSignatory EncryptableSignatory

func (x *EncryptableSignatory) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EncryptableSignatory)(x)
}

func (x *EncryptableSignatory) slowProtoReflect() protoreflect.Message {
	mi := &file_qadena_qadena_encryptable_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EncryptableSignatory_messageType fastReflection_EncryptableSignatory_messageType
var _ protoreflect.MessageType = fastReflection_EncryptableSignatory_messageType{}

type fastReflection_EncryptableSignatory_messageType struct{}

func (x fastReflection_EncryptableSignatory_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EncryptableSignatory)(nil)
}
func (x fastReflection_EncryptableSignatory_messageType) New() protoreflect.Message {
	return new(fastReflection_EncryptableSignatory)
}
func (x fastReflection_EncryptableSignatory_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableSignatory
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EncryptableSignatory) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableSignatory
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EncryptableSignatory) Type() protoreflect.MessageType {
	return _fastReflection_EncryptableSignatory_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EncryptableSignatory) New() protoreflect.Message {
	return new(fastReflection_EncryptableSignatory)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EncryptableSignatory) Interface() protoreflect.ProtoMessage {
	return (*EncryptableSignatory)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EncryptableSignatory) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Nonce != "" {
		value := protoreflect.ValueOfString(x.Nonce)
		if !f(fd_EncryptableSignatory_Nonce, value) {
			return
		}
	}
	if x.Email != "" {
		value := protoreflect.ValueOfString(x.Email)
		if !f(fd_EncryptableSignatory_Email, value) {
			return
		}
	}
	if x.PhoneNumber != "" {
		value := protoreflect.ValueOfString(x.PhoneNumber)
		if !f(fd_EncryptableSignatory_PhoneNumber, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EncryptableSignatory) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSignatory.Nonce":
		return x.Nonce != ""
	case "qadena.qadena.EncryptableSignatory.Email":
		return x.Email != ""
	case "qadena.qadena.EncryptableSignatory.PhoneNumber":
		return x.PhoneNumber != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSignatory"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSignatory does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableSignatory) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSignatory.Nonce":
		x.Nonce = ""
	case "qadena.qadena.EncryptableSignatory.Email":
		x.Email = ""
	case "qadena.qadena.EncryptableSignatory.PhoneNumber":
		x.PhoneNumber = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSignatory"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSignatory does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EncryptableSignatory) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "qadena.qadena.EncryptableSignatory.Nonce":
		value := x.Nonce
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableSignatory.Email":
		value := x.Email
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableSignatory.PhoneNumber":
		value := x.PhoneNumber
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSignatory"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSignatory does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableSignatory) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSignatory.Nonce":
		x.Nonce = value.Interface().(string)
	case "qadena.qadena.EncryptableSignatory.Email":
		x.Email = value.Interface().(string)
	case "qadena.qadena.EncryptableSignatory.PhoneNumber":
		x.PhoneNumber = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSignatory"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSignatory does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableSignatory) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSignatory.Nonce":
		panic(fmt.Errorf("field Nonce of message qadena.qadena.EncryptableSignatory is not mutable"))
	case "qadena.qadena.EncryptableSignatory.Email":
		panic(fmt.Errorf("field Email of message qadena.qadena.EncryptableSignatory is not mutable"))
	case "qadena.qadena.EncryptableSignatory.PhoneNumber":
		panic(fmt.Errorf("field PhoneNumber of message qadena.qadena.EncryptableSignatory is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSignatory"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSignatory does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EncryptableSignatory) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSignatory.Nonce":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableSignatory.Email":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableSignatory.PhoneNumber":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSignatory"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSignatory does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EncryptableSignatory) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in qadena.qadena.EncryptableSignatory", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EncryptableSignatory) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableSignatory) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EncryptableSignatory) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EncryptableSignatory) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EncryptableSignatory)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Nonce)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Email)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PhoneNumber)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableSignatory)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.PhoneNumber) > 0 {
			i -= len(x.PhoneNumber)
			copy(dAtA[i:], x.PhoneNumber)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PhoneNumber)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Email) > 0 {
			i -= len(x.Email)
			copy(dAtA[i:], x.Email)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Email)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Nonce) > 0 {
			i -= len(x.Nonce)
			copy(dAtA[i:], x.Nonce)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Nonce)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableSignatory)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableSignatory: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableSignatory: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Nonce = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Email = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PhoneNumber = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EncryptableWalletAmount                          protoreflect.MessageDescriptor
	fd_EncryptableWalletAmount_Nonce                    protoreflect.FieldDescriptor
	fd_EncryptableWalletAmount_TransactionID            protoreflect.FieldDescriptor
	fd_EncryptableWalletAmount_PedersenCommit           protoreflect.FieldDescriptor
	fd_EncryptableWalletAmount_Note                     protoreflect.FieldDescriptor
	fd_EncryptableWalletAmount_RequiredSenderPIN        protoreflect.FieldDescriptor
	fd_EncryptableWalletAmount_RequiredSenderFirstName  protoreflect.FieldDescriptor
	fd_EncryptableWalletAmount_RequiredSenderMiddleName protoreflect.FieldDescriptor
	fd_EncryptableWalletAmount_RequiredSenderLastName   protoreflect.FieldDescriptor
)

func init() {
	file_qadena_qadena_encryptable_proto_init()
	md_EncryptableWalletAmount = File_qadena_qadena_encryptable_proto.Messages().ByName("EncryptableWalletAmount")
	fd_EncryptableWalletAmount_Nonce = md_EncryptableWalletAmount.Fields().ByName("Nonce")
	fd_EncryptableWalletAmount_TransactionID = md_EncryptableWalletAmount.Fields().ByName("TransactionID")
	fd_EncryptableWalletAmount_PedersenCommit = md_EncryptableWalletAmount.Fields().ByName("PedersenCommit")
	fd_EncryptableWalletAmount_Note = md_EncryptableWalletAmount.Fields().ByName("Note")
	fd_EncryptableWalletAmount_RequiredSenderPIN = md_EncryptableWalletAmount.Fields().ByName("RequiredSenderPIN")
	fd_EncryptableWalletAmount_RequiredSenderFirstName = md_EncryptableWalletAmount.Fields().ByName("RequiredSenderFirstName")
	fd_EncryptableWalletAmount_RequiredSenderMiddleName = md_EncryptableWalletAmount.Fields().ByName("RequiredSenderMiddleName")
	fd_EncryptableWalletAmount_RequiredSenderLastName = md_EncryptableWalletAmount.Fields().ByName("RequiredSenderLastName")
}

var _ protoreflect.Message = (*fastReflection_EncryptableWalletAmount)(nil)

type fastReflection_EncryptableWalletAmount EncryptableWalletAmount

func (x *EncryptableWalletAmount) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EncryptableWalletAmount)(x)
}

func (x *EncryptableWalletAmount) slowProtoReflect() protoreflect.Message {
	mi := &file_qadena_qadena_encryptable_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EncryptableWalletAmount_messageType fastReflection_EncryptableWalletAmount_messageType
var _ protoreflect.MessageType = fastReflection_EncryptableWalletAmount_messageType{}

type fastReflection_EncryptableWalletAmount_messageType struct{}

func (x fastReflection_EncryptableWalletAmount_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EncryptableWalletAmount)(nil)
}
func (x fastReflection_EncryptableWalletAmount_messageType) New() protoreflect.Message {
	return new(fastReflection_EncryptableWalletAmount)
}
func (x fastReflection_EncryptableWalletAmount_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableWalletAmount
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EncryptableWalletAmount) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableWalletAmount
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EncryptableWalletAmount) Type() protoreflect.MessageType {
	return _fastReflection_EncryptableWalletAmount_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EncryptableWalletAmount) New() protoreflect.Message {
	return new(fastReflection_EncryptableWalletAmount)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EncryptableWalletAmount) Interface() protoreflect.ProtoMessage {
	return (*EncryptableWalletAmount)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EncryptableWalletAmount) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Nonce != "" {
		value := protoreflect.ValueOfString(x.Nonce)
		if !f(fd_EncryptableWalletAmount_Nonce, value) {
			return
		}
	}
	if x.TransactionID != "" {
		value := protoreflect.ValueOfString(x.TransactionID)
		if !f(fd_EncryptableWalletAmount_TransactionID, value) {
			return
		}
	}
	if x.PedersenCommit != nil {
		value := protoreflect.ValueOfMessage(x.PedersenCommit.ProtoReflect())
		if !f(fd_EncryptableWalletAmount_PedersenCommit, value) {
			return
		}
	}
	if x.Note != "" {
		value := protoreflect.ValueOfString(x.Note)
		if !f(fd_EncryptableWalletAmount_Note, value) {
			return
		}
	}
	if x.RequiredSenderPIN != "" {
		value := protoreflect.ValueOfString(x.RequiredSenderPIN)
		if !f(fd_EncryptableWalletAmount_RequiredSenderPIN, value) {
			return
		}
	}
	if x.RequiredSenderFirstName != "" {
		value := protoreflect.ValueOfString(x.RequiredSenderFirstName)
		if !f(fd_EncryptableWalletAmount_RequiredSenderFirstName, value) {
			return
		}
	}
	if x.RequiredSenderMiddleName != "" {
		value := protoreflect.ValueOfString(x.RequiredSenderMiddleName)
		if !f(fd_EncryptableWalletAmount_RequiredSenderMiddleName, value) {
			return
		}
	}
	if x.RequiredSenderLastName != "" {
		value := protoreflect.ValueOfString(x.RequiredSenderLastName)
		if !f(fd_EncryptableWalletAmount_RequiredSenderLastName, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EncryptableWalletAmount) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableWalletAmount.Nonce":
		return x.Nonce != ""
	case "qadena.qadena.EncryptableWalletAmount.TransactionID":
		return x.TransactionID != ""
	case "qadena.qadena.EncryptableWalletAmount.PedersenCommit":
		return x.PedersenCommit != nil
	case "qadena.qadena.EncryptableWalletAmount.Note":
		return x.Note != ""
	case "qadena.qadena.EncryptableWalletAmount.RequiredSenderPIN":
		return x.RequiredSenderPIN != ""
	case "qadena.qadena.EncryptableWalletAmount.RequiredSenderFirstName":
		return x.RequiredSenderFirstName != ""
	case "qadena.qadena.EncryptableWalletAmount.RequiredSenderMiddleName":
		return x.RequiredSenderMiddleName != ""
	case "qadena.qadena.EncryptableWalletAmount.RequiredSenderLastName":
		return x.RequiredSenderLastName != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableWalletAmount"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableWalletAmount does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableWalletAmount) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableWalletAmount.Nonce":
		x.Nonce = ""
	case "qadena.qadena.EncryptableWalletAmount.TransactionID":
		x.TransactionID = ""
	case "qadena.qadena.EncryptableWalletAmount.PedersenCommit":
		x.PedersenCommit = nil
	case "qadena.qadena.EncryptableWalletAmount.Note":
		x.Note = ""
	case "qadena.qadena.EncryptableWalletAmount.RequiredSenderPIN":
		x.RequiredSenderPIN = ""
	case "qadena.qadena.EncryptableWalletAmount.RequiredSenderFirstName":
		x.RequiredSenderFirstName = ""
	case "qadena.qadena.EncryptableWalletAmount.RequiredSenderMiddleName":
		x.RequiredSenderMiddleName = ""
	case "qadena.qadena.EncryptableWalletAmount.RequiredSenderLastName":
		x.RequiredSenderLastName = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableWalletAmount"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableWalletAmount does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EncryptableWalletAmount) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "qadena.qadena.EncryptableWalletAmount.Nonce":
		value := x.Nonce
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableWalletAmount.TransactionID":
		value := x.TransactionID
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableWalletAmount.PedersenCommit":
		value := x.PedersenCommit
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "qadena.qadena.EncryptableWalletAmount.Note":
		value := x.Note
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableWalletAmount.RequiredSenderPIN":
		value := x.RequiredSenderPIN
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableWalletAmount.RequiredSenderFirstName":
		value := x.RequiredSenderFirstName
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableWalletAmount.RequiredSenderMiddleName":
		value := x.RequiredSenderMiddleName
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableWalletAmount.RequiredSenderLastName":
		value := x.RequiredSenderLastName
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableWalletAmount"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableWalletAmount does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableWalletAmount) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableWalletAmount.Nonce":
		x.Nonce = value.Interface().(string)
	case "qadena.qadena.EncryptableWalletAmount.TransactionID":
		x.TransactionID = value.Interface().(string)
	case "qadena.qadena.EncryptableWalletAmount.PedersenCommit":
		x.PedersenCommit = value.Message().Interface().(*EncryptablePedersenCommit)
	case "qadena.qadena.EncryptableWalletAmount.Note":
		x.Note = value.Interface().(string)
	case "qadena.qadena.EncryptableWalletAmount.RequiredSenderPIN":
		x.RequiredSenderPIN = value.Interface().(string)
	case "qadena.qadena.EncryptableWalletAmount.RequiredSenderFirstName":
		x.RequiredSenderFirstName = value.Interface().(string)
	case "qadena.qadena.EncryptableWalletAmount.RequiredSenderMiddleName":
		x.RequiredSenderMiddleName = value.Interface().(string)
	case "qadena.qadena.EncryptableWalletAmount.RequiredSenderLastName":
		x.RequiredSenderLastName = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableWalletAmount"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableWalletAmount does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableWalletAmount) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableWalletAmount.PedersenCommit":
		if x.PedersenCommit == nil {
			x.PedersenCommit = new(EncryptablePedersenCommit)
		}
		return protoreflect.ValueOfMessage(x.PedersenCommit.ProtoReflect())
	case "qadena.qadena.EncryptableWalletAmount.Nonce":
		panic(fmt.Errorf("field Nonce of message qadena.qadena.EncryptableWalletAmount is not mutable"))
	case "qadena.qadena.EncryptableWalletAmount.TransactionID":
		panic(fmt.Errorf("field TransactionID of message qadena.qadena.EncryptableWalletAmount is not mutable"))
	case "qadena.qadena.EncryptableWalletAmount.Note":
		panic(fmt.Errorf("field Note of message qadena.qadena.EncryptableWalletAmount is not mutable"))
	case "qadena.qadena.EncryptableWalletAmount.RequiredSenderPIN":
		panic(fmt.Errorf("field RequiredSenderPIN of message qadena.qadena.EncryptableWalletAmount is not mutable"))
	case "qadena.qadena.EncryptableWalletAmount.RequiredSenderFirstName":
		panic(fmt.Errorf("field RequiredSenderFirstName of message qadena.qadena.EncryptableWalletAmount is not mutable"))
	case "qadena.qadena.EncryptableWalletAmount.RequiredSenderMiddleName":
		panic(fmt.Errorf("field RequiredSenderMiddleName of message qadena.qadena.EncryptableWalletAmount is not mutable"))
	case "qadena.qadena.EncryptableWalletAmount.RequiredSenderLastName":
		panic(fmt.Errorf("field RequiredSenderLastName of message qadena.qadena.EncryptableWalletAmount is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableWalletAmount"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableWalletAmount does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EncryptableWalletAmount) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableWalletAmount.Nonce":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableWalletAmount.TransactionID":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableWalletAmount.PedersenCommit":
		m := new(EncryptablePedersenCommit)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "qadena.qadena.EncryptableWalletAmount.Note":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableWalletAmount.RequiredSenderPIN":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableWalletAmount.RequiredSenderFirstName":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableWalletAmount.RequiredSenderMiddleName":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableWalletAmount.RequiredSenderLastName":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableWalletAmount"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableWalletAmount does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EncryptableWalletAmount) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in qadena.qadena.EncryptableWalletAmount", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EncryptableWalletAmount) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableWalletAmount) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EncryptableWalletAmount) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EncryptableWalletAmount) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EncryptableWalletAmount)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Nonce)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.TransactionID)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.PedersenCommit != nil {
			l = options.Size(x.PedersenCommit)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Note)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.RequiredSenderPIN)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.RequiredSenderFirstName)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.RequiredSenderMiddleName)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.RequiredSenderLastName)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableWalletAmount)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.RequiredSenderLastName) > 0 {
			i -= len(x.RequiredSenderLastName)
			copy(dAtA[i:], x.RequiredSenderLastName)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RequiredSenderLastName)))
			i--
			dAtA[i] = 0x42
		}
		if len(x.RequiredSenderMiddleName) > 0 {
			i -= len(x.RequiredSenderMiddleName)
			copy(dAtA[i:], x.RequiredSenderMiddleName)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RequiredSenderMiddleName)))
			i--
			dAtA[i] = 0x3a
		}
		if len(x.RequiredSenderFirstName) > 0 {
			i -= len(x.RequiredSenderFirstName)
			copy(dAtA[i:], x.RequiredSenderFirstName)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RequiredSenderFirstName)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.RequiredSenderPIN) > 0 {
			i -= len(x.RequiredSenderPIN)
			copy(dAtA[i:], x.RequiredSenderPIN)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RequiredSenderPIN)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.Note) > 0 {
			i -= len(x.Note)
			copy(dAtA[i:], x.Note)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Note)))
			i--
			dAtA[i] = 0x22
		}
		if x.PedersenCommit != nil {
			encoded, err := options.Marshal(x.PedersenCommit)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.TransactionID) > 0 {
			i -= len(x.TransactionID)
			copy(dAtA[i:], x.TransactionID)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.TransactionID)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Nonce) > 0 {
			i -= len(x.Nonce)
			copy(dAtA[i:], x.Nonce)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Nonce)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableWalletAmount)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableWalletAmount: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableWalletAmount: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Nonce = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TransactionID", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.TransactionID = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PedersenCommit", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.PedersenCommit == nil {
					x.PedersenCommit = &EncryptablePedersenCommit{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.PedersenCommit); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Note = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RequiredSenderPIN", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RequiredSenderPIN = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RequiredSenderFirstName", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RequiredSenderFirstName = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RequiredSenderMiddleName", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RequiredSenderMiddleName = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 8:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RequiredSenderLastName", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RequiredSenderLastName = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EncryptablePersonalInfoDetails             protoreflect.MessageDescriptor
	fd_EncryptablePersonalInfoDetails_FirstName   protoreflect.FieldDescriptor
	fd_EncryptablePersonalInfoDetails_MiddleName  protoreflect.FieldDescriptor
	fd_EncryptablePersonalInfoDetails_LastName    protoreflect.FieldDescriptor
	fd_EncryptablePersonalInfoDetails_Birthdate   protoreflect.FieldDescriptor
	fd_EncryptablePersonalInfoDetails_Citizenship protoreflect.FieldDescriptor
	fd_EncryptablePersonalInfoDetails_Residency   protoreflect.FieldDescriptor
	fd_EncryptablePersonalInfoDetails_Gender      protoreflect.FieldDescriptor
)

func init() {
	file_qadena_qadena_encryptable_proto_init()
	md_EncryptablePersonalInfoDetails = File_qadena_qadena_encryptable_proto.Messages().ByName("EncryptablePersonalInfoDetails")
	fd_EncryptablePersonalInfoDetails_FirstName = md_EncryptablePersonalInfoDetails.Fields().ByName("FirstName")
	fd_EncryptablePersonalInfoDetails_MiddleName = md_EncryptablePersonalInfoDetails.Fields().ByName("MiddleName")
	fd_EncryptablePersonalInfoDetails_LastName = md_EncryptablePersonalInfoDetails.Fields().ByName("LastName")
	fd_EncryptablePersonalInfoDetails_Birthdate = md_EncryptablePersonalInfoDetails.Fields().ByName("Birthdate")
	fd_EncryptablePersonalInfoDetails_Citizenship = md_EncryptablePersonalInfoDetails.Fields().ByName("Citizenship")
	fd_EncryptablePersonalInfoDetails_Residency = md_EncryptablePersonalInfoDetails.Fields().ByName("Residency")
	fd_EncryptablePersonalInfoDetails_Gender = md_EncryptablePersonalInfoDetails.Fields().ByName("Gender")
}

var _ protoreflect.Message = (*fastReflection_EncryptablePersonalInfoDetails)(nil)

type fastReflection_EncryptablePersonalInfoDetails EncryptablePersonalInfoDetails

func (x *EncryptablePersonalInfoDetails) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EncryptablePersonalInfoDetails)(x)
}

func (x *EncryptablePersonalInfoDetails) slowProtoReflect() protoreflect.Message {
	mi := &file_qadena_qadena_encryptable_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EncryptablePersonalInfoDetails_messageType fastReflection_EncryptablePersonalInfoDetails_messageType
var _ protoreflect.MessageType = fastReflection_EncryptablePersonalInfoDetails_messageType{}

type fastReflection_EncryptablePersonalInfoDetails_messageType struct{}

func (x fastReflection_EncryptablePersonalInfoDetails_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EncryptablePersonalInfoDetails)(nil)
}
func (x fastReflection_EncryptablePersonalInfoDetails_messageType) New() protoreflect.Message {
	return new(fastReflection_EncryptablePersonalInfoDetails)
}
func (x fastReflection_EncryptablePersonalInfoDetails_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptablePersonalInfoDetails
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EncryptablePersonalInfoDetails) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptablePersonalInfoDetails
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EncryptablePersonalInfoDetails) Type() protoreflect.MessageType {
	return _fastReflection_EncryptablePersonalInfoDetails_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EncryptablePersonalInfoDetails) New() protoreflect.Message {
	return new(fastReflection_EncryptablePersonalInfoDetails)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EncryptablePersonalInfoDetails) Interface() protoreflect.ProtoMessage {
	return (*EncryptablePersonalInfoDetails)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EncryptablePersonalInfoDetails) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.FirstName != "" {
		value := protoreflect.ValueOfString(x.FirstName)
		if !f(fd_EncryptablePersonalInfoDetails_FirstName, value) {
			return
		}
	}
	if x.MiddleName != "" {
		value := protoreflect.ValueOfString(x.MiddleName)
		if !f(fd_EncryptablePersonalInfoDetails_MiddleName, value) {
			return
		}
	}
	if x.LastName != "" {
		value := protoreflect.ValueOfString(x.LastName)
		if !f(fd_EncryptablePersonalInfoDetails_LastName, value) {
			return
		}
	}
	if x.Birthdate != "" {
		value := protoreflect.ValueOfString(x.Birthdate)
		if !f(fd_EncryptablePersonalInfoDetails_Birthdate, value) {
			return
		}
	}
	if x.Citizenship != "" {
		value := protoreflect.ValueOfString(x.Citizenship)
		if !f(fd_EncryptablePersonalInfoDetails_Citizenship, value) {
			return
		}
	}
	if x.Residency != "" {
		value := protoreflect.ValueOfString(x.Residency)
		if !f(fd_EncryptablePersonalInfoDetails_Residency, value) {
			return
		}
	}
	if x.Gender != "" {
		value := protoreflect.ValueOfString(x.Gender)
		if !f(fd_EncryptablePersonalInfoDetails_Gender, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EncryptablePersonalInfoDetails) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "qadena.qadena.EncryptablePersonalInfoDetails.FirstName":
		return x.FirstName != ""
	case "qadena.qadena.EncryptablePersonalInfoDetails.MiddleName":
		return x.MiddleName != ""
	case "qadena.qadena.EncryptablePersonalInfoDetails.LastName":
		return x.LastName != ""
	case "qadena.qadena.EncryptablePersonalInfoDetails.Birthdate":
		return x.Birthdate != ""
	case "qadena.qadena.EncryptablePersonalInfoDetails.Citizenship":
		return x.Citizenship != ""
	case "qadena.qadena.EncryptablePersonalInfoDetails.Residency":
		return x.Residency != ""
	case "qadena.qadena.EncryptablePersonalInfoDetails.Gender":
		return x.Gender != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptablePersonalInfoDetails"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptablePersonalInfoDetails does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptablePersonalInfoDetails) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptablePersonalInfoDetails.FirstName":
		x.FirstName = ""
	case "qadena.qadena.EncryptablePersonalInfoDetails.MiddleName":
		x.MiddleName = ""
	case "qadena.qadena.EncryptablePersonalInfoDetails.LastName":
		x.LastName = ""
	case "qadena.qadena.EncryptablePersonalInfoDetails.Birthdate":
		x.Birthdate = ""
	case "qadena.qadena.EncryptablePersonalInfoDetails.Citizenship":
		x.Citizenship = ""
	case "qadena.qadena.EncryptablePersonalInfoDetails.Residency":
		x.Residency = ""
	case "qadena.qadena.EncryptablePersonalInfoDetails.Gender":
		x.Gender = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptablePersonalInfoDetails"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptablePersonalInfoDetails does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EncryptablePersonalInfoDetails) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "qadena.qadena.EncryptablePersonalInfoDetails.FirstName":
		value := x.FirstName
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptablePersonalInfoDetails.MiddleName":
		value := x.MiddleName
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptablePersonalInfoDetails.LastName":
		value := x.LastName
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptablePersonalInfoDetails.Birthdate":
		value := x.Birthdate
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptablePersonalInfoDetails.Citizenship":
		value := x.Citizenship
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptablePersonalInfoDetails.Residency":
		value := x.Residency
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptablePersonalInfoDetails.Gender":
		value := x.Gender
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptablePersonalInfoDetails"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptablePersonalInfoDetails does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptablePersonalInfoDetails) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptablePersonalInfoDetails.FirstName":
		x.FirstName = value.Interface().(string)
	case "qadena.qadena.EncryptablePersonalInfoDetails.MiddleName":
		x.MiddleName = value.Interface().(string)
	case "qadena.qadena.EncryptablePersonalInfoDetails.LastName":
		x.LastName = value.Interface().(string)
	case "qadena.qadena.EncryptablePersonalInfoDetails.Birthdate":
		x.Birthdate = value.Interface().(string)
	case "qadena.qadena.EncryptablePersonalInfoDetails.Citizenship":
		x.Citizenship = value.Interface().(string)
	case "qadena.qadena.EncryptablePersonalInfoDetails.Residency":
		x.Residency = value.Interface().(string)
	case "qadena.qadena.EncryptablePersonalInfoDetails.Gender":
		x.Gender = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptablePersonalInfoDetails"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptablePersonalInfoDetails does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptablePersonalInfoDetails) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptablePersonalInfoDetails.FirstName":
		panic(fmt.Errorf("field FirstName of message qadena.qadena.EncryptablePersonalInfoDetails is not mutable"))
	case "qadena.qadena.EncryptablePersonalInfoDetails.MiddleName":
		panic(fmt.Errorf("field MiddleName of message qadena.qadena.EncryptablePersonalInfoDetails is not mutable"))
	case "qadena.qadena.EncryptablePersonalInfoDetails.LastName":
		panic(fmt.Errorf("field LastName of message qadena.qadena.EncryptablePersonalInfoDetails is not mutable"))
	case "qadena.qadena.EncryptablePersonalInfoDetails.Birthdate":
		panic(fmt.Errorf("field Birthdate of message qadena.qadena.EncryptablePersonalInfoDetails is not mutable"))
	case "qadena.qadena.EncryptablePersonalInfoDetails.Citizenship":
		panic(fmt.Errorf("field Citizenship of message qadena.qadena.EncryptablePersonalInfoDetails is not mutable"))
	case "qadena.qadena.EncryptablePersonalInfoDetails.Residency":
		panic(fmt.Errorf("field Residency of message qadena.qadena.EncryptablePersonalInfoDetails is not mutable"))
	case "qadena.qadena.EncryptablePersonalInfoDetails.Gender":
		panic(fmt.Errorf("field Gender of message qadena.qadena.EncryptablePersonalInfoDetails is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptablePersonalInfoDetails"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptablePersonalInfoDetails does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EncryptablePersonalInfoDetails) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptablePersonalInfoDetails.FirstName":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptablePersonalInfoDetails.MiddleName":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptablePersonalInfoDetails.LastName":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptablePersonalInfoDetails.Birthdate":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptablePersonalInfoDetails.Citizenship":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptablePersonalInfoDetails.Residency":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptablePersonalInfoDetails.Gender":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptablePersonalInfoDetails"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptablePersonalInfoDetails does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EncryptablePersonalInfoDetails) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in qadena.qadena.EncryptablePersonalInfoDetails", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EncryptablePersonalInfoDetails) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptablePersonalInfoDetails) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EncryptablePersonalInfoDetails) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EncryptablePersonalInfoDetails) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EncryptablePersonalInfoDetails)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.FirstName)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.MiddleName)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.LastName)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Birthdate)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Citizenship)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Residency)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Gender)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EncryptablePersonalInfoDetails)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Gender) > 0 {
			i -= len(x.Gender)
			copy(dAtA[i:], x.Gender)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Gender)))
			i--
			dAtA[i] = 0x3a
		}
		if len(x.Residency) > 0 {
			i -= len(x.Residency)
			copy(dAtA[i:], x.Residency)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Residency)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.Citizenship) > 0 {
			i -= len(x.Citizenship)
			copy(dAtA[i:], x.Citizenship)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Citizenship)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.Birthdate) > 0 {
			i -= len(x.Birthdate)
			copy(dAtA[i:], x.Birthdate)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Birthdate)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.LastName) > 0 {
			i -= len(x.LastName)
			copy(dAtA[i:], x.LastName)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.LastName)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.MiddleName) > 0 {
			i -= len(x.MiddleName)
			copy(dAtA[i:], x.MiddleName)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MiddleName)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.FirstName) > 0 {
			i -= len(x.FirstName)
			copy(dAtA[i:], x.FirstName)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.FirstName)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EncryptablePersonalInfoDetails)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptablePersonalInfoDetails: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptablePersonalInfoDetails: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.FirstName = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MiddleName", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MiddleName = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.LastName = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Birthdate", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Birthdate = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Citizenship", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Citizenship = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Residency", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Residency = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Gender", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Gender = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EncryptablePersonalInfo         protoreflect.MessageDescriptor
	fd_EncryptablePersonalInfo_Nonce   protoreflect.FieldDescriptor
	fd_EncryptablePersonalInfo_PIN     protoreflect.FieldDescriptor
	fd_EncryptablePersonalInfo_Details protoreflect.FieldDescriptor
)

func init() {
	file_qadena_qadena_encryptable_proto_init()
	md_EncryptablePersonalInfo = File_qadena_qadena_encryptable_proto.Messages().ByName("EncryptablePersonalInfo")
	fd_EncryptablePersonalInfo_Nonce = md_EncryptablePersonalInfo.Fields().ByName("Nonce")
	fd_EncryptablePersonalInfo_PIN = md_EncryptablePersonalInfo.Fields().ByName("PIN")
	fd_EncryptablePersonalInfo_Details = md_EncryptablePersonalInfo.Fields().ByName("Details")
}

var _ protoreflect.Message = (*fastReflection_EncryptablePersonalInfo)(nil)

type fastReflection_EncryptablePersonalInfo EncryptablePersonalInfo

func (x *EncryptablePersonalInfo) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EncryptablePersonalInfo)(x)
}

func (x *EncryptablePersonalInfo) slowProtoReflect() protoreflect.Message {
	mi := &file_qadena_qadena_encryptable_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EncryptablePersonalInfo_messageType fastReflection_EncryptablePersonalInfo_messageType
var _ protoreflect.MessageType = fastReflection_EncryptablePersonalInfo_messageType{}

type fastReflection_EncryptablePersonalInfo_messageType struct{}

func (x fastReflection_EncryptablePersonalInfo_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EncryptablePersonalInfo)(nil)
}
func (x fastReflection_EncryptablePersonalInfo_messageType) New() protoreflect.Message {
	return new(fastReflection_EncryptablePersonalInfo)
}
func (x fastReflection_EncryptablePersonalInfo_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptablePersonalInfo
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EncryptablePersonalInfo) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptablePersonalInfo
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EncryptablePersonalInfo) Type() protoreflect.MessageType {
	return _fastReflection_EncryptablePersonalInfo_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EncryptablePersonalInfo) New() protoreflect.Message {
	return new(fastReflection_EncryptablePersonalInfo)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EncryptablePersonalInfo) Interface() protoreflect.ProtoMessage {
	return (*EncryptablePersonalInfo)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EncryptablePersonalInfo) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Nonce != "" {
		value := protoreflect.ValueOfString(x.Nonce)
		if !f(fd_EncryptablePersonalInfo_Nonce, value) {
			return
		}
	}
	if x.PIN != "" {
		value := protoreflect.ValueOfString(x.PIN)
		if !f(fd_EncryptablePersonalInfo_PIN, value) {
			return
		}
	}
	if x.Details != nil {
		value := protoreflect.ValueOfMessage(x.Details.ProtoReflect())
		if !f(fd_EncryptablePersonalInfo_Details, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EncryptablePersonalInfo) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "qadena.qadena.EncryptablePersonalInfo.Nonce":
		return x.Nonce != ""
	case "qadena.qadena.EncryptablePersonalInfo.PIN":
		return x.PIN != ""
	case "qadena.qadena.EncryptablePersonalInfo.Details":
		return x.Details != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptablePersonalInfo"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptablePersonalInfo does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptablePersonalInfo) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptablePersonalInfo.Nonce":
		x.Nonce = ""
	case "qadena.qadena.EncryptablePersonalInfo.PIN":
		x.PIN = ""
	case "qadena.qadena.EncryptablePersonalInfo.Details":
		x.Details = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptablePersonalInfo"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptablePersonalInfo does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EncryptablePersonalInfo) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "qadena.qadena.EncryptablePersonalInfo.Nonce":
		value := x.Nonce
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptablePersonalInfo.PIN":
		value := x.PIN
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptablePersonalInfo.Details":
		value := x.Details
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptablePersonalInfo"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptablePersonalInfo does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptablePersonalInfo) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptablePersonalInfo.Nonce":
		x.Nonce = value.Interface().(string)
	case "qadena.qadena.EncryptablePersonalInfo.PIN":
		x.PIN = value.Interface().(string)
	case "qadena.qadena.EncryptablePersonalInfo.Details":
		x.Details = value.Message().Interface().(*EncryptablePersonalInfoDetails)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptablePersonalInfo"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptablePersonalInfo does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptablePersonalInfo) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptablePersonalInfo.Details":
		if x.Details == nil {
			x.Details = new(EncryptablePersonalInfoDetails)
		}
		return protoreflect.ValueOfMessage(x.Details.ProtoReflect())
	case "qadena.qadena.EncryptablePersonalInfo.Nonce":
		panic(fmt.Errorf("field Nonce of message qadena.qadena.EncryptablePersonalInfo is not mutable"))
	case "qadena.qadena.EncryptablePersonalInfo.PIN":
		panic(fmt.Errorf("field PIN of message qadena.qadena.EncryptablePersonalInfo is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptablePersonalInfo"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptablePersonalInfo does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EncryptablePersonalInfo) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptablePersonalInfo.Nonce":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptablePersonalInfo.PIN":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptablePersonalInfo.Details":
		m := new(EncryptablePersonalInfoDetails)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptablePersonalInfo"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptablePersonalInfo does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EncryptablePersonalInfo) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in qadena.qadena.EncryptablePersonalInfo", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EncryptablePersonalInfo) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptablePersonalInfo) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EncryptablePersonalInfo) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EncryptablePersonalInfo) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EncryptablePersonalInfo)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Nonce)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PIN)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Details != nil {
			l = options.Size(x.Details)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EncryptablePersonalInfo)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Details != nil {
			encoded, err := options.Marshal(x.Details)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.PIN) > 0 {
			i -= len(x.PIN)
			copy(dAtA[i:], x.PIN)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PIN)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Nonce) > 0 {
			i -= len(x.Nonce)
			copy(dAtA[i:], x.Nonce)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Nonce)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EncryptablePersonalInfo)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptablePersonalInfo: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptablePersonalInfo: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Nonce = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PIN", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PIN = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Details == nil {
					x.Details = &EncryptablePersonalInfoDetails{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Details); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EncryptableSingleContactInfoDetails         protoreflect.MessageDescriptor
	fd_EncryptableSingleContactInfoDetails_Contact protoreflect.FieldDescriptor
)

func init() {
	file_qadena_qadena_encryptable_proto_init()
	md_EncryptableSingleContactInfoDetails = File_qadena_qadena_encryptable_proto.Messages().ByName("EncryptableSingleContactInfoDetails")
	fd_EncryptableSingleContactInfoDetails_Contact = md_EncryptableSingleContactInfoDetails.Fields().ByName("Contact")
}

var _ protoreflect.Message = (*fastReflection_EncryptableSingleContactInfoDetails)(nil)

type fastReflection_EncryptableSingleContactInfoDetails EncryptableSingleContactInfoDetails

func (x *EncryptableSingleContactInfoDetails) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EncryptableSingleContactInfoDetails)(x)
}

func (x *EncryptableSingleContactInfoDetails) slowProtoReflect() protoreflect.Message {
	mi := &file_qadena_qadena_encryptable_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EncryptableSingleContactInfoDetails_messageType fastReflection_EncryptableSingleContactInfoDetails_messageType
var _ protoreflect.MessageType = fastReflection_EncryptableSingleContactInfoDetails_messageType{}

type fastReflection_EncryptableSingleContactInfoDetails_messageType struct{}

func (x fastReflection_EncryptableSingleContactInfoDetails_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EncryptableSingleContactInfoDetails)(nil)
}
func (x fastReflection_EncryptableSingleContactInfoDetails_messageType) New() protoreflect.Message {
	return new(fastReflection_EncryptableSingleContactInfoDetails)
}
func (x fastReflection_EncryptableSingleContactInfoDetails_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableSingleContactInfoDetails
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EncryptableSingleContactInfoDetails) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableSingleContactInfoDetails
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EncryptableSingleContactInfoDetails) Type() protoreflect.MessageType {
	return _fastReflection_EncryptableSingleContactInfoDetails_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EncryptableSingleContactInfoDetails) New() protoreflect.Message {
	return new(fastReflection_EncryptableSingleContactInfoDetails)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EncryptableSingleContactInfoDetails) Interface() protoreflect.ProtoMessage {
	return (*EncryptableSingleContactInfoDetails)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EncryptableSingleContactInfoDetails) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Contact != "" {
		value := protoreflect.ValueOfString(x.Contact)
		if !f(fd_EncryptableSingleContactInfoDetails_Contact, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EncryptableSingleContactInfoDetails) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSingleContactInfoDetails.Contact":
		return x.Contact != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSingleContactInfoDetails"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSingleContactInfoDetails does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableSingleContactInfoDetails) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSingleContactInfoDetails.Contact":
		x.Contact = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSingleContactInfoDetails"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSingleContactInfoDetails does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EncryptableSingleContactInfoDetails) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "qadena.qadena.EncryptableSingleContactInfoDetails.Contact":
		value := x.Contact
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSingleContactInfoDetails"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSingleContactInfoDetails does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableSingleContactInfoDetails) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSingleContactInfoDetails.Contact":
		x.Contact = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSingleContactInfoDetails"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSingleContactInfoDetails does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableSingleContactInfoDetails) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSingleContactInfoDetails.Contact":
		panic(fmt.Errorf("field Contact of message qadena.qadena.EncryptableSingleContactInfoDetails is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSingleContactInfoDetails"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSingleContactInfoDetails does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EncryptableSingleContactInfoDetails) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSingleContactInfoDetails.Contact":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSingleContactInfoDetails"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSingleContactInfoDetails does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EncryptableSingleContactInfoDetails) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in qadena.qadena.EncryptableSingleContactInfoDetails", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EncryptableSingleContactInfoDetails) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableSingleContactInfoDetails) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EncryptableSingleContactInfoDetails) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EncryptableSingleContactInfoDetails) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EncryptableSingleContactInfoDetails)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Contact)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableSingleContactInfoDetails)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Contact) > 0 {
			i -= len(x.Contact)
			copy(dAtA[i:], x.Contact)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Contact)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableSingleContactInfoDetails)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableSingleContactInfoDetails: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableSingleContactInfoDetails: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Contact", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Contact = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EncryptableSingleContactInfo         protoreflect.MessageDescriptor
	fd_EncryptableSingleContactInfo_Nonce   protoreflect.FieldDescriptor
	fd_EncryptableSingleContactInfo_PIN     protoreflect.FieldDescriptor
	fd_EncryptableSingleContactInfo_Details protoreflect.FieldDescriptor
)

func init() {
	file_qadena_qadena_encryptable_proto_init()
	md_EncryptableSingleContactInfo = File_qadena_qadena_encryptable_proto.Messages().ByName("EncryptableSingleContactInfo")
	fd_EncryptableSingleContactInfo_Nonce = md_EncryptableSingleContactInfo.Fields().ByName("Nonce")
	fd_EncryptableSingleContactInfo_PIN = md_EncryptableSingleContactInfo.Fields().ByName("PIN")
	fd_EncryptableSingleContactInfo_Details = md_EncryptableSingleContactInfo.Fields().ByName("Details")
}

var _ protoreflect.Message = (*fastReflection_EncryptableSingleContactInfo)(nil)

type fastReflection_EncryptableSingleContactInfo EncryptableSingleContactInfo

func (x *EncryptableSingleContactInfo) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EncryptableSingleContactInfo)(x)
}

func (x *EncryptableSingleContactInfo) slowProtoReflect() protoreflect.Message {
	mi := &file_qadena_qadena_encryptable_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EncryptableSingleContactInfo_messageType fastReflection_EncryptableSingleContactInfo_messageType
var _ protoreflect.MessageType = fastReflection_EncryptableSingleContactInfo_messageType{}

type fastReflection_EncryptableSingleContactInfo_messageType struct{}

func (x fastReflection_EncryptableSingleContactInfo_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EncryptableSingleContactInfo)(nil)
}
func (x fastReflection_EncryptableSingleContactInfo_messageType) New() protoreflect.Message {
	return new(fastReflection_EncryptableSingleContactInfo)
}
func (x fastReflection_EncryptableSingleContactInfo_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableSingleContactInfo
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EncryptableSingleContactInfo) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableSingleContactInfo
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EncryptableSingleContactInfo) Type() protoreflect.MessageType {
	return _fastReflection_EncryptableSingleContactInfo_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EncryptableSingleContactInfo) New() protoreflect.Message {
	return new(fastReflection_EncryptableSingleContactInfo)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EncryptableSingleContactInfo) Interface() protoreflect.ProtoMessage {
	return (*EncryptableSingleContactInfo)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EncryptableSingleContactInfo) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Nonce != "" {
		value := protoreflect.ValueOfString(x.Nonce)
		if !f(fd_EncryptableSingleContactInfo_Nonce, value) {
			return
		}
	}
	if x.PIN != "" {
		value := protoreflect.ValueOfString(x.PIN)
		if !f(fd_EncryptableSingleContactInfo_PIN, value) {
			return
		}
	}
	if x.Details != nil {
		value := protoreflect.ValueOfMessage(x.Details.ProtoReflect())
		if !f(fd_EncryptableSingleContactInfo_Details, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EncryptableSingleContactInfo) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSingleContactInfo.Nonce":
		return x.Nonce != ""
	case "qadena.qadena.EncryptableSingleContactInfo.PIN":
		return x.PIN != ""
	case "qadena.qadena.EncryptableSingleContactInfo.Details":
		return x.Details != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSingleContactInfo"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSingleContactInfo does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableSingleContactInfo) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSingleContactInfo.Nonce":
		x.Nonce = ""
	case "qadena.qadena.EncryptableSingleContactInfo.PIN":
		x.PIN = ""
	case "qadena.qadena.EncryptableSingleContactInfo.Details":
		x.Details = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSingleContactInfo"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSingleContactInfo does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EncryptableSingleContactInfo) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "qadena.qadena.EncryptableSingleContactInfo.Nonce":
		value := x.Nonce
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableSingleContactInfo.PIN":
		value := x.PIN
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableSingleContactInfo.Details":
		value := x.Details
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSingleContactInfo"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSingleContactInfo does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableSingleContactInfo) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSingleContactInfo.Nonce":
		x.Nonce = value.Interface().(string)
	case "qadena.qadena.EncryptableSingleContactInfo.PIN":
		x.PIN = value.Interface().(string)
	case "qadena.qadena.EncryptableSingleContactInfo.Details":
		x.Details = value.Message().Interface().(*EncryptableSingleContactInfoDetails)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSingleContactInfo"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSingleContactInfo does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableSingleContactInfo) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSingleContactInfo.Details":
		if x.Details == nil {
			x.Details = new(EncryptableSingleContactInfoDetails)
		}
		return protoreflect.ValueOfMessage(x.Details.ProtoReflect())
	case "qadena.qadena.EncryptableSingleContactInfo.Nonce":
		panic(fmt.Errorf("field Nonce of message qadena.qadena.EncryptableSingleContactInfo is not mutable"))
	case "qadena.qadena.EncryptableSingleContactInfo.PIN":
		panic(fmt.Errorf("field PIN of message qadena.qadena.EncryptableSingleContactInfo is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSingleContactInfo"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSingleContactInfo does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EncryptableSingleContactInfo) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSingleContactInfo.Nonce":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableSingleContactInfo.PIN":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableSingleContactInfo.Details":
		m := new(EncryptableSingleContactInfoDetails)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSingleContactInfo"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSingleContactInfo does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EncryptableSingleContactInfo) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in qadena.qadena.EncryptableSingleContactInfo", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EncryptableSingleContactInfo) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableSingleContactInfo) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EncryptableSingleContactInfo) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EncryptableSingleContactInfo) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EncryptableSingleContactInfo)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Nonce)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PIN)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.Details != nil {
			l = options.Size(x.Details)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableSingleContactInfo)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.Details != nil {
			encoded, err := options.Marshal(x.Details)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.PIN) > 0 {
			i -= len(x.PIN)
			copy(dAtA[i:], x.PIN)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PIN)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Nonce) > 0 {
			i -= len(x.Nonce)
			copy(dAtA[i:], x.Nonce)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Nonce)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableSingleContactInfo)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableSingleContactInfo: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableSingleContactInfo: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Nonce = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PIN", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PIN = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Details == nil {
					x.Details = &EncryptableSingleContactInfoDetails{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Details); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EncryptableValidatedCredential                protoreflect.MessageDescriptor
	fd_EncryptableValidatedCredential_CredentialType protoreflect.FieldDescriptor
	fd_EncryptableValidatedCredential_PIN            protoreflect.FieldDescriptor
	fd_EncryptableValidatedCredential_CredentialPC   protoreflect.FieldDescriptor
)

func init() {
	file_qadena_qadena_encryptable_proto_init()
	md_EncryptableValidatedCredential = File_qadena_qadena_encryptable_proto.Messages().ByName("EncryptableValidatedCredential")
	fd_EncryptableValidatedCredential_CredentialType = md_EncryptableValidatedCredential.Fields().ByName("CredentialType")
	fd_EncryptableValidatedCredential_PIN = md_EncryptableValidatedCredential.Fields().ByName("PIN")
	fd_EncryptableValidatedCredential_CredentialPC = md_EncryptableValidatedCredential.Fields().ByName("CredentialPC")
}

var _ protoreflect.Message = (*fastReflection_EncryptableValidatedCredential)(nil)

type fastReflection_EncryptableValidatedCredential EncryptableValidatedCredential

func (x *EncryptableValidatedCredential) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EncryptableValidatedCredential)(x)
}

func (x *EncryptableValidatedCredential) slowProtoReflect() protoreflect.Message {
	mi := &file_qadena_qadena_encryptable_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EncryptableValidatedCredential_messageType fastReflection_EncryptableValidatedCredential_messageType
var _ protoreflect.MessageType = fastReflection_EncryptableValidatedCredential_messageType{}

type fastReflection_EncryptableValidatedCredential_messageType struct{}

func (x fastReflection_EncryptableValidatedCredential_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EncryptableValidatedCredential)(nil)
}
func (x fastReflection_EncryptableValidatedCredential_messageType) New() protoreflect.Message {
	return new(fastReflection_EncryptableValidatedCredential)
}
func (x fastReflection_EncryptableValidatedCredential_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableValidatedCredential
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EncryptableValidatedCredential) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableValidatedCredential
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EncryptableValidatedCredential) Type() protoreflect.MessageType {
	return _fastReflection_EncryptableValidatedCredential_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EncryptableValidatedCredential) New() protoreflect.Message {
	return new(fastReflection_EncryptableValidatedCredential)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EncryptableValidatedCredential) Interface() protoreflect.ProtoMessage {
	return (*EncryptableValidatedCredential)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EncryptableValidatedCredential) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.CredentialType != "" {
		value := protoreflect.ValueOfString(x.CredentialType)
		if !f(fd_EncryptableValidatedCredential_CredentialType, value) {
			return
		}
	}
	if x.PIN != "" {
		value := protoreflect.ValueOfString(x.PIN)
		if !f(fd_EncryptableValidatedCredential_PIN, value) {
			return
		}
	}
	if x.CredentialPC != nil {
		value := protoreflect.ValueOfMessage(x.CredentialPC.ProtoReflect())
		if !f(fd_EncryptableValidatedCredential_CredentialPC, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EncryptableValidatedCredential) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableValidatedCredential.CredentialType":
		return x.CredentialType != ""
	case "qadena.qadena.EncryptableValidatedCredential.PIN":
		return x.PIN != ""
	case "qadena.qadena.EncryptableValidatedCredential.CredentialPC":
		return x.CredentialPC != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableValidatedCredential"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableValidatedCredential does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableValidatedCredential) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableValidatedCredential.CredentialType":
		x.CredentialType = ""
	case "qadena.qadena.EncryptableValidatedCredential.PIN":
		x.PIN = ""
	case "qadena.qadena.EncryptableValidatedCredential.CredentialPC":
		x.CredentialPC = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableValidatedCredential"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableValidatedCredential does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EncryptableValidatedCredential) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "qadena.qadena.EncryptableValidatedCredential.CredentialType":
		value := x.CredentialType
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableValidatedCredential.PIN":
		value := x.PIN
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableValidatedCredential.CredentialPC":
		value := x.CredentialPC
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableValidatedCredential"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableValidatedCredential does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableValidatedCredential) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableValidatedCredential.CredentialType":
		x.CredentialType = value.Interface().(string)
	case "qadena.qadena.EncryptableValidatedCredential.PIN":
		x.PIN = value.Interface().(string)
	case "qadena.qadena.EncryptableValidatedCredential.CredentialPC":
		x.CredentialPC = value.Message().Interface().(*BPedersenCommit)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableValidatedCredential"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableValidatedCredential does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableValidatedCredential) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableValidatedCredential.CredentialPC":
		if x.CredentialPC == nil {
			x.CredentialPC = new(BPedersenCommit)
		}
		return protoreflect.ValueOfMessage(x.CredentialPC.ProtoReflect())
	case "qadena.qadena.EncryptableValidatedCredential.CredentialType":
		panic(fmt.Errorf("field CredentialType of message qadena.qadena.EncryptableValidatedCredential is not mutable"))
	case "qadena.qadena.EncryptableValidatedCredential.PIN":
		panic(fmt.Errorf("field PIN of message qadena.qadena.EncryptableValidatedCredential is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableValidatedCredential"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableValidatedCredential does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EncryptableValidatedCredential) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableValidatedCredential.CredentialType":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableValidatedCredential.PIN":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableValidatedCredential.CredentialPC":
		m := new(BPedersenCommit)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableValidatedCredential"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableValidatedCredential does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EncryptableValidatedCredential) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in qadena.qadena.EncryptableValidatedCredential", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EncryptableValidatedCredential) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableValidatedCredential) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EncryptableValidatedCredential) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EncryptableValidatedCredential) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EncryptableValidatedCredential)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.CredentialType)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PIN)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.CredentialPC != nil {
			l = options.Size(x.CredentialPC)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableValidatedCredential)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.CredentialPC != nil {
			encoded, err := options.Marshal(x.CredentialPC)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.PIN) > 0 {
			i -= len(x.PIN)
			copy(dAtA[i:], x.PIN)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PIN)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.CredentialType) > 0 {
			i -= len(x.CredentialType)
			copy(dAtA[i:], x.CredentialType)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.CredentialType)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableValidatedCredential)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableValidatedCredential: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableValidatedCredential: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CredentialType", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.CredentialType = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PIN", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PIN = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CredentialPC", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.CredentialPC == nil {
					x.CredentialPC = &BPedersenCommit{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.CredentialPC); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_EncryptableValidatedCredentials_1_list)(nil)

type _EncryptableValidatedCredentials_1_list struct {
	list *[]*EncryptableValidatedCredential
}

func (x *_EncryptableValidatedCredentials_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_EncryptableValidatedCredentials_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfMessage((*x.list)[i].ProtoReflect())
}

func (x *_EncryptableValidatedCredentials_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*EncryptableValidatedCredential)
	(*x.list)[i] = concreteValue
}

func (x *_EncryptableValidatedCredentials_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*EncryptableValidatedCredential)
	*x.list = append(*x.list, concreteValue)
}

func (x *_EncryptableValidatedCredentials_1_list) AppendMutable() protoreflect.Value {
	v := new(EncryptableValidatedCredential)
	*x.list = append(*x.list, v)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_EncryptableValidatedCredentials_1_list) Truncate(n int) {
	for i := n; i < len(*x.list); i++ {
		(*x.list)[i] = nil
	}
	*x.list = (*x.list)[:n]
}

func (x *_EncryptableValidatedCredentials_1_list) NewElement() protoreflect.Value {
	v := new(EncryptableValidatedCredential)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_EncryptableValidatedCredentials_1_list) IsValid() bool {
	return x.list != nil
}

var (
	md_EncryptableValidatedCredentials             protoreflect.MessageDescriptor
	fd_EncryptableValidatedCredentials_Credentials protoreflect.FieldDescriptor
)

func init() {
	file_qadena_qadena_encryptable_proto_init()
	md_EncryptableValidatedCredentials = File_qadena_qadena_encryptable_proto.Messages().ByName("EncryptableValidatedCredentials")
	fd_EncryptableValidatedCredentials_Credentials = md_EncryptableValidatedCredentials.Fields().ByName("Credentials")
}

var _ protoreflect.Message = (*fastReflection_EncryptableValidatedCredentials)(nil)

type fastReflection_EncryptableValidatedCredentials EncryptableValidatedCredentials

func (x *EncryptableValidatedCredentials) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EncryptableValidatedCredentials)(x)
}

func (x *EncryptableValidatedCredentials) slowProtoReflect() protoreflect.Message {
	mi := &file_qadena_qadena_encryptable_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EncryptableValidatedCredentials_messageType fastReflection_EncryptableValidatedCredentials_messageType
var _ protoreflect.MessageType = fastReflection_EncryptableValidatedCredentials_messageType{}

type fastReflection_EncryptableValidatedCredentials_messageType struct{}

func (x fastReflection_EncryptableValidatedCredentials_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EncryptableValidatedCredentials)(nil)
}
func (x fastReflection_EncryptableValidatedCredentials_messageType) New() protoreflect.Message {
	return new(fastReflection_EncryptableValidatedCredentials)
}
func (x fastReflection_EncryptableValidatedCredentials_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableValidatedCredentials
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EncryptableValidatedCredentials) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableValidatedCredentials
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EncryptableValidatedCredentials) Type() protoreflect.MessageType {
	return _fastReflection_EncryptableValidatedCredentials_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EncryptableValidatedCredentials) New() protoreflect.Message {
	return new(fastReflection_EncryptableValidatedCredentials)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EncryptableValidatedCredentials) Interface() protoreflect.ProtoMessage {
	return (*EncryptableValidatedCredentials)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EncryptableValidatedCredentials) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.Credentials) != 0 {
		value := protoreflect.ValueOfList(&_EncryptableValidatedCredentials_1_list{list: &x.Credentials})
		if !f(fd_EncryptableValidatedCredentials_Credentials, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EncryptableValidatedCredentials) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableValidatedCredentials.Credentials":
		return len(x.Credentials) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableValidatedCredentials"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableValidatedCredentials does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableValidatedCredentials) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableValidatedCredentials.Credentials":
		x.Credentials = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableValidatedCredentials"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableValidatedCredentials does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EncryptableValidatedCredentials) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "qadena.qadena.EncryptableValidatedCredentials.Credentials":
		if len(x.Credentials) == 0 {
			return protoreflect.ValueOfList(&_EncryptableValidatedCredentials_1_list{})
		}
		listValue := &_EncryptableValidatedCredentials_1_list{list: &x.Credentials}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableValidatedCredentials"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableValidatedCredentials does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableValidatedCredentials) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableValidatedCredentials.Credentials":
		lv := value.List()
		clv := lv.(*_EncryptableValidatedCredentials_1_list)
		x.Credentials = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableValidatedCredentials"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableValidatedCredentials does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableValidatedCredentials) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableValidatedCredentials.Credentials":
		if x.Credentials == nil {
			x.Credentials = []*EncryptableValidatedCredential{}
		}
		value := &_EncryptableValidatedCredentials_1_list{list: &x.Credentials}
		return protoreflect.ValueOfList(value)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableValidatedCredentials"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableValidatedCredentials does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EncryptableValidatedCredentials) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableValidatedCredentials.Credentials":
		list := []*EncryptableValidatedCredential{}
		return protoreflect.ValueOfList(&_EncryptableValidatedCredentials_1_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableValidatedCredentials"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableValidatedCredentials does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EncryptableValidatedCredentials) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in qadena.qadena.EncryptableValidatedCredentials", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EncryptableValidatedCredentials) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableValidatedCredentials) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EncryptableValidatedCredentials) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EncryptableValidatedCredentials) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EncryptableValidatedCredentials)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.Credentials) > 0 {
			for _, e := range x.Credentials {
				l = options.Size(e)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableValidatedCredentials)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Credentials) > 0 {
			for iNdEx := len(x.Credentials) - 1; iNdEx >= 0; iNdEx-- {
				encoded, err := options.Marshal(x.Credentials[iNdEx])
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0xa
			}
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableValidatedCredentials)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableValidatedCredentials: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableValidatedCredentials: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Credentials", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Credentials = append(x.Credentials, &EncryptableValidatedCredential{})
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.Credentials[len(x.Credentials)-1]); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EncryptableCreateWalletEWalletIDExtraParms         protoreflect.MessageDescriptor
	fd_EncryptableCreateWalletEWalletIDExtraParms_ProofPC protoreflect.FieldDescriptor
)

func init() {
	file_qadena_qadena_encryptable_proto_init()
	md_EncryptableCreateWalletEWalletIDExtraParms = File_qadena_qadena_encryptable_proto.Messages().ByName("EncryptableCreateWalletEWalletIDExtraParms")
	fd_EncryptableCreateWalletEWalletIDExtraParms_ProofPC = md_EncryptableCreateWalletEWalletIDExtraParms.Fields().ByName("ProofPC")
}

var _ protoreflect.Message = (*fastReflection_EncryptableCreateWalletEWalletIDExtraParms)(nil)

type fastReflection_EncryptableCreateWalletEWalletIDExtraParms EncryptableCreateWalletEWalletIDExtraParms

func (x *EncryptableCreateWalletEWalletIDExtraParms) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EncryptableCreateWalletEWalletIDExtraParms)(x)
}

func (x *EncryptableCreateWalletEWalletIDExtraParms) slowProtoReflect() protoreflect.Message {
	mi := &file_qadena_qadena_encryptable_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EncryptableCreateWalletEWalletIDExtraParms_messageType fastReflection_EncryptableCreateWalletEWalletIDExtraParms_messageType
var _ protoreflect.MessageType = fastReflection_EncryptableCreateWalletEWalletIDExtraParms_messageType{}

type fastReflection_EncryptableCreateWalletEWalletIDExtraParms_messageType struct{}

func (x fastReflection_EncryptableCreateWalletEWalletIDExtraParms_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EncryptableCreateWalletEWalletIDExtraParms)(nil)
}
func (x fastReflection_EncryptableCreateWalletEWalletIDExtraParms_messageType) New() protoreflect.Message {
	return new(fastReflection_EncryptableCreateWalletEWalletIDExtraParms)
}
func (x fastReflection_EncryptableCreateWalletEWalletIDExtraParms_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableCreateWalletEWalletIDExtraParms
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EncryptableCreateWalletEWalletIDExtraParms) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableCreateWalletEWalletIDExtraParms
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EncryptableCreateWalletEWalletIDExtraParms) Type() protoreflect.MessageType {
	return _fastReflection_EncryptableCreateWalletEWalletIDExtraParms_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EncryptableCreateWalletEWalletIDExtraParms) New() protoreflect.Message {
	return new(fastReflection_EncryptableCreateWalletEWalletIDExtraParms)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EncryptableCreateWalletEWalletIDExtraParms) Interface() protoreflect.ProtoMessage {
	return (*EncryptableCreateWalletEWalletIDExtraParms)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EncryptableCreateWalletEWalletIDExtraParms) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.ProofPC != nil {
		value := protoreflect.ValueOfMessage(x.ProofPC.ProtoReflect())
		if !f(fd_EncryptableCreateWalletEWalletIDExtraParms_ProofPC, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EncryptableCreateWalletEWalletIDExtraParms) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableCreateWalletEWalletIDExtraParms.ProofPC":
		return x.ProofPC != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableCreateWalletEWalletIDExtraParms"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableCreateWalletEWalletIDExtraParms does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableCreateWalletEWalletIDExtraParms) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableCreateWalletEWalletIDExtraParms.ProofPC":
		x.ProofPC = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableCreateWalletEWalletIDExtraParms"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableCreateWalletEWalletIDExtraParms does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EncryptableCreateWalletEWalletIDExtraParms) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "qadena.qadena.EncryptableCreateWalletEWalletIDExtraParms.ProofPC":
		value := x.ProofPC
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableCreateWalletEWalletIDExtraParms"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableCreateWalletEWalletIDExtraParms does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableCreateWalletEWalletIDExtraParms) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableCreateWalletEWalletIDExtraParms.ProofPC":
		x.ProofPC = value.Message().Interface().(*BPedersenCommit)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableCreateWalletEWalletIDExtraParms"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableCreateWalletEWalletIDExtraParms does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableCreateWalletEWalletIDExtraParms) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableCreateWalletEWalletIDExtraParms.ProofPC":
		if x.ProofPC == nil {
			x.ProofPC = new(BPedersenCommit)
		}
		return protoreflect.ValueOfMessage(x.ProofPC.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableCreateWalletEWalletIDExtraParms"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableCreateWalletEWalletIDExtraParms does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EncryptableCreateWalletEWalletIDExtraParms) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableCreateWalletEWalletIDExtraParms.ProofPC":
		m := new(BPedersenCommit)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableCreateWalletEWalletIDExtraParms"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableCreateWalletEWalletIDExtraParms does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EncryptableCreateWalletEWalletIDExtraParms) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in qadena.qadena.EncryptableCreateWalletEWalletIDExtraParms", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EncryptableCreateWalletEWalletIDExtraParms) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableCreateWalletEWalletIDExtraParms) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EncryptableCreateWalletEWalletIDExtraParms) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EncryptableCreateWalletEWalletIDExtraParms) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EncryptableCreateWalletEWalletIDExtraParms)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.ProofPC != nil {
			l = options.Size(x.ProofPC)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableCreateWalletEWalletIDExtraParms)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.ProofPC != nil {
			encoded, err := options.Marshal(x.ProofPC)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableCreateWalletEWalletIDExtraParms)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableCreateWalletEWalletIDExtraParms: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableCreateWalletEWalletIDExtraParms: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ProofPC", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.ProofPC == nil {
					x.ProofPC = &BPedersenCommit{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ProofPC); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EncryptableCreateWalletEWalletID            protoreflect.MessageDescriptor
	fd_EncryptableCreateWalletEWalletID_Nonce      protoreflect.FieldDescriptor
	fd_EncryptableCreateWalletEWalletID_WalletID   protoreflect.FieldDescriptor
	fd_EncryptableCreateWalletEWalletID_ExtraParms protoreflect.FieldDescriptor
)

func init() {
	file_qadena_qadena_encryptable_proto_init()
	md_EncryptableCreateWalletEWalletID = File_qadena_qadena_encryptable_proto.Messages().ByName("EncryptableCreateWalletEWalletID")
	fd_EncryptableCreateWalletEWalletID_Nonce = md_EncryptableCreateWalletEWalletID.Fields().ByName("Nonce")
	fd_EncryptableCreateWalletEWalletID_WalletID = md_EncryptableCreateWalletEWalletID.Fields().ByName("WalletID")
	fd_EncryptableCreateWalletEWalletID_ExtraParms = md_EncryptableCreateWalletEWalletID.Fields().ByName("ExtraParms")
}

var _ protoreflect.Message = (*fastReflection_EncryptableCreateWalletEWalletID)(nil)

type fastReflection_EncryptableCreateWalletEWalletID EncryptableCreateWalletEWalletID

func (x *EncryptableCreateWalletEWalletID) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EncryptableCreateWalletEWalletID)(x)
}

func (x *EncryptableCreateWalletEWalletID) slowProtoReflect() protoreflect.Message {
	mi := &file_qadena_qadena_encryptable_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EncryptableCreateWalletEWalletID_messageType fastReflection_EncryptableCreateWalletEWalletID_messageType
var _ protoreflect.MessageType = fastReflection_EncryptableCreateWalletEWalletID_messageType{}

type fastReflection_EncryptableCreateWalletEWalletID_messageType struct{}

func (x fastReflection_EncryptableCreateWalletEWalletID_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EncryptableCreateWalletEWalletID)(nil)
}
func (x fastReflection_EncryptableCreateWalletEWalletID_messageType) New() protoreflect.Message {
	return new(fastReflection_EncryptableCreateWalletEWalletID)
}
func (x fastReflection_EncryptableCreateWalletEWalletID_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableCreateWalletEWalletID
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EncryptableCreateWalletEWalletID) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableCreateWalletEWalletID
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EncryptableCreateWalletEWalletID) Type() protoreflect.MessageType {
	return _fastReflection_EncryptableCreateWalletEWalletID_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EncryptableCreateWalletEWalletID) New() protoreflect.Message {
	return new(fastReflection_EncryptableCreateWalletEWalletID)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EncryptableCreateWalletEWalletID) Interface() protoreflect.ProtoMessage {
	return (*EncryptableCreateWalletEWalletID)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EncryptableCreateWalletEWalletID) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Nonce != "" {
		value := protoreflect.ValueOfString(x.Nonce)
		if !f(fd_EncryptableCreateWalletEWalletID_Nonce, value) {
			return
		}
	}
	if x.WalletID != "" {
		value := protoreflect.ValueOfString(x.WalletID)
		if !f(fd_EncryptableCreateWalletEWalletID_WalletID, value) {
			return
		}
	}
	if x.ExtraParms != nil {
		value := protoreflect.ValueOfMessage(x.ExtraParms.ProtoReflect())
		if !f(fd_EncryptableCreateWalletEWalletID_ExtraParms, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EncryptableCreateWalletEWalletID) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableCreateWalletEWalletID.Nonce":
		return x.Nonce != ""
	case "qadena.qadena.EncryptableCreateWalletEWalletID.WalletID":
		return x.WalletID != ""
	case "qadena.qadena.EncryptableCreateWalletEWalletID.ExtraParms":
		return x.ExtraParms != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableCreateWalletEWalletID"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableCreateWalletEWalletID does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableCreateWalletEWalletID) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableCreateWalletEWalletID.Nonce":
		x.Nonce = ""
	case "qadena.qadena.EncryptableCreateWalletEWalletID.WalletID":
		x.WalletID = ""
	case "qadena.qadena.EncryptableCreateWalletEWalletID.ExtraParms":
		x.ExtraParms = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableCreateWalletEWalletID"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableCreateWalletEWalletID does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EncryptableCreateWalletEWalletID) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "qadena.qadena.EncryptableCreateWalletEWalletID.Nonce":
		value := x.Nonce
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableCreateWalletEWalletID.WalletID":
		value := x.WalletID
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableCreateWalletEWalletID.ExtraParms":
		value := x.ExtraParms
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableCreateWalletEWalletID"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableCreateWalletEWalletID does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableCreateWalletEWalletID) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableCreateWalletEWalletID.Nonce":
		x.Nonce = value.Interface().(string)
	case "qadena.qadena.EncryptableCreateWalletEWalletID.WalletID":
		x.WalletID = value.Interface().(string)
	case "qadena.qadena.EncryptableCreateWalletEWalletID.ExtraParms":
		x.ExtraParms = value.Message().Interface().(*EncryptableCreateWalletEWalletIDExtraParms)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableCreateWalletEWalletID"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableCreateWalletEWalletID does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableCreateWalletEWalletID) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableCreateWalletEWalletID.ExtraParms":
		if x.ExtraParms == nil {
			x.ExtraParms = new(EncryptableCreateWalletEWalletIDExtraParms)
		}
		return protoreflect.ValueOfMessage(x.ExtraParms.ProtoReflect())
	case "qadena.qadena.EncryptableCreateWalletEWalletID.Nonce":
		panic(fmt.Errorf("field Nonce of message qadena.qadena.EncryptableCreateWalletEWalletID is not mutable"))
	case "qadena.qadena.EncryptableCreateWalletEWalletID.WalletID":
		panic(fmt.Errorf("field WalletID of message qadena.qadena.EncryptableCreateWalletEWalletID is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableCreateWalletEWalletID"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableCreateWalletEWalletID does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EncryptableCreateWalletEWalletID) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableCreateWalletEWalletID.Nonce":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableCreateWalletEWalletID.WalletID":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableCreateWalletEWalletID.ExtraParms":
		m := new(EncryptableCreateWalletEWalletIDExtraParms)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableCreateWalletEWalletID"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableCreateWalletEWalletID does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EncryptableCreateWalletEWalletID) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in qadena.qadena.EncryptableCreateWalletEWalletID", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EncryptableCreateWalletEWalletID) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableCreateWalletEWalletID) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EncryptableCreateWalletEWalletID) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EncryptableCreateWalletEWalletID) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EncryptableCreateWalletEWalletID)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Nonce)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.WalletID)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.ExtraParms != nil {
			l = options.Size(x.ExtraParms)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableCreateWalletEWalletID)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.ExtraParms != nil {
			encoded, err := options.Marshal(x.ExtraParms)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.WalletID) > 0 {
			i -= len(x.WalletID)
			copy(dAtA[i:], x.WalletID)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.WalletID)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Nonce) > 0 {
			i -= len(x.Nonce)
			copy(dAtA[i:], x.Nonce)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Nonce)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableCreateWalletEWalletID)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableCreateWalletEWalletID: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableCreateWalletEWalletID: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Nonce = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field WalletID", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.WalletID = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ExtraParms", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.ExtraParms == nil {
					x.ExtraParms = &EncryptableCreateWalletEWalletIDExtraParms{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ExtraParms); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EncryptableCreateWallet              protoreflect.MessageDescriptor
	fd_EncryptableCreateWallet_DstEWalletID protoreflect.FieldDescriptor
)

func init() {
	file_qadena_qadena_encryptable_proto_init()
	md_EncryptableCreateWallet = File_qadena_qadena_encryptable_proto.Messages().ByName("EncryptableCreateWallet")
	fd_EncryptableCreateWallet_DstEWalletID = md_EncryptableCreateWallet.Fields().ByName("DstEWalletID")
}

var _ protoreflect.Message = (*fastReflection_EncryptableCreateWallet)(nil)

type fastReflection_EncryptableCreateWallet EncryptableCreateWallet

func (x *EncryptableCreateWallet) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EncryptableCreateWallet)(x)
}

func (x *EncryptableCreateWallet) slowProtoReflect() protoreflect.Message {
	mi := &file_qadena_qadena_encryptable_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EncryptableCreateWallet_messageType fastReflection_EncryptableCreateWallet_messageType
var _ protoreflect.MessageType = fastReflection_EncryptableCreateWallet_messageType{}

type fastReflection_EncryptableCreateWallet_messageType struct{}

func (x fastReflection_EncryptableCreateWallet_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EncryptableCreateWallet)(nil)
}
func (x fastReflection_EncryptableCreateWallet_messageType) New() protoreflect.Message {
	return new(fastReflection_EncryptableCreateWallet)
}
func (x fastReflection_EncryptableCreateWallet_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableCreateWallet
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EncryptableCreateWallet) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableCreateWallet
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EncryptableCreateWallet) Type() protoreflect.MessageType {
	return _fastReflection_EncryptableCreateWallet_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EncryptableCreateWallet) New() protoreflect.Message {
	return new(fastReflection_EncryptableCreateWallet)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EncryptableCreateWallet) Interface() protoreflect.ProtoMessage {
	return (*EncryptableCreateWallet)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EncryptableCreateWallet) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.DstEWalletID != nil {
		value := protoreflect.ValueOfMessage(x.DstEWalletID.ProtoReflect())
		if !f(fd_EncryptableCreateWallet_DstEWalletID, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EncryptableCreateWallet) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableCreateWallet.DstEWalletID":
		return x.DstEWalletID != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableCreateWallet"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableCreateWallet does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableCreateWallet) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableCreateWallet.DstEWalletID":
		x.DstEWalletID = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableCreateWallet"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableCreateWallet does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EncryptableCreateWallet) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "qadena.qadena.EncryptableCreateWallet.DstEWalletID":
		value := x.DstEWalletID
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableCreateWallet"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableCreateWallet does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableCreateWallet) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableCreateWallet.DstEWalletID":
		x.DstEWalletID = value.Message().Interface().(*EncryptableCreateWalletEWalletID)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableCreateWallet"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableCreateWallet does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableCreateWallet) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableCreateWallet.DstEWalletID":
		if x.DstEWalletID == nil {
			x.DstEWalletID = new(EncryptableCreateWalletEWalletID)
		}
		return protoreflect.ValueOfMessage(x.DstEWalletID.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableCreateWallet"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableCreateWallet does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EncryptableCreateWallet) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableCreateWallet.DstEWalletID":
		m := new(EncryptableCreateWalletEWalletID)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableCreateWallet"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableCreateWallet does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EncryptableCreateWallet) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in qadena.qadena.EncryptableCreateWallet", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EncryptableCreateWallet) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableCreateWallet) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EncryptableCreateWallet) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EncryptableCreateWallet) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EncryptableCreateWallet)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.DstEWalletID != nil {
			l = options.Size(x.DstEWalletID)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableCreateWallet)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.DstEWalletID != nil {
			encoded, err := options.Marshal(x.DstEWalletID)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableCreateWallet)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableCreateWallet: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableCreateWallet: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field DstEWalletID", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.DstEWalletID == nil {
					x.DstEWalletID = &EncryptableCreateWalletEWalletID{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.DstEWalletID); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EncryptableTransferFundsEWalletIDExtraParms                                 protoreflect.MessageDescriptor
	fd_EncryptableTransferFundsEWalletIDExtraParms_AcceptPasswordPC                protoreflect.FieldDescriptor
	fd_EncryptableTransferFundsEWalletIDExtraParms_MatchFirstNameHashHex           protoreflect.FieldDescriptor
	fd_EncryptableTransferFundsEWalletIDExtraParms_MatchMiddleNameHashHex          protoreflect.FieldDescriptor
	fd_EncryptableTransferFundsEWalletIDExtraParms_MatchLastNameHashHex            protoreflect.FieldDescriptor
	fd_EncryptableTransferFundsEWalletIDExtraParms_RequiredSenderFirstNameCheckPC  protoreflect.FieldDescriptor
	fd_EncryptableTransferFundsEWalletIDExtraParms_RequiredSenderFirstNameProofPC  protoreflect.FieldDescriptor
	fd_EncryptableTransferFundsEWalletIDExtraParms_RequiredSenderMiddleNameCheckPC protoreflect.FieldDescriptor
	fd_EncryptableTransferFundsEWalletIDExtraParms_RequiredSenderMiddleNameProofPC protoreflect.FieldDescriptor
	fd_EncryptableTransferFundsEWalletIDExtraParms_RequiredSenderLastNameCheckPC   protoreflect.FieldDescriptor
	fd_EncryptableTransferFundsEWalletIDExtraParms_RequiredSenderLastNameProofPC   protoreflect.FieldDescriptor
)

func init() {
	file_qadena_qadena_encryptable_proto_init()
	md_EncryptableTransferFundsEWalletIDExtraParms = File_qadena_qadena_encryptable_proto.Messages().ByName("EncryptableTransferFundsEWalletIDExtraParms")
	fd_EncryptableTransferFundsEWalletIDExtraParms_AcceptPasswordPC = md_EncryptableTransferFundsEWalletIDExtraParms.Fields().ByName("AcceptPasswordPC")
	fd_EncryptableTransferFundsEWalletIDExtraParms_MatchFirstNameHashHex = md_EncryptableTransferFundsEWalletIDExtraParms.Fields().ByName("MatchFirstNameHashHex")
	fd_EncryptableTransferFundsEWalletIDExtraParms_MatchMiddleNameHashHex = md_EncryptableTransferFundsEWalletIDExtraParms.Fields().ByName("MatchMiddleNameHashHex")
	fd_EncryptableTransferFundsEWalletIDExtraParms_MatchLastNameHashHex = md_EncryptableTransferFundsEWalletIDExtraParms.Fields().ByName("MatchLastNameHashHex")
	fd_EncryptableTransferFundsEWalletIDExtraParms_RequiredSenderFirstNameCheckPC = md_EncryptableTransferFundsEWalletIDExtraParms.Fields().ByName("RequiredSenderFirstNameCheckPC")
	fd_EncryptableTransferFundsEWalletIDExtraParms_RequiredSenderFirstNameProofPC = md_EncryptableTransferFundsEWalletIDExtraParms.Fields().ByName("RequiredSenderFirstNameProofPC")
	fd_EncryptableTransferFundsEWalletIDExtraParms_RequiredSenderMiddleNameCheckPC = md_EncryptableTransferFundsEWalletIDExtraParms.Fields().ByName("RequiredSenderMiddleNameCheckPC")
	fd_EncryptableTransferFundsEWalletIDExtraParms_RequiredSenderMiddleNameProofPC = md_EncryptableTransferFundsEWalletIDExtraParms.Fields().ByName("RequiredSenderMiddleNameProofPC")
	fd_EncryptableTransferFundsEWalletIDExtraParms_RequiredSenderLastNameCheckPC = md_EncryptableTransferFundsEWalletIDExtraParms.Fields().ByName("RequiredSenderLastNameCheckPC")
	fd_EncryptableTransferFundsEWalletIDExtraParms_RequiredSenderLastNameProofPC = md_EncryptableTransferFundsEWalletIDExtraParms.Fields().ByName("RequiredSenderLastNameProofPC")
}

var _ protoreflect.Message = (*fastReflection_EncryptableTransferFundsEWalletIDExtraParms)(nil)

type fastReflection_EncryptableTransferFundsEWalletIDExtraParms EncryptableTransferFundsEWalletIDExtraParms

func (x *EncryptableTransferFundsEWalletIDExtraParms) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EncryptableTransferFundsEWalletIDExtraParms)(x)
}

func (x *EncryptableTransferFundsEWalletIDExtraParms) slowProtoReflect() protoreflect.Message {
	mi := &file_qadena_qadena_encryptable_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EncryptableTransferFundsEWalletIDExtraParms_messageType fastReflection_EncryptableTransferFundsEWalletIDExtraParms_messageType
var _ protoreflect.MessageType = fastReflection_EncryptableTransferFundsEWalletIDExtraParms_messageType{}

type fastReflection_EncryptableTransferFundsEWalletIDExtraParms_messageType struct{}

func (x fastReflection_EncryptableTransferFundsEWalletIDExtraParms_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EncryptableTransferFundsEWalletIDExtraParms)(nil)
}
func (x fastReflection_EncryptableTransferFundsEWalletIDExtraParms_messageType) New() protoreflect.Message {
	return new(fastReflection_EncryptableTransferFundsEWalletIDExtraParms)
}
func (x fastReflection_EncryptableTransferFundsEWalletIDExtraParms_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableTransferFundsEWalletIDExtraParms
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EncryptableTransferFundsEWalletIDExtraParms) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableTransferFundsEWalletIDExtraParms
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EncryptableTransferFundsEWalletIDExtraParms) Type() protoreflect.MessageType {
	return _fastReflection_EncryptableTransferFundsEWalletIDExtraParms_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EncryptableTransferFundsEWalletIDExtraParms) New() protoreflect.Message {
	return new(fastReflection_EncryptableTransferFundsEWalletIDExtraParms)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EncryptableTransferFundsEWalletIDExtraParms) Interface() protoreflect.ProtoMessage {
	return (*EncryptableTransferFundsEWalletIDExtraParms)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EncryptableTransferFundsEWalletIDExtraParms) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.AcceptPasswordPC != nil {
		value := protoreflect.ValueOfMessage(x.AcceptPasswordPC.ProtoReflect())
		if !f(fd_EncryptableTransferFundsEWalletIDExtraParms_AcceptPasswordPC, value) {
			return
		}
	}
	if len(x.MatchFirstNameHashHex) != 0 {
		value := protoreflect.ValueOfBytes(x.MatchFirstNameHashHex)
		if !f(fd_EncryptableTransferFundsEWalletIDExtraParms_MatchFirstNameHashHex, value) {
			return
		}
	}
	if len(x.MatchMiddleNameHashHex) != 0 {
		value := protoreflect.ValueOfBytes(x.MatchMiddleNameHashHex)
		if !f(fd_EncryptableTransferFundsEWalletIDExtraParms_MatchMiddleNameHashHex, value) {
			return
		}
	}
	if len(x.MatchLastNameHashHex) != 0 {
		value := protoreflect.ValueOfBytes(x.MatchLastNameHashHex)
		if !f(fd_EncryptableTransferFundsEWalletIDExtraParms_MatchLastNameHashHex, value) {
			return
		}
	}
	if x.RequiredSenderFirstNameCheckPC != nil {
		value := protoreflect.ValueOfMessage(x.RequiredSenderFirstNameCheckPC.ProtoReflect())
		if !f(fd_EncryptableTransferFundsEWalletIDExtraParms_RequiredSenderFirstNameCheckPC, value) {
			return
		}
	}
	if x.RequiredSenderFirstNameProofPC != nil {
		value := protoreflect.ValueOfMessage(x.RequiredSenderFirstNameProofPC.ProtoReflect())
		if !f(fd_EncryptableTransferFundsEWalletIDExtraParms_RequiredSenderFirstNameProofPC, value) {
			return
		}
	}
	if x.RequiredSenderMiddleNameCheckPC != nil {
		value := protoreflect.ValueOfMessage(x.RequiredSenderMiddleNameCheckPC.ProtoReflect())
		if !f(fd_EncryptableTransferFundsEWalletIDExtraParms_RequiredSenderMiddleNameCheckPC, value) {
			return
		}
	}
	if x.RequiredSenderMiddleNameProofPC != nil {
		value := protoreflect.ValueOfMessage(x.RequiredSenderMiddleNameProofPC.ProtoReflect())
		if !f(fd_EncryptableTransferFundsEWalletIDExtraParms_RequiredSenderMiddleNameProofPC, value) {
			return
		}
	}
	if x.RequiredSenderLastNameCheckPC != nil {
		value := protoreflect.ValueOfMessage(x.RequiredSenderLastNameCheckPC.ProtoReflect())
		if !f(fd_EncryptableTransferFundsEWalletIDExtraParms_RequiredSenderLastNameCheckPC, value) {
			return
		}
	}
	if x.RequiredSenderLastNameProofPC != nil {
		value := protoreflect.ValueOfMessage(x.RequiredSenderLastNameProofPC.ProtoReflect())
		if !f(fd_EncryptableTransferFundsEWalletIDExtraParms_RequiredSenderLastNameProofPC, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EncryptableTransferFundsEWalletIDExtraParms) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.AcceptPasswordPC":
		return x.AcceptPasswordPC != nil
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.MatchFirstNameHashHex":
		return len(x.MatchFirstNameHashHex) != 0
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.MatchMiddleNameHashHex":
		return len(x.MatchMiddleNameHashHex) != 0
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.MatchLastNameHashHex":
		return len(x.MatchLastNameHashHex) != 0
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderFirstNameCheckPC":
		return x.RequiredSenderFirstNameCheckPC != nil
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderFirstNameProofPC":
		return x.RequiredSenderFirstNameProofPC != nil
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderMiddleNameCheckPC":
		return x.RequiredSenderMiddleNameCheckPC != nil
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderMiddleNameProofPC":
		return x.RequiredSenderMiddleNameProofPC != nil
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderLastNameCheckPC":
		return x.RequiredSenderLastNameCheckPC != nil
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderLastNameProofPC":
		return x.RequiredSenderLastNameProofPC != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableTransferFundsEWalletIDExtraParms) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.AcceptPasswordPC":
		x.AcceptPasswordPC = nil
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.MatchFirstNameHashHex":
		x.MatchFirstNameHashHex = nil
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.MatchMiddleNameHashHex":
		x.MatchMiddleNameHashHex = nil
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.MatchLastNameHashHex":
		x.MatchLastNameHashHex = nil
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderFirstNameCheckPC":
		x.RequiredSenderFirstNameCheckPC = nil
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderFirstNameProofPC":
		x.RequiredSenderFirstNameProofPC = nil
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderMiddleNameCheckPC":
		x.RequiredSenderMiddleNameCheckPC = nil
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderMiddleNameProofPC":
		x.RequiredSenderMiddleNameProofPC = nil
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderLastNameCheckPC":
		x.RequiredSenderLastNameCheckPC = nil
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderLastNameProofPC":
		x.RequiredSenderLastNameProofPC = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EncryptableTransferFundsEWalletIDExtraParms) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.AcceptPasswordPC":
		value := x.AcceptPasswordPC
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.MatchFirstNameHashHex":
		value := x.MatchFirstNameHashHex
		return protoreflect.ValueOfBytes(value)
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.MatchMiddleNameHashHex":
		value := x.MatchMiddleNameHashHex
		return protoreflect.ValueOfBytes(value)
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.MatchLastNameHashHex":
		value := x.MatchLastNameHashHex
		return protoreflect.ValueOfBytes(value)
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderFirstNameCheckPC":
		value := x.RequiredSenderFirstNameCheckPC
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderFirstNameProofPC":
		value := x.RequiredSenderFirstNameProofPC
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderMiddleNameCheckPC":
		value := x.RequiredSenderMiddleNameCheckPC
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderMiddleNameProofPC":
		value := x.RequiredSenderMiddleNameProofPC
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderLastNameCheckPC":
		value := x.RequiredSenderLastNameCheckPC
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderLastNameProofPC":
		value := x.RequiredSenderLastNameProofPC
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableTransferFundsEWalletIDExtraParms) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.AcceptPasswordPC":
		x.AcceptPasswordPC = value.Message().Interface().(*BPedersenCommit)
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.MatchFirstNameHashHex":
		x.MatchFirstNameHashHex = value.Bytes()
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.MatchMiddleNameHashHex":
		x.MatchMiddleNameHashHex = value.Bytes()
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.MatchLastNameHashHex":
		x.MatchLastNameHashHex = value.Bytes()
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderFirstNameCheckPC":
		x.RequiredSenderFirstNameCheckPC = value.Message().Interface().(*BPedersenCommit)
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderFirstNameProofPC":
		x.RequiredSenderFirstNameProofPC = value.Message().Interface().(*BPedersenCommit)
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderMiddleNameCheckPC":
		x.RequiredSenderMiddleNameCheckPC = value.Message().Interface().(*BPedersenCommit)
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderMiddleNameProofPC":
		x.RequiredSenderMiddleNameProofPC = value.Message().Interface().(*BPedersenCommit)
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderLastNameCheckPC":
		x.RequiredSenderLastNameCheckPC = value.Message().Interface().(*BPedersenCommit)
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderLastNameProofPC":
		x.RequiredSenderLastNameProofPC = value.Message().Interface().(*BPedersenCommit)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableTransferFundsEWalletIDExtraParms) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.AcceptPasswordPC":
		if x.AcceptPasswordPC == nil {
			x.AcceptPasswordPC = new(BPedersenCommit)
		}
		return protoreflect.ValueOfMessage(x.AcceptPasswordPC.ProtoReflect())
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderFirstNameCheckPC":
		if x.RequiredSenderFirstNameCheckPC == nil {
			x.RequiredSenderFirstNameCheckPC = new(BPedersenCommit)
		}
		return protoreflect.ValueOfMessage(x.RequiredSenderFirstNameCheckPC.ProtoReflect())
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderFirstNameProofPC":
		if x.RequiredSenderFirstNameProofPC == nil {
			x.RequiredSenderFirstNameProofPC = new(BPedersenCommit)
		}
		return protoreflect.ValueOfMessage(x.RequiredSenderFirstNameProofPC.ProtoReflect())
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderMiddleNameCheckPC":
		if x.RequiredSenderMiddleNameCheckPC == nil {
			x.RequiredSenderMiddleNameCheckPC = new(BPedersenCommit)
		}
		return protoreflect.ValueOfMessage(x.RequiredSenderMiddleNameCheckPC.ProtoReflect())
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderMiddleNameProofPC":
		if x.RequiredSenderMiddleNameProofPC == nil {
			x.RequiredSenderMiddleNameProofPC = new(BPedersenCommit)
		}
		return protoreflect.ValueOfMessage(x.RequiredSenderMiddleNameProofPC.ProtoReflect())
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderLastNameCheckPC":
		if x.RequiredSenderLastNameCheckPC == nil {
			x.RequiredSenderLastNameCheckPC = new(BPedersenCommit)
		}
		return protoreflect.ValueOfMessage(x.RequiredSenderLastNameCheckPC.ProtoReflect())
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderLastNameProofPC":
		if x.RequiredSenderLastNameProofPC == nil {
			x.RequiredSenderLastNameProofPC = new(BPedersenCommit)
		}
		return protoreflect.ValueOfMessage(x.RequiredSenderLastNameProofPC.ProtoReflect())
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.MatchFirstNameHashHex":
		panic(fmt.Errorf("field MatchFirstNameHashHex of message qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms is not mutable"))
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.MatchMiddleNameHashHex":
		panic(fmt.Errorf("field MatchMiddleNameHashHex of message qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms is not mutable"))
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.MatchLastNameHashHex":
		panic(fmt.Errorf("field MatchLastNameHashHex of message qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EncryptableTransferFundsEWalletIDExtraParms) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.AcceptPasswordPC":
		m := new(BPedersenCommit)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.MatchFirstNameHashHex":
		return protoreflect.ValueOfBytes(nil)
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.MatchMiddleNameHashHex":
		return protoreflect.ValueOfBytes(nil)
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.MatchLastNameHashHex":
		return protoreflect.ValueOfBytes(nil)
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderFirstNameCheckPC":
		m := new(BPedersenCommit)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderFirstNameProofPC":
		m := new(BPedersenCommit)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderMiddleNameCheckPC":
		m := new(BPedersenCommit)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderMiddleNameProofPC":
		m := new(BPedersenCommit)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderLastNameCheckPC":
		m := new(BPedersenCommit)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderLastNameProofPC":
		m := new(BPedersenCommit)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EncryptableTransferFundsEWalletIDExtraParms) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EncryptableTransferFundsEWalletIDExtraParms) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableTransferFundsEWalletIDExtraParms) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EncryptableTransferFundsEWalletIDExtraParms) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EncryptableTransferFundsEWalletIDExtraParms) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EncryptableTransferFundsEWalletIDExtraParms)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.AcceptPasswordPC != nil {
			l = options.Size(x.AcceptPasswordPC)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.MatchFirstNameHashHex)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.MatchMiddleNameHashHex)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.MatchLastNameHashHex)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.RequiredSenderFirstNameCheckPC != nil {
			l = options.Size(x.RequiredSenderFirstNameCheckPC)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.RequiredSenderFirstNameProofPC != nil {
			l = options.Size(x.RequiredSenderFirstNameProofPC)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.RequiredSenderMiddleNameCheckPC != nil {
			l = options.Size(x.RequiredSenderMiddleNameCheckPC)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.RequiredSenderMiddleNameProofPC != nil {
			l = options.Size(x.RequiredSenderMiddleNameProofPC)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.RequiredSenderLastNameCheckPC != nil {
			l = options.Size(x.RequiredSenderLastNameCheckPC)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.RequiredSenderLastNameProofPC != nil {
			l = options.Size(x.RequiredSenderLastNameProofPC)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableTransferFundsEWalletIDExtraParms)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.RequiredSenderLastNameProofPC != nil {
			encoded, err := options.Marshal(x.RequiredSenderLastNameProofPC)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x52
		}
		if x.RequiredSenderLastNameCheckPC != nil {
			encoded, err := options.Marshal(x.RequiredSenderLastNameCheckPC)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x4a
		}
		if x.RequiredSenderMiddleNameProofPC != nil {
			encoded, err := options.Marshal(x.RequiredSenderMiddleNameProofPC)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x42
		}
		if x.RequiredSenderMiddleNameCheckPC != nil {
			encoded, err := options.Marshal(x.RequiredSenderMiddleNameCheckPC)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x3a
		}
		if x.RequiredSenderFirstNameProofPC != nil {
			encoded, err := options.Marshal(x.RequiredSenderFirstNameProofPC)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x32
		}
		if x.RequiredSenderFirstNameCheckPC != nil {
			encoded, err := options.Marshal(x.RequiredSenderFirstNameCheckPC)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.MatchLastNameHashHex) > 0 {
			i -= len(x.MatchLastNameHashHex)
			copy(dAtA[i:], x.MatchLastNameHashHex)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MatchLastNameHashHex)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.MatchMiddleNameHashHex) > 0 {
			i -= len(x.MatchMiddleNameHashHex)
			copy(dAtA[i:], x.MatchMiddleNameHashHex)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MatchMiddleNameHashHex)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.MatchFirstNameHashHex) > 0 {
			i -= len(x.MatchFirstNameHashHex)
			copy(dAtA[i:], x.MatchFirstNameHashHex)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MatchFirstNameHashHex)))
			i--
			dAtA[i] = 0x12
		}
		if x.AcceptPasswordPC != nil {
			encoded, err := options.Marshal(x.AcceptPasswordPC)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableTransferFundsEWalletIDExtraParms)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableTransferFundsEWalletIDExtraParms: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableTransferFundsEWalletIDExtraParms: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field AcceptPasswordPC", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.AcceptPasswordPC == nil {
					x.AcceptPasswordPC = &BPedersenCommit{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.AcceptPasswordPC); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MatchFirstNameHashHex", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MatchFirstNameHashHex = append(x.MatchFirstNameHashHex[:0], dAtA[iNdEx:postIndex]...)
				if x.MatchFirstNameHashHex == nil {
					x.MatchFirstNameHashHex = []byte{}
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MatchMiddleNameHashHex", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MatchMiddleNameHashHex = append(x.MatchMiddleNameHashHex[:0], dAtA[iNdEx:postIndex]...)
				if x.MatchMiddleNameHashHex == nil {
					x.MatchMiddleNameHashHex = []byte{}
				}
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MatchLastNameHashHex", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MatchLastNameHashHex = append(x.MatchLastNameHashHex[:0], dAtA[iNdEx:postIndex]...)
				if x.MatchLastNameHashHex == nil {
					x.MatchLastNameHashHex = []byte{}
				}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RequiredSenderFirstNameCheckPC", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.RequiredSenderFirstNameCheckPC == nil {
					x.RequiredSenderFirstNameCheckPC = &BPedersenCommit{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.RequiredSenderFirstNameCheckPC); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RequiredSenderFirstNameProofPC", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.RequiredSenderFirstNameProofPC == nil {
					x.RequiredSenderFirstNameProofPC = &BPedersenCommit{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.RequiredSenderFirstNameProofPC); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RequiredSenderMiddleNameCheckPC", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.RequiredSenderMiddleNameCheckPC == nil {
					x.RequiredSenderMiddleNameCheckPC = &BPedersenCommit{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.RequiredSenderMiddleNameCheckPC); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 8:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RequiredSenderMiddleNameProofPC", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.RequiredSenderMiddleNameProofPC == nil {
					x.RequiredSenderMiddleNameProofPC = &BPedersenCommit{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.RequiredSenderMiddleNameProofPC); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 9:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RequiredSenderLastNameCheckPC", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.RequiredSenderLastNameCheckPC == nil {
					x.RequiredSenderLastNameCheckPC = &BPedersenCommit{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.RequiredSenderLastNameCheckPC); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 10:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RequiredSenderLastNameProofPC", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.RequiredSenderLastNameProofPC == nil {
					x.RequiredSenderLastNameProofPC = &BPedersenCommit{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.RequiredSenderLastNameProofPC); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EncryptableTransferFundsEWalletID            protoreflect.MessageDescriptor
	fd_EncryptableTransferFundsEWalletID_Nonce      protoreflect.FieldDescriptor
	fd_EncryptableTransferFundsEWalletID_WalletID   protoreflect.FieldDescriptor
	fd_EncryptableTransferFundsEWalletID_ExtraParms protoreflect.FieldDescriptor
)

func init() {
	file_qadena_qadena_encryptable_proto_init()
	md_EncryptableTransferFundsEWalletID = File_qadena_qadena_encryptable_proto.Messages().ByName("EncryptableTransferFundsEWalletID")
	fd_EncryptableTransferFundsEWalletID_Nonce = md_EncryptableTransferFundsEWalletID.Fields().ByName("Nonce")
	fd_EncryptableTransferFundsEWalletID_WalletID = md_EncryptableTransferFundsEWalletID.Fields().ByName("WalletID")
	fd_EncryptableTransferFundsEWalletID_ExtraParms = md_EncryptableTransferFundsEWalletID.Fields().ByName("ExtraParms")
}

var _ protoreflect.Message = (*fastReflection_EncryptableTransferFundsEWalletID)(nil)

type fastReflection_EncryptableTransferFundsEWalletID EncryptableTransferFundsEWalletID

func (x *EncryptableTransferFundsEWalletID) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EncryptableTransferFundsEWalletID)(x)
}

func (x *EncryptableTransferFundsEWalletID) slowProtoReflect() protoreflect.Message {
	mi := &file_qadena_qadena_encryptable_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EncryptableTransferFundsEWalletID_messageType fastReflection_EncryptableTransferFundsEWalletID_messageType
var _ protoreflect.MessageType = fastReflection_EncryptableTransferFundsEWalletID_messageType{}

type fastReflection_EncryptableTransferFundsEWalletID_messageType struct{}

func (x fastReflection_EncryptableTransferFundsEWalletID_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EncryptableTransferFundsEWalletID)(nil)
}
func (x fastReflection_EncryptableTransferFundsEWalletID_messageType) New() protoreflect.Message {
	return new(fastReflection_EncryptableTransferFundsEWalletID)
}
func (x fastReflection_EncryptableTransferFundsEWalletID_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableTransferFundsEWalletID
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EncryptableTransferFundsEWalletID) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableTransferFundsEWalletID
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EncryptableTransferFundsEWalletID) Type() protoreflect.MessageType {
	return _fastReflection_EncryptableTransferFundsEWalletID_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EncryptableTransferFundsEWalletID) New() protoreflect.Message {
	return new(fastReflection_EncryptableTransferFundsEWalletID)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EncryptableTransferFundsEWalletID) Interface() protoreflect.ProtoMessage {
	return (*EncryptableTransferFundsEWalletID)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EncryptableTransferFundsEWalletID) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Nonce != "" {
		value := protoreflect.ValueOfString(x.Nonce)
		if !f(fd_EncryptableTransferFundsEWalletID_Nonce, value) {
			return
		}
	}
	if x.WalletID != "" {
		value := protoreflect.ValueOfString(x.WalletID)
		if !f(fd_EncryptableTransferFundsEWalletID_WalletID, value) {
			return
		}
	}
	if x.ExtraParms != nil {
		value := protoreflect.ValueOfMessage(x.ExtraParms.ProtoReflect())
		if !f(fd_EncryptableTransferFundsEWalletID_ExtraParms, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EncryptableTransferFundsEWalletID) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableTransferFundsEWalletID.Nonce":
		return x.Nonce != ""
	case "qadena.qadena.EncryptableTransferFundsEWalletID.WalletID":
		return x.WalletID != ""
	case "qadena.qadena.EncryptableTransferFundsEWalletID.ExtraParms":
		return x.ExtraParms != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableTransferFundsEWalletID"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableTransferFundsEWalletID does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableTransferFundsEWalletID) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableTransferFundsEWalletID.Nonce":
		x.Nonce = ""
	case "qadena.qadena.EncryptableTransferFundsEWalletID.WalletID":
		x.WalletID = ""
	case "qadena.qadena.EncryptableTransferFundsEWalletID.ExtraParms":
		x.ExtraParms = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableTransferFundsEWalletID"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableTransferFundsEWalletID does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EncryptableTransferFundsEWalletID) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "qadena.qadena.EncryptableTransferFundsEWalletID.Nonce":
		value := x.Nonce
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableTransferFundsEWalletID.WalletID":
		value := x.WalletID
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableTransferFundsEWalletID.ExtraParms":
		value := x.ExtraParms
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableTransferFundsEWalletID"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableTransferFundsEWalletID does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableTransferFundsEWalletID) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableTransferFundsEWalletID.Nonce":
		x.Nonce = value.Interface().(string)
	case "qadena.qadena.EncryptableTransferFundsEWalletID.WalletID":
		x.WalletID = value.Interface().(string)
	case "qadena.qadena.EncryptableTransferFundsEWalletID.ExtraParms":
		x.ExtraParms = value.Message().Interface().(*EncryptableTransferFundsEWalletIDExtraParms)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableTransferFundsEWalletID"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableTransferFundsEWalletID does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableTransferFundsEWalletID) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableTransferFundsEWalletID.ExtraParms":
		if x.ExtraParms == nil {
			x.ExtraParms = new(EncryptableTransferFundsEWalletIDExtraParms)
		}
		return protoreflect.ValueOfMessage(x.ExtraParms.ProtoReflect())
	case "qadena.qadena.EncryptableTransferFundsEWalletID.Nonce":
		panic(fmt.Errorf("field Nonce of message qadena.qadena.EncryptableTransferFundsEWalletID is not mutable"))
	case "qadena.qadena.EncryptableTransferFundsEWalletID.WalletID":
		panic(fmt.Errorf("field WalletID of message qadena.qadena.EncryptableTransferFundsEWalletID is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableTransferFundsEWalletID"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableTransferFundsEWalletID does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EncryptableTransferFundsEWalletID) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableTransferFundsEWalletID.Nonce":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableTransferFundsEWalletID.WalletID":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableTransferFundsEWalletID.ExtraParms":
		m := new(EncryptableTransferFundsEWalletIDExtraParms)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableTransferFundsEWalletID"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableTransferFundsEWalletID does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EncryptableTransferFundsEWalletID) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in qadena.qadena.EncryptableTransferFundsEWalletID", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EncryptableTransferFundsEWalletID) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableTransferFundsEWalletID) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EncryptableTransferFundsEWalletID) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EncryptableTransferFundsEWalletID) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EncryptableTransferFundsEWalletID)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Nonce)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.WalletID)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.ExtraParms != nil {
			l = options.Size(x.ExtraParms)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableTransferFundsEWalletID)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.ExtraParms != nil {
			encoded, err := options.Marshal(x.ExtraParms)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.WalletID) > 0 {
			i -= len(x.WalletID)
			copy(dAtA[i:], x.WalletID)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.WalletID)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Nonce) > 0 {
			i -= len(x.Nonce)
			copy(dAtA[i:], x.Nonce)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Nonce)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableTransferFundsEWalletID)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableTransferFundsEWalletID: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableTransferFundsEWalletID: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Nonce = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field WalletID", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.WalletID = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ExtraParms", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.ExtraParms == nil {
					x.ExtraParms = &EncryptableTransferFundsEWalletIDExtraParms{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ExtraParms); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EncryptableTransferFunds                  protoreflect.MessageDescriptor
	fd_EncryptableTransferFunds_HiddenTransferPC protoreflect.FieldDescriptor
	fd_EncryptableTransferFunds_DstEWalletID     protoreflect.FieldDescriptor
	fd_EncryptableTransferFunds_OptInReason      protoreflect.FieldDescriptor
)

func init() {
	file_qadena_qadena_encryptable_proto_init()
	md_EncryptableTransferFunds = File_qadena_qadena_encryptable_proto.Messages().ByName("EncryptableTransferFunds")
	fd_EncryptableTransferFunds_HiddenTransferPC = md_EncryptableTransferFunds.Fields().ByName("HiddenTransferPC")
	fd_EncryptableTransferFunds_DstEWalletID = md_EncryptableTransferFunds.Fields().ByName("DstEWalletID")
	fd_EncryptableTransferFunds_OptInReason = md_EncryptableTransferFunds.Fields().ByName("OptInReason")
}

var _ protoreflect.Message = (*fastReflection_EncryptableTransferFunds)(nil)

type fastReflection_EncryptableTransferFunds EncryptableTransferFunds

func (x *EncryptableTransferFunds) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EncryptableTransferFunds)(x)
}

func (x *EncryptableTransferFunds) slowProtoReflect() protoreflect.Message {
	mi := &file_qadena_qadena_encryptable_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EncryptableTransferFunds_messageType fastReflection_EncryptableTransferFunds_messageType
var _ protoreflect.MessageType = fastReflection_EncryptableTransferFunds_messageType{}

type fastReflection_EncryptableTransferFunds_messageType struct{}

func (x fastReflection_EncryptableTransferFunds_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EncryptableTransferFunds)(nil)
}
func (x fastReflection_EncryptableTransferFunds_messageType) New() protoreflect.Message {
	return new(fastReflection_EncryptableTransferFunds)
}
func (x fastReflection_EncryptableTransferFunds_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableTransferFunds
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EncryptableTransferFunds) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableTransferFunds
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EncryptableTransferFunds) Type() protoreflect.MessageType {
	return _fastReflection_EncryptableTransferFunds_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EncryptableTransferFunds) New() protoreflect.Message {
	return new(fastReflection_EncryptableTransferFunds)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EncryptableTransferFunds) Interface() protoreflect.ProtoMessage {
	return (*EncryptableTransferFunds)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EncryptableTransferFunds) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.HiddenTransferPC != nil {
		value := protoreflect.ValueOfMessage(x.HiddenTransferPC.ProtoReflect())
		if !f(fd_EncryptableTransferFunds_HiddenTransferPC, value) {
			return
		}
	}
	if x.DstEWalletID != nil {
		value := protoreflect.ValueOfMessage(x.DstEWalletID.ProtoReflect())
		if !f(fd_EncryptableTransferFunds_DstEWalletID, value) {
			return
		}
	}
	if x.OptInReason != "" {
		value := protoreflect.ValueOfString(x.OptInReason)
		if !f(fd_EncryptableTransferFunds_OptInReason, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EncryptableTransferFunds) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableTransferFunds.HiddenTransferPC":
		return x.HiddenTransferPC != nil
	case "qadena.qadena.EncryptableTransferFunds.DstEWalletID":
		return x.DstEWalletID != nil
	case "qadena.qadena.EncryptableTransferFunds.OptInReason":
		return x.OptInReason != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableTransferFunds"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableTransferFunds does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableTransferFunds) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableTransferFunds.HiddenTransferPC":
		x.HiddenTransferPC = nil
	case "qadena.qadena.EncryptableTransferFunds.DstEWalletID":
		x.DstEWalletID = nil
	case "qadena.qadena.EncryptableTransferFunds.OptInReason":
		x.OptInReason = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableTransferFunds"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableTransferFunds does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EncryptableTransferFunds) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "qadena.qadena.EncryptableTransferFunds.HiddenTransferPC":
		value := x.HiddenTransferPC
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "qadena.qadena.EncryptableTransferFunds.DstEWalletID":
		value := x.DstEWalletID
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "qadena.qadena.EncryptableTransferFunds.OptInReason":
		value := x.OptInReason
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableTransferFunds"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableTransferFunds does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableTransferFunds) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableTransferFunds.HiddenTransferPC":
		x.HiddenTransferPC = value.Message().Interface().(*EncryptablePedersenCommit)
	case "qadena.qadena.EncryptableTransferFunds.DstEWalletID":
		x.DstEWalletID = value.Message().Interface().(*EncryptableTransferFundsEWalletID)
	case "qadena.qadena.EncryptableTransferFunds.OptInReason":
		x.OptInReason = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableTransferFunds"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableTransferFunds does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableTransferFunds) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableTransferFunds.HiddenTransferPC":
		if x.HiddenTransferPC == nil {
			x.HiddenTransferPC = new(EncryptablePedersenCommit)
		}
		return protoreflect.ValueOfMessage(x.HiddenTransferPC.ProtoReflect())
	case "qadena.qadena.EncryptableTransferFunds.DstEWalletID":
		if x.DstEWalletID == nil {
			x.DstEWalletID = new(EncryptableTransferFundsEWalletID)
		}
		return protoreflect.ValueOfMessage(x.DstEWalletID.ProtoReflect())
	case "qadena.qadena.EncryptableTransferFunds.OptInReason":
		panic(fmt.Errorf("field OptInReason of message qadena.qadena.EncryptableTransferFunds is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableTransferFunds"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableTransferFunds does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EncryptableTransferFunds) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableTransferFunds.HiddenTransferPC":
		m := new(EncryptablePedersenCommit)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "qadena.qadena.EncryptableTransferFunds.DstEWalletID":
		m := new(EncryptableTransferFundsEWalletID)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "qadena.qadena.EncryptableTransferFunds.OptInReason":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableTransferFunds"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableTransferFunds does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EncryptableTransferFunds) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in qadena.qadena.EncryptableTransferFunds", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EncryptableTransferFunds) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableTransferFunds) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EncryptableTransferFunds) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EncryptableTransferFunds) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EncryptableTransferFunds)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.HiddenTransferPC != nil {
			l = options.Size(x.HiddenTransferPC)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.DstEWalletID != nil {
			l = options.Size(x.DstEWalletID)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.OptInReason)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableTransferFunds)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.OptInReason) > 0 {
			i -= len(x.OptInReason)
			copy(dAtA[i:], x.OptInReason)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.OptInReason)))
			i--
			dAtA[i] = 0x1a
		}
		if x.DstEWalletID != nil {
			encoded, err := options.Marshal(x.DstEWalletID)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if x.HiddenTransferPC != nil {
			encoded, err := options.Marshal(x.HiddenTransferPC)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableTransferFunds)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableTransferFunds: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableTransferFunds: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field HiddenTransferPC", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.HiddenTransferPC == nil {
					x.HiddenTransferPC = &EncryptablePedersenCommit{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.HiddenTransferPC); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field DstEWalletID", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.DstEWalletID == nil {
					x.DstEWalletID = &EncryptableTransferFundsEWalletID{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.DstEWalletID); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OptInReason", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.OptInReason = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EncryptableReceiveFundsEWalletIDExtraParms       protoreflect.MessageDescriptor
	fd_EncryptableReceiveFundsEWalletIDExtraParms_Queue protoreflect.FieldDescriptor
)

func init() {
	file_qadena_qadena_encryptable_proto_init()
	md_EncryptableReceiveFundsEWalletIDExtraParms = File_qadena_qadena_encryptable_proto.Messages().ByName("EncryptableReceiveFundsEWalletIDExtraParms")
	fd_EncryptableReceiveFundsEWalletIDExtraParms_Queue = md_EncryptableReceiveFundsEWalletIDExtraParms.Fields().ByName("Queue")
}

var _ protoreflect.Message = (*fastReflection_EncryptableReceiveFundsEWalletIDExtraParms)(nil)

type fastReflection_EncryptableReceiveFundsEWalletIDExtraParms EncryptableReceiveFundsEWalletIDExtraParms

func (x *EncryptableReceiveFundsEWalletIDExtraParms) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EncryptableReceiveFundsEWalletIDExtraParms)(x)
}

func (x *EncryptableReceiveFundsEWalletIDExtraParms) slowProtoReflect() protoreflect.Message {
	mi := &file_qadena_qadena_encryptable_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EncryptableReceiveFundsEWalletIDExtraParms_messageType fastReflection_EncryptableReceiveFundsEWalletIDExtraParms_messageType
var _ protoreflect.MessageType = fastReflection_EncryptableReceiveFundsEWalletIDExtraParms_messageType{}

type fastReflection_EncryptableReceiveFundsEWalletIDExtraParms_messageType struct{}

func (x fastReflection_EncryptableReceiveFundsEWalletIDExtraParms_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EncryptableReceiveFundsEWalletIDExtraParms)(nil)
}
func (x fastReflection_EncryptableReceiveFundsEWalletIDExtraParms_messageType) New() protoreflect.Message {
	return new(fastReflection_EncryptableReceiveFundsEWalletIDExtraParms)
}
func (x fastReflection_EncryptableReceiveFundsEWalletIDExtraParms_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableReceiveFundsEWalletIDExtraParms
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EncryptableReceiveFundsEWalletIDExtraParms) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableReceiveFundsEWalletIDExtraParms
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EncryptableReceiveFundsEWalletIDExtraParms) Type() protoreflect.MessageType {
	return _fastReflection_EncryptableReceiveFundsEWalletIDExtraParms_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EncryptableReceiveFundsEWalletIDExtraParms) New() protoreflect.Message {
	return new(fastReflection_EncryptableReceiveFundsEWalletIDExtraParms)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EncryptableReceiveFundsEWalletIDExtraParms) Interface() protoreflect.ProtoMessage {
	return (*EncryptableReceiveFundsEWalletIDExtraParms)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EncryptableReceiveFundsEWalletIDExtraParms) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Queue != "" {
		value := protoreflect.ValueOfString(x.Queue)
		if !f(fd_EncryptableReceiveFundsEWalletIDExtraParms_Queue, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EncryptableReceiveFundsEWalletIDExtraParms) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableReceiveFundsEWalletIDExtraParms.Queue":
		return x.Queue != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableReceiveFundsEWalletIDExtraParms"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableReceiveFundsEWalletIDExtraParms does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableReceiveFundsEWalletIDExtraParms) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableReceiveFundsEWalletIDExtraParms.Queue":
		x.Queue = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableReceiveFundsEWalletIDExtraParms"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableReceiveFundsEWalletIDExtraParms does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EncryptableReceiveFundsEWalletIDExtraParms) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "qadena.qadena.EncryptableReceiveFundsEWalletIDExtraParms.Queue":
		value := x.Queue
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableReceiveFundsEWalletIDExtraParms"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableReceiveFundsEWalletIDExtraParms does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableReceiveFundsEWalletIDExtraParms) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableReceiveFundsEWalletIDExtraParms.Queue":
		x.Queue = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableReceiveFundsEWalletIDExtraParms"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableReceiveFundsEWalletIDExtraParms does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableReceiveFundsEWalletIDExtraParms) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableReceiveFundsEWalletIDExtraParms.Queue":
		panic(fmt.Errorf("field Queue of message qadena.qadena.EncryptableReceiveFundsEWalletIDExtraParms is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableReceiveFundsEWalletIDExtraParms"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableReceiveFundsEWalletIDExtraParms does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EncryptableReceiveFundsEWalletIDExtraParms) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableReceiveFundsEWalletIDExtraParms.Queue":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableReceiveFundsEWalletIDExtraParms"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableReceiveFundsEWalletIDExtraParms does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EncryptableReceiveFundsEWalletIDExtraParms) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in qadena.qadena.EncryptableReceiveFundsEWalletIDExtraParms", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EncryptableReceiveFundsEWalletIDExtraParms) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableReceiveFundsEWalletIDExtraParms) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EncryptableReceiveFundsEWalletIDExtraParms) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EncryptableReceiveFundsEWalletIDExtraParms) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EncryptableReceiveFundsEWalletIDExtraParms)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Queue)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableReceiveFundsEWalletIDExtraParms)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Queue) > 0 {
			i -= len(x.Queue)
			copy(dAtA[i:], x.Queue)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Queue)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableReceiveFundsEWalletIDExtraParms)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableReceiveFundsEWalletIDExtraParms: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableReceiveFundsEWalletIDExtraParms: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Queue = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EncryptableReceiveFundsEWalletID            protoreflect.MessageDescriptor
	fd_EncryptableReceiveFundsEWalletID_Nonce      protoreflect.FieldDescriptor
	fd_EncryptableReceiveFundsEWalletID_WalletID   protoreflect.FieldDescriptor
	fd_EncryptableReceiveFundsEWalletID_ExtraParms protoreflect.FieldDescriptor
)

func init() {
	file_qadena_qadena_encryptable_proto_init()
	md_EncryptableReceiveFundsEWalletID = File_qadena_qadena_encryptable_proto.Messages().ByName("EncryptableReceiveFundsEWalletID")
	fd_EncryptableReceiveFundsEWalletID_Nonce = md_EncryptableReceiveFundsEWalletID.Fields().ByName("Nonce")
	fd_EncryptableReceiveFundsEWalletID_WalletID = md_EncryptableReceiveFundsEWalletID.Fields().ByName("WalletID")
	fd_EncryptableReceiveFundsEWalletID_ExtraParms = md_EncryptableReceiveFundsEWalletID.Fields().ByName("ExtraParms")
}

var _ protoreflect.Message = (*fastReflection_EncryptableReceiveFundsEWalletID)(nil)

type fastReflection_EncryptableReceiveFundsEWalletID EncryptableReceiveFundsEWalletID

func (x *EncryptableReceiveFundsEWalletID) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EncryptableReceiveFundsEWalletID)(x)
}

func (x *EncryptableReceiveFundsEWalletID) slowProtoReflect() protoreflect.Message {
	mi := &file_qadena_qadena_encryptable_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EncryptableReceiveFundsEWalletID_messageType fastReflection_EncryptableReceiveFundsEWalletID_messageType
var _ protoreflect.MessageType = fastReflection_EncryptableReceiveFundsEWalletID_messageType{}

type fastReflection_EncryptableReceiveFundsEWalletID_messageType struct{}

func (x fastReflection_EncryptableReceiveFundsEWalletID_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EncryptableReceiveFundsEWalletID)(nil)
}
func (x fastReflection_EncryptableReceiveFundsEWalletID_messageType) New() protoreflect.Message {
	return new(fastReflection_EncryptableReceiveFundsEWalletID)
}
func (x fastReflection_EncryptableReceiveFundsEWalletID_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableReceiveFundsEWalletID
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EncryptableReceiveFundsEWalletID) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableReceiveFundsEWalletID
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EncryptableReceiveFundsEWalletID) Type() protoreflect.MessageType {
	return _fastReflection_EncryptableReceiveFundsEWalletID_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EncryptableReceiveFundsEWalletID) New() protoreflect.Message {
	return new(fastReflection_EncryptableReceiveFundsEWalletID)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EncryptableReceiveFundsEWalletID) Interface() protoreflect.ProtoMessage {
	return (*EncryptableReceiveFundsEWalletID)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EncryptableReceiveFundsEWalletID) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Nonce != "" {
		value := protoreflect.ValueOfString(x.Nonce)
		if !f(fd_EncryptableReceiveFundsEWalletID_Nonce, value) {
			return
		}
	}
	if x.WalletID != "" {
		value := protoreflect.ValueOfString(x.WalletID)
		if !f(fd_EncryptableReceiveFundsEWalletID_WalletID, value) {
			return
		}
	}
	if x.ExtraParms != nil {
		value := protoreflect.ValueOfMessage(x.ExtraParms.ProtoReflect())
		if !f(fd_EncryptableReceiveFundsEWalletID_ExtraParms, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EncryptableReceiveFundsEWalletID) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableReceiveFundsEWalletID.Nonce":
		return x.Nonce != ""
	case "qadena.qadena.EncryptableReceiveFundsEWalletID.WalletID":
		return x.WalletID != ""
	case "qadena.qadena.EncryptableReceiveFundsEWalletID.ExtraParms":
		return x.ExtraParms != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableReceiveFundsEWalletID"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableReceiveFundsEWalletID does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableReceiveFundsEWalletID) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableReceiveFundsEWalletID.Nonce":
		x.Nonce = ""
	case "qadena.qadena.EncryptableReceiveFundsEWalletID.WalletID":
		x.WalletID = ""
	case "qadena.qadena.EncryptableReceiveFundsEWalletID.ExtraParms":
		x.ExtraParms = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableReceiveFundsEWalletID"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableReceiveFundsEWalletID does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EncryptableReceiveFundsEWalletID) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "qadena.qadena.EncryptableReceiveFundsEWalletID.Nonce":
		value := x.Nonce
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableReceiveFundsEWalletID.WalletID":
		value := x.WalletID
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableReceiveFundsEWalletID.ExtraParms":
		value := x.ExtraParms
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableReceiveFundsEWalletID"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableReceiveFundsEWalletID does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableReceiveFundsEWalletID) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableReceiveFundsEWalletID.Nonce":
		x.Nonce = value.Interface().(string)
	case "qadena.qadena.EncryptableReceiveFundsEWalletID.WalletID":
		x.WalletID = value.Interface().(string)
	case "qadena.qadena.EncryptableReceiveFundsEWalletID.ExtraParms":
		x.ExtraParms = value.Message().Interface().(*EncryptableReceiveFundsEWalletIDExtraParms)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableReceiveFundsEWalletID"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableReceiveFundsEWalletID does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableReceiveFundsEWalletID) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableReceiveFundsEWalletID.ExtraParms":
		if x.ExtraParms == nil {
			x.ExtraParms = new(EncryptableReceiveFundsEWalletIDExtraParms)
		}
		return protoreflect.ValueOfMessage(x.ExtraParms.ProtoReflect())
	case "qadena.qadena.EncryptableReceiveFundsEWalletID.Nonce":
		panic(fmt.Errorf("field Nonce of message qadena.qadena.EncryptableReceiveFundsEWalletID is not mutable"))
	case "qadena.qadena.EncryptableReceiveFundsEWalletID.WalletID":
		panic(fmt.Errorf("field WalletID of message qadena.qadena.EncryptableReceiveFundsEWalletID is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableReceiveFundsEWalletID"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableReceiveFundsEWalletID does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EncryptableReceiveFundsEWalletID) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableReceiveFundsEWalletID.Nonce":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableReceiveFundsEWalletID.WalletID":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableReceiveFundsEWalletID.ExtraParms":
		m := new(EncryptableReceiveFundsEWalletIDExtraParms)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableReceiveFundsEWalletID"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableReceiveFundsEWalletID does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EncryptableReceiveFundsEWalletID) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in qadena.qadena.EncryptableReceiveFundsEWalletID", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EncryptableReceiveFundsEWalletID) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableReceiveFundsEWalletID) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EncryptableReceiveFundsEWalletID) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EncryptableReceiveFundsEWalletID) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EncryptableReceiveFundsEWalletID)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Nonce)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.WalletID)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.ExtraParms != nil {
			l = options.Size(x.ExtraParms)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableReceiveFundsEWalletID)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.ExtraParms != nil {
			encoded, err := options.Marshal(x.ExtraParms)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.WalletID) > 0 {
			i -= len(x.WalletID)
			copy(dAtA[i:], x.WalletID)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.WalletID)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Nonce) > 0 {
			i -= len(x.Nonce)
			copy(dAtA[i:], x.Nonce)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Nonce)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableReceiveFundsEWalletID)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableReceiveFundsEWalletID: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableReceiveFundsEWalletID: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Nonce = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field WalletID", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.WalletID = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field ExtraParms", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.ExtraParms == nil {
					x.ExtraParms = &EncryptableReceiveFundsEWalletIDExtraParms{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.ExtraParms); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EncryptableSignRecoverKeyEWalletID          protoreflect.MessageDescriptor
	fd_EncryptableSignRecoverKeyEWalletID_Nonce    protoreflect.FieldDescriptor
	fd_EncryptableSignRecoverKeyEWalletID_WalletID protoreflect.FieldDescriptor
)

func init() {
	file_qadena_qadena_encryptable_proto_init()
	md_EncryptableSignRecoverKeyEWalletID = File_qadena_qadena_encryptable_proto.Messages().ByName("EncryptableSignRecoverKeyEWalletID")
	fd_EncryptableSignRecoverKeyEWalletID_Nonce = md_EncryptableSignRecoverKeyEWalletID.Fields().ByName("Nonce")
	fd_EncryptableSignRecoverKeyEWalletID_WalletID = md_EncryptableSignRecoverKeyEWalletID.Fields().ByName("WalletID")
}

var _ protoreflect.Message = (*fastReflection_EncryptableSignRecoverKeyEWalletID)(nil)

type fastReflection_EncryptableSignRecoverKeyEWalletID EncryptableSignRecoverKeyEWalletID

func (x *EncryptableSignRecoverKeyEWalletID) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EncryptableSignRecoverKeyEWalletID)(x)
}

func (x *EncryptableSignRecoverKeyEWalletID) slowProtoReflect() protoreflect.Message {
	mi := &file_qadena_qadena_encryptable_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EncryptableSignRecoverKeyEWalletID_messageType fastReflection_EncryptableSignRecoverKeyEWalletID_messageType
var _ protoreflect.MessageType = fastReflection_EncryptableSignRecoverKeyEWalletID_messageType{}

type fastReflection_EncryptableSignRecoverKeyEWalletID_messageType struct{}

func (x fastReflection_EncryptableSignRecoverKeyEWalletID_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EncryptableSignRecoverKeyEWalletID)(nil)
}
func (x fastReflection_EncryptableSignRecoverKeyEWalletID_messageType) New() protoreflect.Message {
	return new(fastReflection_EncryptableSignRecoverKeyEWalletID)
}
func (x fastReflection_EncryptableSignRecoverKeyEWalletID_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableSignRecoverKeyEWalletID
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EncryptableSignRecoverKeyEWalletID) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableSignRecoverKeyEWalletID
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EncryptableSignRecoverKeyEWalletID) Type() protoreflect.MessageType {
	return _fastReflection_EncryptableSignRecoverKeyEWalletID_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EncryptableSignRecoverKeyEWalletID) New() protoreflect.Message {
	return new(fastReflection_EncryptableSignRecoverKeyEWalletID)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EncryptableSignRecoverKeyEWalletID) Interface() protoreflect.ProtoMessage {
	return (*EncryptableSignRecoverKeyEWalletID)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EncryptableSignRecoverKeyEWalletID) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Nonce != "" {
		value := protoreflect.ValueOfString(x.Nonce)
		if !f(fd_EncryptableSignRecoverKeyEWalletID_Nonce, value) {
			return
		}
	}
	if x.WalletID != "" {
		value := protoreflect.ValueOfString(x.WalletID)
		if !f(fd_EncryptableSignRecoverKeyEWalletID_WalletID, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EncryptableSignRecoverKeyEWalletID) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSignRecoverKeyEWalletID.Nonce":
		return x.Nonce != ""
	case "qadena.qadena.EncryptableSignRecoverKeyEWalletID.WalletID":
		return x.WalletID != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSignRecoverKeyEWalletID"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSignRecoverKeyEWalletID does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableSignRecoverKeyEWalletID) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSignRecoverKeyEWalletID.Nonce":
		x.Nonce = ""
	case "qadena.qadena.EncryptableSignRecoverKeyEWalletID.WalletID":
		x.WalletID = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSignRecoverKeyEWalletID"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSignRecoverKeyEWalletID does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EncryptableSignRecoverKeyEWalletID) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "qadena.qadena.EncryptableSignRecoverKeyEWalletID.Nonce":
		value := x.Nonce
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableSignRecoverKeyEWalletID.WalletID":
		value := x.WalletID
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSignRecoverKeyEWalletID"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSignRecoverKeyEWalletID does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableSignRecoverKeyEWalletID) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSignRecoverKeyEWalletID.Nonce":
		x.Nonce = value.Interface().(string)
	case "qadena.qadena.EncryptableSignRecoverKeyEWalletID.WalletID":
		x.WalletID = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSignRecoverKeyEWalletID"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSignRecoverKeyEWalletID does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableSignRecoverKeyEWalletID) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSignRecoverKeyEWalletID.Nonce":
		panic(fmt.Errorf("field Nonce of message qadena.qadena.EncryptableSignRecoverKeyEWalletID is not mutable"))
	case "qadena.qadena.EncryptableSignRecoverKeyEWalletID.WalletID":
		panic(fmt.Errorf("field WalletID of message qadena.qadena.EncryptableSignRecoverKeyEWalletID is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSignRecoverKeyEWalletID"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSignRecoverKeyEWalletID does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EncryptableSignRecoverKeyEWalletID) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSignRecoverKeyEWalletID.Nonce":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableSignRecoverKeyEWalletID.WalletID":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSignRecoverKeyEWalletID"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSignRecoverKeyEWalletID does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EncryptableSignRecoverKeyEWalletID) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in qadena.qadena.EncryptableSignRecoverKeyEWalletID", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EncryptableSignRecoverKeyEWalletID) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableSignRecoverKeyEWalletID) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EncryptableSignRecoverKeyEWalletID) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EncryptableSignRecoverKeyEWalletID) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EncryptableSignRecoverKeyEWalletID)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Nonce)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.WalletID)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableSignRecoverKeyEWalletID)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.WalletID) > 0 {
			i -= len(x.WalletID)
			copy(dAtA[i:], x.WalletID)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.WalletID)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Nonce) > 0 {
			i -= len(x.Nonce)
			copy(dAtA[i:], x.Nonce)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Nonce)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableSignRecoverKeyEWalletID)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableSignRecoverKeyEWalletID: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableSignRecoverKeyEWalletID: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Nonce = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field WalletID", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.WalletID = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EncryptableReceiveFunds              protoreflect.MessageDescriptor
	fd_EncryptableReceiveFunds_EphEWalletID protoreflect.FieldDescriptor
)

func init() {
	file_qadena_qadena_encryptable_proto_init()
	md_EncryptableReceiveFunds = File_qadena_qadena_encryptable_proto.Messages().ByName("EncryptableReceiveFunds")
	fd_EncryptableReceiveFunds_EphEWalletID = md_EncryptableReceiveFunds.Fields().ByName("EphEWalletID")
}

var _ protoreflect.Message = (*fastReflection_EncryptableReceiveFunds)(nil)

type fastReflection_EncryptableReceiveFunds EncryptableReceiveFunds

func (x *EncryptableReceiveFunds) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EncryptableReceiveFunds)(x)
}

func (x *EncryptableReceiveFunds) slowProtoReflect() protoreflect.Message {
	mi := &file_qadena_qadena_encryptable_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EncryptableReceiveFunds_messageType fastReflection_EncryptableReceiveFunds_messageType
var _ protoreflect.MessageType = fastReflection_EncryptableReceiveFunds_messageType{}

type fastReflection_EncryptableReceiveFunds_messageType struct{}

func (x fastReflection_EncryptableReceiveFunds_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EncryptableReceiveFunds)(nil)
}
func (x fastReflection_EncryptableReceiveFunds_messageType) New() protoreflect.Message {
	return new(fastReflection_EncryptableReceiveFunds)
}
func (x fastReflection_EncryptableReceiveFunds_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableReceiveFunds
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EncryptableReceiveFunds) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableReceiveFunds
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EncryptableReceiveFunds) Type() protoreflect.MessageType {
	return _fastReflection_EncryptableReceiveFunds_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EncryptableReceiveFunds) New() protoreflect.Message {
	return new(fastReflection_EncryptableReceiveFunds)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EncryptableReceiveFunds) Interface() protoreflect.ProtoMessage {
	return (*EncryptableReceiveFunds)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EncryptableReceiveFunds) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.EphEWalletID != nil {
		value := protoreflect.ValueOfMessage(x.EphEWalletID.ProtoReflect())
		if !f(fd_EncryptableReceiveFunds_EphEWalletID, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EncryptableReceiveFunds) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableReceiveFunds.EphEWalletID":
		return x.EphEWalletID != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableReceiveFunds"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableReceiveFunds does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableReceiveFunds) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableReceiveFunds.EphEWalletID":
		x.EphEWalletID = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableReceiveFunds"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableReceiveFunds does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EncryptableReceiveFunds) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "qadena.qadena.EncryptableReceiveFunds.EphEWalletID":
		value := x.EphEWalletID
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableReceiveFunds"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableReceiveFunds does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableReceiveFunds) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableReceiveFunds.EphEWalletID":
		x.EphEWalletID = value.Message().Interface().(*EncryptableReceiveFundsEWalletID)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableReceiveFunds"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableReceiveFunds does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableReceiveFunds) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableReceiveFunds.EphEWalletID":
		if x.EphEWalletID == nil {
			x.EphEWalletID = new(EncryptableReceiveFundsEWalletID)
		}
		return protoreflect.ValueOfMessage(x.EphEWalletID.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableReceiveFunds"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableReceiveFunds does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EncryptableReceiveFunds) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableReceiveFunds.EphEWalletID":
		m := new(EncryptableReceiveFundsEWalletID)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableReceiveFunds"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableReceiveFunds does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EncryptableReceiveFunds) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in qadena.qadena.EncryptableReceiveFunds", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EncryptableReceiveFunds) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableReceiveFunds) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EncryptableReceiveFunds) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EncryptableReceiveFunds) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EncryptableReceiveFunds)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.EphEWalletID != nil {
			l = options.Size(x.EphEWalletID)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableReceiveFunds)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.EphEWalletID != nil {
			encoded, err := options.Marshal(x.EphEWalletID)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableReceiveFunds)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableReceiveFunds: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableReceiveFunds: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field EphEWalletID", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.EphEWalletID == nil {
					x.EphEWalletID = &EncryptableReceiveFundsEWalletID{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.EphEWalletID); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EncryptableAnonTransferFunds                       protoreflect.MessageDescriptor
	fd_EncryptableAnonTransferFunds_TotalTransferPrimePC  protoreflect.FieldDescriptor
	fd_EncryptableAnonTransferFunds_TransparentTransferBF protoreflect.FieldDescriptor
)

func init() {
	file_qadena_qadena_encryptable_proto_init()
	md_EncryptableAnonTransferFunds = File_qadena_qadena_encryptable_proto.Messages().ByName("EncryptableAnonTransferFunds")
	fd_EncryptableAnonTransferFunds_TotalTransferPrimePC = md_EncryptableAnonTransferFunds.Fields().ByName("TotalTransferPrimePC")
	fd_EncryptableAnonTransferFunds_TransparentTransferBF = md_EncryptableAnonTransferFunds.Fields().ByName("TransparentTransferBF")
}

var _ protoreflect.Message = (*fastReflection_EncryptableAnonTransferFunds)(nil)

type fastReflection_EncryptableAnonTransferFunds EncryptableAnonTransferFunds

func (x *EncryptableAnonTransferFunds) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EncryptableAnonTransferFunds)(x)
}

func (x *EncryptableAnonTransferFunds) slowProtoReflect() protoreflect.Message {
	mi := &file_qadena_qadena_encryptable_proto_msgTypes[21]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EncryptableAnonTransferFunds_messageType fastReflection_EncryptableAnonTransferFunds_messageType
var _ protoreflect.MessageType = fastReflection_EncryptableAnonTransferFunds_messageType{}

type fastReflection_EncryptableAnonTransferFunds_messageType struct{}

func (x fastReflection_EncryptableAnonTransferFunds_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EncryptableAnonTransferFunds)(nil)
}
func (x fastReflection_EncryptableAnonTransferFunds_messageType) New() protoreflect.Message {
	return new(fastReflection_EncryptableAnonTransferFunds)
}
func (x fastReflection_EncryptableAnonTransferFunds_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableAnonTransferFunds
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EncryptableAnonTransferFunds) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableAnonTransferFunds
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EncryptableAnonTransferFunds) Type() protoreflect.MessageType {
	return _fastReflection_EncryptableAnonTransferFunds_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EncryptableAnonTransferFunds) New() protoreflect.Message {
	return new(fastReflection_EncryptableAnonTransferFunds)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EncryptableAnonTransferFunds) Interface() protoreflect.ProtoMessage {
	return (*EncryptableAnonTransferFunds)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EncryptableAnonTransferFunds) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.TotalTransferPrimePC != nil {
		value := protoreflect.ValueOfMessage(x.TotalTransferPrimePC.ProtoReflect())
		if !f(fd_EncryptableAnonTransferFunds_TotalTransferPrimePC, value) {
			return
		}
	}
	if x.TransparentTransferBF != nil {
		value := protoreflect.ValueOfMessage(x.TransparentTransferBF.ProtoReflect())
		if !f(fd_EncryptableAnonTransferFunds_TransparentTransferBF, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EncryptableAnonTransferFunds) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableAnonTransferFunds.TotalTransferPrimePC":
		return x.TotalTransferPrimePC != nil
	case "qadena.qadena.EncryptableAnonTransferFunds.TransparentTransferBF":
		return x.TransparentTransferBF != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableAnonTransferFunds"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableAnonTransferFunds does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableAnonTransferFunds) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableAnonTransferFunds.TotalTransferPrimePC":
		x.TotalTransferPrimePC = nil
	case "qadena.qadena.EncryptableAnonTransferFunds.TransparentTransferBF":
		x.TransparentTransferBF = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableAnonTransferFunds"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableAnonTransferFunds does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EncryptableAnonTransferFunds) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "qadena.qadena.EncryptableAnonTransferFunds.TotalTransferPrimePC":
		value := x.TotalTransferPrimePC
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "qadena.qadena.EncryptableAnonTransferFunds.TransparentTransferBF":
		value := x.TransparentTransferBF
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableAnonTransferFunds"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableAnonTransferFunds does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableAnonTransferFunds) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableAnonTransferFunds.TotalTransferPrimePC":
		x.TotalTransferPrimePC = value.Message().Interface().(*EncryptablePedersenCommit)
	case "qadena.qadena.EncryptableAnonTransferFunds.TransparentTransferBF":
		x.TransparentTransferBF = value.Message().Interface().(*BInt)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableAnonTransferFunds"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableAnonTransferFunds does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableAnonTransferFunds) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableAnonTransferFunds.TotalTransferPrimePC":
		if x.TotalTransferPrimePC == nil {
			x.TotalTransferPrimePC = new(EncryptablePedersenCommit)
		}
		return protoreflect.ValueOfMessage(x.TotalTransferPrimePC.ProtoReflect())
	case "qadena.qadena.EncryptableAnonTransferFunds.TransparentTransferBF":
		if x.TransparentTransferBF == nil {
			x.TransparentTransferBF = new(BInt)
		}
		return protoreflect.ValueOfMessage(x.TransparentTransferBF.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableAnonTransferFunds"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableAnonTransferFunds does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EncryptableAnonTransferFunds) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableAnonTransferFunds.TotalTransferPrimePC":
		m := new(EncryptablePedersenCommit)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "qadena.qadena.EncryptableAnonTransferFunds.TransparentTransferBF":
		m := new(BInt)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableAnonTransferFunds"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableAnonTransferFunds does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EncryptableAnonTransferFunds) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in qadena.qadena.EncryptableAnonTransferFunds", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EncryptableAnonTransferFunds) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableAnonTransferFunds) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EncryptableAnonTransferFunds) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EncryptableAnonTransferFunds) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EncryptableAnonTransferFunds)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.TotalTransferPrimePC != nil {
			l = options.Size(x.TotalTransferPrimePC)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.TransparentTransferBF != nil {
			l = options.Size(x.TransparentTransferBF)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableAnonTransferFunds)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.TransparentTransferBF != nil {
			encoded, err := options.Marshal(x.TransparentTransferBF)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if x.TotalTransferPrimePC != nil {
			encoded, err := options.Marshal(x.TotalTransferPrimePC)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableAnonTransferFunds)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableAnonTransferFunds: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableAnonTransferFunds: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TotalTransferPrimePC", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.TotalTransferPrimePC == nil {
					x.TotalTransferPrimePC = &EncryptablePedersenCommit{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.TotalTransferPrimePC); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field TransparentTransferBF", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.TransparentTransferBF == nil {
					x.TransparentTransferBF = &BInt{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.TransparentTransferBF); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EncryptableESuspiciousAmount               protoreflect.MessageDescriptor
	fd_EncryptableESuspiciousAmount_Nonce         protoreflect.FieldDescriptor
	fd_EncryptableESuspiciousAmount_USDCoinAmount protoreflect.FieldDescriptor
	fd_EncryptableESuspiciousAmount_CoinAmount    protoreflect.FieldDescriptor
)

func init() {
	file_qadena_qadena_encryptable_proto_init()
	md_EncryptableESuspiciousAmount = File_qadena_qadena_encryptable_proto.Messages().ByName("EncryptableESuspiciousAmount")
	fd_EncryptableESuspiciousAmount_Nonce = md_EncryptableESuspiciousAmount.Fields().ByName("Nonce")
	fd_EncryptableESuspiciousAmount_USDCoinAmount = md_EncryptableESuspiciousAmount.Fields().ByName("USDCoinAmount")
	fd_EncryptableESuspiciousAmount_CoinAmount = md_EncryptableESuspiciousAmount.Fields().ByName("CoinAmount")
}

var _ protoreflect.Message = (*fastReflection_EncryptableESuspiciousAmount)(nil)

type fastReflection_EncryptableESuspiciousAmount EncryptableESuspiciousAmount

func (x *EncryptableESuspiciousAmount) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EncryptableESuspiciousAmount)(x)
}

func (x *EncryptableESuspiciousAmount) slowProtoReflect() protoreflect.Message {
	mi := &file_qadena_qadena_encryptable_proto_msgTypes[22]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EncryptableESuspiciousAmount_messageType fastReflection_EncryptableESuspiciousAmount_messageType
var _ protoreflect.MessageType = fastReflection_EncryptableESuspiciousAmount_messageType{}

type fastReflection_EncryptableESuspiciousAmount_messageType struct{}

func (x fastReflection_EncryptableESuspiciousAmount_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EncryptableESuspiciousAmount)(nil)
}
func (x fastReflection_EncryptableESuspiciousAmount_messageType) New() protoreflect.Message {
	return new(fastReflection_EncryptableESuspiciousAmount)
}
func (x fastReflection_EncryptableESuspiciousAmount_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableESuspiciousAmount
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EncryptableESuspiciousAmount) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableESuspiciousAmount
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EncryptableESuspiciousAmount) Type() protoreflect.MessageType {
	return _fastReflection_EncryptableESuspiciousAmount_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EncryptableESuspiciousAmount) New() protoreflect.Message {
	return new(fastReflection_EncryptableESuspiciousAmount)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EncryptableESuspiciousAmount) Interface() protoreflect.ProtoMessage {
	return (*EncryptableESuspiciousAmount)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EncryptableESuspiciousAmount) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Nonce != "" {
		value := protoreflect.ValueOfString(x.Nonce)
		if !f(fd_EncryptableESuspiciousAmount_Nonce, value) {
			return
		}
	}
	if x.USDCoinAmount != nil {
		value := protoreflect.ValueOfMessage(x.USDCoinAmount.ProtoReflect())
		if !f(fd_EncryptableESuspiciousAmount_USDCoinAmount, value) {
			return
		}
	}
	if x.CoinAmount != nil {
		value := protoreflect.ValueOfMessage(x.CoinAmount.ProtoReflect())
		if !f(fd_EncryptableESuspiciousAmount_CoinAmount, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EncryptableESuspiciousAmount) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableESuspiciousAmount.Nonce":
		return x.Nonce != ""
	case "qadena.qadena.EncryptableESuspiciousAmount.USDCoinAmount":
		return x.USDCoinAmount != nil
	case "qadena.qadena.EncryptableESuspiciousAmount.CoinAmount":
		return x.CoinAmount != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableESuspiciousAmount"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableESuspiciousAmount does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableESuspiciousAmount) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableESuspiciousAmount.Nonce":
		x.Nonce = ""
	case "qadena.qadena.EncryptableESuspiciousAmount.USDCoinAmount":
		x.USDCoinAmount = nil
	case "qadena.qadena.EncryptableESuspiciousAmount.CoinAmount":
		x.CoinAmount = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableESuspiciousAmount"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableESuspiciousAmount does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EncryptableESuspiciousAmount) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "qadena.qadena.EncryptableESuspiciousAmount.Nonce":
		value := x.Nonce
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableESuspiciousAmount.USDCoinAmount":
		value := x.USDCoinAmount
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "qadena.qadena.EncryptableESuspiciousAmount.CoinAmount":
		value := x.CoinAmount
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableESuspiciousAmount"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableESuspiciousAmount does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableESuspiciousAmount) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableESuspiciousAmount.Nonce":
		x.Nonce = value.Interface().(string)
	case "qadena.qadena.EncryptableESuspiciousAmount.USDCoinAmount":
		x.USDCoinAmount = value.Message().Interface().(*v1beta1.Coin)
	case "qadena.qadena.EncryptableESuspiciousAmount.CoinAmount":
		x.CoinAmount = value.Message().Interface().(*v1beta1.Coin)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableESuspiciousAmount"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableESuspiciousAmount does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableESuspiciousAmount) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableESuspiciousAmount.USDCoinAmount":
		if x.USDCoinAmount == nil {
			x.USDCoinAmount = new(v1beta1.Coin)
		}
		return protoreflect.ValueOfMessage(x.USDCoinAmount.ProtoReflect())
	case "qadena.qadena.EncryptableESuspiciousAmount.CoinAmount":
		if x.CoinAmount == nil {
			x.CoinAmount = new(v1beta1.Coin)
		}
		return protoreflect.ValueOfMessage(x.CoinAmount.ProtoReflect())
	case "qadena.qadena.EncryptableESuspiciousAmount.Nonce":
		panic(fmt.Errorf("field Nonce of message qadena.qadena.EncryptableESuspiciousAmount is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableESuspiciousAmount"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableESuspiciousAmount does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EncryptableESuspiciousAmount) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableESuspiciousAmount.Nonce":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableESuspiciousAmount.USDCoinAmount":
		m := new(v1beta1.Coin)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "qadena.qadena.EncryptableESuspiciousAmount.CoinAmount":
		m := new(v1beta1.Coin)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableESuspiciousAmount"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableESuspiciousAmount does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EncryptableESuspiciousAmount) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in qadena.qadena.EncryptableESuspiciousAmount", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EncryptableESuspiciousAmount) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableESuspiciousAmount) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EncryptableESuspiciousAmount) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EncryptableESuspiciousAmount) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EncryptableESuspiciousAmount)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Nonce)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.USDCoinAmount != nil {
			l = options.Size(x.USDCoinAmount)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.CoinAmount != nil {
			l = options.Size(x.CoinAmount)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableESuspiciousAmount)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.CoinAmount != nil {
			encoded, err := options.Marshal(x.CoinAmount)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x1a
		}
		if x.USDCoinAmount != nil {
			encoded, err := options.Marshal(x.USDCoinAmount)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Nonce) > 0 {
			i -= len(x.Nonce)
			copy(dAtA[i:], x.Nonce)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Nonce)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableESuspiciousAmount)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableESuspiciousAmount: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableESuspiciousAmount: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Nonce = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field USDCoinAmount", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.USDCoinAmount == nil {
					x.USDCoinAmount = &v1beta1.Coin{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.USDCoinAmount); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field CoinAmount", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.CoinAmount == nil {
					x.CoinAmount = &v1beta1.Coin{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.CoinAmount); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EncryptableSSIDAndPrivK        protoreflect.MessageDescriptor
	fd_EncryptableSSIDAndPrivK_PubKID protoreflect.FieldDescriptor
	fd_EncryptableSSIDAndPrivK_PubK   protoreflect.FieldDescriptor
	fd_EncryptableSSIDAndPrivK_PrivK  protoreflect.FieldDescriptor
)

func init() {
	file_qadena_qadena_encryptable_proto_init()
	md_EncryptableSSIDAndPrivK = File_qadena_qadena_encryptable_proto.Messages().ByName("EncryptableSSIDAndPrivK")
	fd_EncryptableSSIDAndPrivK_PubKID = md_EncryptableSSIDAndPrivK.Fields().ByName("PubKID")
	fd_EncryptableSSIDAndPrivK_PubK = md_EncryptableSSIDAndPrivK.Fields().ByName("PubK")
	fd_EncryptableSSIDAndPrivK_PrivK = md_EncryptableSSIDAndPrivK.Fields().ByName("PrivK")
}

var _ protoreflect.Message = (*fastReflection_EncryptableSSIDAndPrivK)(nil)

type fastReflection_EncryptableSSIDAndPrivK EncryptableSSIDAndPrivK

func (x *EncryptableSSIDAndPrivK) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EncryptableSSIDAndPrivK)(x)
}

func (x *EncryptableSSIDAndPrivK) slowProtoReflect() protoreflect.Message {
	mi := &file_qadena_qadena_encryptable_proto_msgTypes[23]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EncryptableSSIDAndPrivK_messageType fastReflection_EncryptableSSIDAndPrivK_messageType
var _ protoreflect.MessageType = fastReflection_EncryptableSSIDAndPrivK_messageType{}

type fastReflection_EncryptableSSIDAndPrivK_messageType struct{}

func (x fastReflection_EncryptableSSIDAndPrivK_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EncryptableSSIDAndPrivK)(nil)
}
func (x fastReflection_EncryptableSSIDAndPrivK_messageType) New() protoreflect.Message {
	return new(fastReflection_EncryptableSSIDAndPrivK)
}
func (x fastReflection_EncryptableSSIDAndPrivK_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableSSIDAndPrivK
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EncryptableSSIDAndPrivK) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableSSIDAndPrivK
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EncryptableSSIDAndPrivK) Type() protoreflect.MessageType {
	return _fastReflection_EncryptableSSIDAndPrivK_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EncryptableSSIDAndPrivK) New() protoreflect.Message {
	return new(fastReflection_EncryptableSSIDAndPrivK)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EncryptableSSIDAndPrivK) Interface() protoreflect.ProtoMessage {
	return (*EncryptableSSIDAndPrivK)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EncryptableSSIDAndPrivK) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.PubKID != "" {
		value := protoreflect.ValueOfString(x.PubKID)
		if !f(fd_EncryptableSSIDAndPrivK_PubKID, value) {
			return
		}
	}
	if x.PubK != "" {
		value := protoreflect.ValueOfString(x.PubK)
		if !f(fd_EncryptableSSIDAndPrivK_PubK, value) {
			return
		}
	}
	if x.PrivK != "" {
		value := protoreflect.ValueOfString(x.PrivK)
		if !f(fd_EncryptableSSIDAndPrivK_PrivK, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EncryptableSSIDAndPrivK) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSSIDAndPrivK.PubKID":
		return x.PubKID != ""
	case "qadena.qadena.EncryptableSSIDAndPrivK.PubK":
		return x.PubK != ""
	case "qadena.qadena.EncryptableSSIDAndPrivK.PrivK":
		return x.PrivK != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSSIDAndPrivK"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSSIDAndPrivK does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableSSIDAndPrivK) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSSIDAndPrivK.PubKID":
		x.PubKID = ""
	case "qadena.qadena.EncryptableSSIDAndPrivK.PubK":
		x.PubK = ""
	case "qadena.qadena.EncryptableSSIDAndPrivK.PrivK":
		x.PrivK = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSSIDAndPrivK"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSSIDAndPrivK does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EncryptableSSIDAndPrivK) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "qadena.qadena.EncryptableSSIDAndPrivK.PubKID":
		value := x.PubKID
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableSSIDAndPrivK.PubK":
		value := x.PubK
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableSSIDAndPrivK.PrivK":
		value := x.PrivK
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSSIDAndPrivK"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSSIDAndPrivK does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableSSIDAndPrivK) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSSIDAndPrivK.PubKID":
		x.PubKID = value.Interface().(string)
	case "qadena.qadena.EncryptableSSIDAndPrivK.PubK":
		x.PubK = value.Interface().(string)
	case "qadena.qadena.EncryptableSSIDAndPrivK.PrivK":
		x.PrivK = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSSIDAndPrivK"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSSIDAndPrivK does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableSSIDAndPrivK) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSSIDAndPrivK.PubKID":
		panic(fmt.Errorf("field PubKID of message qadena.qadena.EncryptableSSIDAndPrivK is not mutable"))
	case "qadena.qadena.EncryptableSSIDAndPrivK.PubK":
		panic(fmt.Errorf("field PubK of message qadena.qadena.EncryptableSSIDAndPrivK is not mutable"))
	case "qadena.qadena.EncryptableSSIDAndPrivK.PrivK":
		panic(fmt.Errorf("field PrivK of message qadena.qadena.EncryptableSSIDAndPrivK is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSSIDAndPrivK"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSSIDAndPrivK does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EncryptableSSIDAndPrivK) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSSIDAndPrivK.PubKID":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableSSIDAndPrivK.PubK":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableSSIDAndPrivK.PrivK":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSSIDAndPrivK"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSSIDAndPrivK does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EncryptableSSIDAndPrivK) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in qadena.qadena.EncryptableSSIDAndPrivK", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EncryptableSSIDAndPrivK) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableSSIDAndPrivK) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EncryptableSSIDAndPrivK) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EncryptableSSIDAndPrivK) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EncryptableSSIDAndPrivK)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.PubKID)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PubK)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.PrivK)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableSSIDAndPrivK)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.PrivK) > 0 {
			i -= len(x.PrivK)
			copy(dAtA[i:], x.PrivK)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PrivK)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.PubK) > 0 {
			i -= len(x.PubK)
			copy(dAtA[i:], x.PubK)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PubK)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.PubKID) > 0 {
			i -= len(x.PubKID)
			copy(dAtA[i:], x.PubKID)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PubKID)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableSSIDAndPrivK)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableSSIDAndPrivK: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableSSIDAndPrivK: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PubKID", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PubKID = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PubK", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PubK = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PrivK", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PrivK = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.List = (*_EncryptablePioneerIDs_1_list)(nil)

type _EncryptablePioneerIDs_1_list struct {
	list *[]string
}

func (x *_EncryptablePioneerIDs_1_list) Len() int {
	if x.list == nil {
		return 0
	}
	return len(*x.list)
}

func (x *_EncryptablePioneerIDs_1_list) Get(i int) protoreflect.Value {
	return protoreflect.ValueOfString((*x.list)[i])
}

func (x *_EncryptablePioneerIDs_1_list) Set(i int, value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.list)[i] = concreteValue
}

func (x *_EncryptablePioneerIDs_1_list) Append(value protoreflect.Value) {
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	*x.list = append(*x.list, concreteValue)
}

func (x *_EncryptablePioneerIDs_1_list) AppendMutable() protoreflect.Value {
	panic(fmt.Errorf("AppendMutable can not be called on message EncryptablePioneerIDs at list field PioneerIDs as it is not of Message kind"))
}

func (x *_EncryptablePioneerIDs_1_list) Truncate(n int) {
	*x.list = (*x.list)[:n]
}

func (x *_EncryptablePioneerIDs_1_list) NewElement() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_EncryptablePioneerIDs_1_list) IsValid() bool {
	return x.list != nil
}

var (
	md_EncryptablePioneerIDs            protoreflect.MessageDescriptor
	fd_EncryptablePioneerIDs_PioneerIDs protoreflect.FieldDescriptor
)

func init() {
	file_qadena_qadena_encryptable_proto_init()
	md_EncryptablePioneerIDs = File_qadena_qadena_encryptable_proto.Messages().ByName("EncryptablePioneerIDs")
	fd_EncryptablePioneerIDs_PioneerIDs = md_EncryptablePioneerIDs.Fields().ByName("PioneerIDs")
}

var _ protoreflect.Message = (*fastReflection_EncryptablePioneerIDs)(nil)

type fastReflection_EncryptablePioneerIDs EncryptablePioneerIDs

func (x *EncryptablePioneerIDs) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EncryptablePioneerIDs)(x)
}

func (x *EncryptablePioneerIDs) slowProtoReflect() protoreflect.Message {
	mi := &file_qadena_qadena_encryptable_proto_msgTypes[24]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EncryptablePioneerIDs_messageType fastReflection_EncryptablePioneerIDs_messageType
var _ protoreflect.MessageType = fastReflection_EncryptablePioneerIDs_messageType{}

type fastReflection_EncryptablePioneerIDs_messageType struct{}

func (x fastReflection_EncryptablePioneerIDs_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EncryptablePioneerIDs)(nil)
}
func (x fastReflection_EncryptablePioneerIDs_messageType) New() protoreflect.Message {
	return new(fastReflection_EncryptablePioneerIDs)
}
func (x fastReflection_EncryptablePioneerIDs_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptablePioneerIDs
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EncryptablePioneerIDs) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptablePioneerIDs
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EncryptablePioneerIDs) Type() protoreflect.MessageType {
	return _fastReflection_EncryptablePioneerIDs_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EncryptablePioneerIDs) New() protoreflect.Message {
	return new(fastReflection_EncryptablePioneerIDs)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EncryptablePioneerIDs) Interface() protoreflect.ProtoMessage {
	return (*EncryptablePioneerIDs)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EncryptablePioneerIDs) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.PioneerIDs) != 0 {
		value := protoreflect.ValueOfList(&_EncryptablePioneerIDs_1_list{list: &x.PioneerIDs})
		if !f(fd_EncryptablePioneerIDs_PioneerIDs, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EncryptablePioneerIDs) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "qadena.qadena.EncryptablePioneerIDs.PioneerIDs":
		return len(x.PioneerIDs) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptablePioneerIDs"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptablePioneerIDs does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptablePioneerIDs) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptablePioneerIDs.PioneerIDs":
		x.PioneerIDs = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptablePioneerIDs"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptablePioneerIDs does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EncryptablePioneerIDs) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "qadena.qadena.EncryptablePioneerIDs.PioneerIDs":
		if len(x.PioneerIDs) == 0 {
			return protoreflect.ValueOfList(&_EncryptablePioneerIDs_1_list{})
		}
		listValue := &_EncryptablePioneerIDs_1_list{list: &x.PioneerIDs}
		return protoreflect.ValueOfList(listValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptablePioneerIDs"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptablePioneerIDs does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptablePioneerIDs) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptablePioneerIDs.PioneerIDs":
		lv := value.List()
		clv := lv.(*_EncryptablePioneerIDs_1_list)
		x.PioneerIDs = *clv.list
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptablePioneerIDs"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptablePioneerIDs does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptablePioneerIDs) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptablePioneerIDs.PioneerIDs":
		if x.PioneerIDs == nil {
			x.PioneerIDs = []string{}
		}
		value := &_EncryptablePioneerIDs_1_list{list: &x.PioneerIDs}
		return protoreflect.ValueOfList(value)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptablePioneerIDs"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptablePioneerIDs does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EncryptablePioneerIDs) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptablePioneerIDs.PioneerIDs":
		list := []string{}
		return protoreflect.ValueOfList(&_EncryptablePioneerIDs_1_list{list: &list})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptablePioneerIDs"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptablePioneerIDs does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EncryptablePioneerIDs) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in qadena.qadena.EncryptablePioneerIDs", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EncryptablePioneerIDs) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptablePioneerIDs) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EncryptablePioneerIDs) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EncryptablePioneerIDs) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EncryptablePioneerIDs)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.PioneerIDs) > 0 {
			for _, s := range x.PioneerIDs {
				l = len(s)
				n += 1 + l + runtime.Sov(uint64(l))
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EncryptablePioneerIDs)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.PioneerIDs) > 0 {
			for iNdEx := len(x.PioneerIDs) - 1; iNdEx >= 0; iNdEx-- {
				i -= len(x.PioneerIDs[iNdEx])
				copy(dAtA[i:], x.PioneerIDs[iNdEx])
				i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PioneerIDs[iNdEx])))
				i--
				dAtA[i] = 0xa
			}
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EncryptablePioneerIDs)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptablePioneerIDs: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptablePioneerIDs: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PioneerIDs", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PioneerIDs = append(x.PioneerIDs, string(dAtA[iNdEx:postIndex]))
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.Map = (*_EncryptableEnclaveSSOwnerMap_1_map)(nil)

type _EncryptableEnclaveSSOwnerMap_1_map struct {
	m *map[string]*EncryptablePioneerIDs
}

func (x *_EncryptableEnclaveSSOwnerMap_1_map) Len() int {
	if x.m == nil {
		return 0
	}
	return len(*x.m)
}

func (x *_EncryptableEnclaveSSOwnerMap_1_map) Range(f func(protoreflect.MapKey, protoreflect.Value) bool) {
	if x.m == nil {
		return
	}
	for k, v := range *x.m {
		mapKey := (protoreflect.MapKey)(protoreflect.ValueOfString(k))
		mapValue := protoreflect.ValueOfMessage(v.ProtoReflect())
		if !f(mapKey, mapValue) {
			break
		}
	}
}

func (x *_EncryptableEnclaveSSOwnerMap_1_map) Has(key protoreflect.MapKey) bool {
	if x.m == nil {
		return false
	}
	keyUnwrapped := key.String()
	concreteValue := keyUnwrapped
	_, ok := (*x.m)[concreteValue]
	return ok
}

func (x *_EncryptableEnclaveSSOwnerMap_1_map) Clear(key protoreflect.MapKey) {
	if x.m == nil {
		return
	}
	keyUnwrapped := key.String()
	concreteKey := keyUnwrapped
	delete(*x.m, concreteKey)
}

func (x *_EncryptableEnclaveSSOwnerMap_1_map) Get(key protoreflect.MapKey) protoreflect.Value {
	if x.m == nil {
		return protoreflect.Value{}
	}
	keyUnwrapped := key.String()
	concreteKey := keyUnwrapped
	v, ok := (*x.m)[concreteKey]
	if !ok {
		return protoreflect.Value{}
	}
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_EncryptableEnclaveSSOwnerMap_1_map) Set(key protoreflect.MapKey, value protoreflect.Value) {
	if !key.IsValid() || !value.IsValid() {
		panic("invalid key or value provided")
	}
	keyUnwrapped := key.String()
	concreteKey := keyUnwrapped
	valueUnwrapped := value.Message()
	concreteValue := valueUnwrapped.Interface().(*EncryptablePioneerIDs)
	(*x.m)[concreteKey] = concreteValue
}

func (x *_EncryptableEnclaveSSOwnerMap_1_map) Mutable(key protoreflect.MapKey) protoreflect.Value {
	keyUnwrapped := key.String()
	concreteKey := keyUnwrapped
	v, ok := (*x.m)[concreteKey]
	if ok {
		return protoreflect.ValueOfMessage(v.ProtoReflect())
	}
	newValue := new(EncryptablePioneerIDs)
	(*x.m)[concreteKey] = newValue
	return protoreflect.ValueOfMessage(newValue.ProtoReflect())
}

func (x *_EncryptableEnclaveSSOwnerMap_1_map) NewValue() protoreflect.Value {
	v := new(EncryptablePioneerIDs)
	return protoreflect.ValueOfMessage(v.ProtoReflect())
}

func (x *_EncryptableEnclaveSSOwnerMap_1_map) IsValid() bool {
	return x.m != nil
}

var (
	md_EncryptableEnclaveSSOwnerMap          protoreflect.MessageDescriptor
	fd_EncryptableEnclaveSSOwnerMap_Pioneers protoreflect.FieldDescriptor
)

func init() {
	file_qadena_qadena_encryptable_proto_init()
	md_EncryptableEnclaveSSOwnerMap = File_qadena_qadena_encryptable_proto.Messages().ByName("EncryptableEnclaveSSOwnerMap")
	fd_EncryptableEnclaveSSOwnerMap_Pioneers = md_EncryptableEnclaveSSOwnerMap.Fields().ByName("Pioneers")
}

var _ protoreflect.Message = (*fastReflection_EncryptableEnclaveSSOwnerMap)(nil)

type fastReflection_EncryptableEnclaveSSOwnerMap EncryptableEnclaveSSOwnerMap

func (x *EncryptableEnclaveSSOwnerMap) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EncryptableEnclaveSSOwnerMap)(x)
}

func (x *EncryptableEnclaveSSOwnerMap) slowProtoReflect() protoreflect.Message {
	mi := &file_qadena_qadena_encryptable_proto_msgTypes[25]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EncryptableEnclaveSSOwnerMap_messageType fastReflection_EncryptableEnclaveSSOwnerMap_messageType
var _ protoreflect.MessageType = fastReflection_EncryptableEnclaveSSOwnerMap_messageType{}

type fastReflection_EncryptableEnclaveSSOwnerMap_messageType struct{}

func (x fastReflection_EncryptableEnclaveSSOwnerMap_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EncryptableEnclaveSSOwnerMap)(nil)
}
func (x fastReflection_EncryptableEnclaveSSOwnerMap_messageType) New() protoreflect.Message {
	return new(fastReflection_EncryptableEnclaveSSOwnerMap)
}
func (x fastReflection_EncryptableEnclaveSSOwnerMap_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableEnclaveSSOwnerMap
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EncryptableEnclaveSSOwnerMap) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableEnclaveSSOwnerMap
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EncryptableEnclaveSSOwnerMap) Type() protoreflect.MessageType {
	return _fastReflection_EncryptableEnclaveSSOwnerMap_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EncryptableEnclaveSSOwnerMap) New() protoreflect.Message {
	return new(fastReflection_EncryptableEnclaveSSOwnerMap)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EncryptableEnclaveSSOwnerMap) Interface() protoreflect.ProtoMessage {
	return (*EncryptableEnclaveSSOwnerMap)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EncryptableEnclaveSSOwnerMap) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.Pioneers) != 0 {
		value := protoreflect.ValueOfMap(&_EncryptableEnclaveSSOwnerMap_1_map{m: &x.Pioneers})
		if !f(fd_EncryptableEnclaveSSOwnerMap_Pioneers, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EncryptableEnclaveSSOwnerMap) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableEnclaveSSOwnerMap.Pioneers":
		return len(x.Pioneers) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableEnclaveSSOwnerMap"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableEnclaveSSOwnerMap does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableEnclaveSSOwnerMap) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableEnclaveSSOwnerMap.Pioneers":
		x.Pioneers = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableEnclaveSSOwnerMap"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableEnclaveSSOwnerMap does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EncryptableEnclaveSSOwnerMap) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "qadena.qadena.EncryptableEnclaveSSOwnerMap.Pioneers":
		if len(x.Pioneers) == 0 {
			return protoreflect.ValueOfMap(&_EncryptableEnclaveSSOwnerMap_1_map{})
		}
		mapValue := &_EncryptableEnclaveSSOwnerMap_1_map{m: &x.Pioneers}
		return protoreflect.ValueOfMap(mapValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableEnclaveSSOwnerMap"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableEnclaveSSOwnerMap does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableEnclaveSSOwnerMap) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableEnclaveSSOwnerMap.Pioneers":
		mv := value.Map()
		cmv := mv.(*_EncryptableEnclaveSSOwnerMap_1_map)
		x.Pioneers = *cmv.m
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableEnclaveSSOwnerMap"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableEnclaveSSOwnerMap does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableEnclaveSSOwnerMap) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableEnclaveSSOwnerMap.Pioneers":
		if x.Pioneers == nil {
			x.Pioneers = make(map[string]*EncryptablePioneerIDs)
		}
		value := &_EncryptableEnclaveSSOwnerMap_1_map{m: &x.Pioneers}
		return protoreflect.ValueOfMap(value)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableEnclaveSSOwnerMap"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableEnclaveSSOwnerMap does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EncryptableEnclaveSSOwnerMap) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableEnclaveSSOwnerMap.Pioneers":
		m := make(map[string]*EncryptablePioneerIDs)
		return protoreflect.ValueOfMap(&_EncryptableEnclaveSSOwnerMap_1_map{m: &m})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableEnclaveSSOwnerMap"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableEnclaveSSOwnerMap does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EncryptableEnclaveSSOwnerMap) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in qadena.qadena.EncryptableEnclaveSSOwnerMap", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EncryptableEnclaveSSOwnerMap) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableEnclaveSSOwnerMap) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EncryptableEnclaveSSOwnerMap) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EncryptableEnclaveSSOwnerMap) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EncryptableEnclaveSSOwnerMap)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.Pioneers) > 0 {
			SiZeMaP := func(k string, v *EncryptablePioneerIDs) {
				l := 0
				if v != nil {
					l = options.Size(v)
				}
				l += 1 + runtime.Sov(uint64(l))
				mapEntrySize := 1 + len(k) + runtime.Sov(uint64(len(k))) + l
				n += mapEntrySize + 1 + runtime.Sov(uint64(mapEntrySize))
			}
			if options.Deterministic {
				sortme := make([]string, 0, len(x.Pioneers))
				for k := range x.Pioneers {
					sortme = append(sortme, k)
				}
				sort.Strings(sortme)
				for _, k := range sortme {
					v := x.Pioneers[k]
					SiZeMaP(k, v)
				}
			} else {
				for k, v := range x.Pioneers {
					SiZeMaP(k, v)
				}
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableEnclaveSSOwnerMap)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Pioneers) > 0 {
			MaRsHaLmAp := func(k string, v *EncryptablePioneerIDs) (protoiface.MarshalOutput, error) {
				baseI := i
				encoded, err := options.Marshal(v)
				if err != nil {
					return protoiface.MarshalOutput{
						NoUnkeyedLiterals: input.NoUnkeyedLiterals,
						Buf:               input.Buf,
					}, err
				}
				i -= len(encoded)
				copy(dAtA[i:], encoded)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
				i--
				dAtA[i] = 0x12
				i -= len(k)
				copy(dAtA[i:], k)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(k)))
				i--
				dAtA[i] = 0xa
				i = runtime.EncodeVarint(dAtA, i, uint64(baseI-i))
				i--
				dAtA[i] = 0xa
				return protoiface.MarshalOutput{}, nil
			}
			if options.Deterministic {
				keysForPioneers := make([]string, 0, len(x.Pioneers))
				for k := range x.Pioneers {
					keysForPioneers = append(keysForPioneers, string(k))
				}
				sort.Slice(keysForPioneers, func(i, j int) bool {
					return keysForPioneers[i] < keysForPioneers[j]
				})
				for iNdEx := len(keysForPioneers) - 1; iNdEx >= 0; iNdEx-- {
					v := x.Pioneers[string(keysForPioneers[iNdEx])]
					out, err := MaRsHaLmAp(keysForPioneers[iNdEx], v)
					if err != nil {
						return out, err
					}
				}
			} else {
				for k := range x.Pioneers {
					v := x.Pioneers[k]
					out, err := MaRsHaLmAp(k, v)
					if err != nil {
						return out, err
					}
				}
			}
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableEnclaveSSOwnerMap)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableEnclaveSSOwnerMap: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableEnclaveSSOwnerMap: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Pioneers", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.Pioneers == nil {
					x.Pioneers = make(map[string]*EncryptablePioneerIDs)
				}
				var mapkey string
				var mapvalue *EncryptablePioneerIDs
				for iNdEx < postIndex {
					entryPreIndex := iNdEx
					var wire uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
						}
						if iNdEx >= l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						wire |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					fieldNum := int32(wire >> 3)
					if fieldNum == 1 {
						var stringLenmapkey uint64
						for shift := uint(0); ; shift += 7 {
							if shift >= 64 {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
							}
							if iNdEx >= l {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
							}
							b := dAtA[iNdEx]
							iNdEx++
							stringLenmapkey |= uint64(b&0x7F) << shift
							if b < 0x80 {
								break
							}
						}
						intStringLenmapkey := int(stringLenmapkey)
						if intStringLenmapkey < 0 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
						}
						postStringIndexmapkey := iNdEx + intStringLenmapkey
						if postStringIndexmapkey < 0 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
						}
						if postStringIndexmapkey > l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
						iNdEx = postStringIndexmapkey
					} else if fieldNum == 2 {
						var mapmsglen int
						for shift := uint(0); ; shift += 7 {
							if shift >= 64 {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
							}
							if iNdEx >= l {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
							}
							b := dAtA[iNdEx]
							iNdEx++
							mapmsglen |= int(b&0x7F) << shift
							if b < 0x80 {
								break
							}
						}
						if mapmsglen < 0 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
						}
						postmsgIndex := iNdEx + mapmsglen
						if postmsgIndex < 0 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
						}
						if postmsgIndex > l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						mapvalue = &EncryptablePioneerIDs{}
						if err := options.Unmarshal(dAtA[iNdEx:postmsgIndex], mapvalue); err != nil {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
						}
						iNdEx = postmsgIndex
					} else {
						iNdEx = entryPreIndex
						skippy, err := runtime.Skip(dAtA[iNdEx:])
						if err != nil {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
						}
						if (skippy < 0) || (iNdEx+skippy) < 0 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
						}
						if (iNdEx + skippy) > postIndex {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						iNdEx += skippy
					}
				}
				x.Pioneers[mapkey] = mapvalue
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var _ protoreflect.Map = (*_EncryptableEnclavePubKCacheMap_1_map)(nil)

type _EncryptableEnclavePubKCacheMap_1_map struct {
	m *map[string]string
}

func (x *_EncryptableEnclavePubKCacheMap_1_map) Len() int {
	if x.m == nil {
		return 0
	}
	return len(*x.m)
}

func (x *_EncryptableEnclavePubKCacheMap_1_map) Range(f func(protoreflect.MapKey, protoreflect.Value) bool) {
	if x.m == nil {
		return
	}
	for k, v := range *x.m {
		mapKey := (protoreflect.MapKey)(protoreflect.ValueOfString(k))
		mapValue := protoreflect.ValueOfString(v)
		if !f(mapKey, mapValue) {
			break
		}
	}
}

func (x *_EncryptableEnclavePubKCacheMap_1_map) Has(key protoreflect.MapKey) bool {
	if x.m == nil {
		return false
	}
	keyUnwrapped := key.String()
	concreteValue := keyUnwrapped
	_, ok := (*x.m)[concreteValue]
	return ok
}

func (x *_EncryptableEnclavePubKCacheMap_1_map) Clear(key protoreflect.MapKey) {
	if x.m == nil {
		return
	}
	keyUnwrapped := key.String()
	concreteKey := keyUnwrapped
	delete(*x.m, concreteKey)
}

func (x *_EncryptableEnclavePubKCacheMap_1_map) Get(key protoreflect.MapKey) protoreflect.Value {
	if x.m == nil {
		return protoreflect.Value{}
	}
	keyUnwrapped := key.String()
	concreteKey := keyUnwrapped
	v, ok := (*x.m)[concreteKey]
	if !ok {
		return protoreflect.Value{}
	}
	return protoreflect.ValueOfString(v)
}

func (x *_EncryptableEnclavePubKCacheMap_1_map) Set(key protoreflect.MapKey, value protoreflect.Value) {
	if !key.IsValid() || !value.IsValid() {
		panic("invalid key or value provided")
	}
	keyUnwrapped := key.String()
	concreteKey := keyUnwrapped
	valueUnwrapped := value.String()
	concreteValue := valueUnwrapped
	(*x.m)[concreteKey] = concreteValue
}

func (x *_EncryptableEnclavePubKCacheMap_1_map) Mutable(key protoreflect.MapKey) protoreflect.Value {
	panic("should not call Mutable on protoreflect.Map whose value is not of type protoreflect.Message")
}

func (x *_EncryptableEnclavePubKCacheMap_1_map) NewValue() protoreflect.Value {
	v := ""
	return protoreflect.ValueOfString(v)
}

func (x *_EncryptableEnclavePubKCacheMap_1_map) IsValid() bool {
	return x.m != nil
}

var (
	md_EncryptableEnclavePubKCacheMap       protoreflect.MessageDescriptor
	fd_EncryptableEnclavePubKCacheMap_PubKs protoreflect.FieldDescriptor
)

func init() {
	file_qadena_qadena_encryptable_proto_init()
	md_EncryptableEnclavePubKCacheMap = File_qadena_qadena_encryptable_proto.Messages().ByName("EncryptableEnclavePubKCacheMap")
	fd_EncryptableEnclavePubKCacheMap_PubKs = md_EncryptableEnclavePubKCacheMap.Fields().ByName("PubKs")
}

var _ protoreflect.Message = (*fastReflection_EncryptableEnclavePubKCacheMap)(nil)

type fastReflection_EncryptableEnclavePubKCacheMap EncryptableEnclavePubKCacheMap

func (x *EncryptableEnclavePubKCacheMap) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EncryptableEnclavePubKCacheMap)(x)
}

func (x *EncryptableEnclavePubKCacheMap) slowProtoReflect() protoreflect.Message {
	mi := &file_qadena_qadena_encryptable_proto_msgTypes[26]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EncryptableEnclavePubKCacheMap_messageType fastReflection_EncryptableEnclavePubKCacheMap_messageType
var _ protoreflect.MessageType = fastReflection_EncryptableEnclavePubKCacheMap_messageType{}

type fastReflection_EncryptableEnclavePubKCacheMap_messageType struct{}

func (x fastReflection_EncryptableEnclavePubKCacheMap_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EncryptableEnclavePubKCacheMap)(nil)
}
func (x fastReflection_EncryptableEnclavePubKCacheMap_messageType) New() protoreflect.Message {
	return new(fastReflection_EncryptableEnclavePubKCacheMap)
}
func (x fastReflection_EncryptableEnclavePubKCacheMap_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableEnclavePubKCacheMap
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EncryptableEnclavePubKCacheMap) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableEnclavePubKCacheMap
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EncryptableEnclavePubKCacheMap) Type() protoreflect.MessageType {
	return _fastReflection_EncryptableEnclavePubKCacheMap_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EncryptableEnclavePubKCacheMap) New() protoreflect.Message {
	return new(fastReflection_EncryptableEnclavePubKCacheMap)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EncryptableEnclavePubKCacheMap) Interface() protoreflect.ProtoMessage {
	return (*EncryptableEnclavePubKCacheMap)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EncryptableEnclavePubKCacheMap) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.PubKs) != 0 {
		value := protoreflect.ValueOfMap(&_EncryptableEnclavePubKCacheMap_1_map{m: &x.PubKs})
		if !f(fd_EncryptableEnclavePubKCacheMap_PubKs, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EncryptableEnclavePubKCacheMap) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableEnclavePubKCacheMap.PubKs":
		return len(x.PubKs) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableEnclavePubKCacheMap"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableEnclavePubKCacheMap does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableEnclavePubKCacheMap) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableEnclavePubKCacheMap.PubKs":
		x.PubKs = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableEnclavePubKCacheMap"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableEnclavePubKCacheMap does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EncryptableEnclavePubKCacheMap) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "qadena.qadena.EncryptableEnclavePubKCacheMap.PubKs":
		if len(x.PubKs) == 0 {
			return protoreflect.ValueOfMap(&_EncryptableEnclavePubKCacheMap_1_map{})
		}
		mapValue := &_EncryptableEnclavePubKCacheMap_1_map{m: &x.PubKs}
		return protoreflect.ValueOfMap(mapValue)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableEnclavePubKCacheMap"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableEnclavePubKCacheMap does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableEnclavePubKCacheMap) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableEnclavePubKCacheMap.PubKs":
		mv := value.Map()
		cmv := mv.(*_EncryptableEnclavePubKCacheMap_1_map)
		x.PubKs = *cmv.m
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableEnclavePubKCacheMap"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableEnclavePubKCacheMap does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableEnclavePubKCacheMap) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableEnclavePubKCacheMap.PubKs":
		if x.PubKs == nil {
			x.PubKs = make(map[string]string)
		}
		value := &_EncryptableEnclavePubKCacheMap_1_map{m: &x.PubKs}
		return protoreflect.ValueOfMap(value)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableEnclavePubKCacheMap"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableEnclavePubKCacheMap does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EncryptableEnclavePubKCacheMap) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableEnclavePubKCacheMap.PubKs":
		m := make(map[string]string)
		return protoreflect.ValueOfMap(&_EncryptableEnclavePubKCacheMap_1_map{m: &m})
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableEnclavePubKCacheMap"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableEnclavePubKCacheMap does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EncryptableEnclavePubKCacheMap) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in qadena.qadena.EncryptableEnclavePubKCacheMap", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EncryptableEnclavePubKCacheMap) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableEnclavePubKCacheMap) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EncryptableEnclavePubKCacheMap) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EncryptableEnclavePubKCacheMap) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EncryptableEnclavePubKCacheMap)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if len(x.PubKs) > 0 {
			SiZeMaP := func(k string, v string) {
				mapEntrySize := 1 + len(k) + runtime.Sov(uint64(len(k))) + 1 + len(v) + runtime.Sov(uint64(len(v)))
				n += mapEntrySize + 1 + runtime.Sov(uint64(mapEntrySize))
			}
			if options.Deterministic {
				sortme := make([]string, 0, len(x.PubKs))
				for k := range x.PubKs {
					sortme = append(sortme, k)
				}
				sort.Strings(sortme)
				for _, k := range sortme {
					v := x.PubKs[k]
					SiZeMaP(k, v)
				}
			} else {
				for k, v := range x.PubKs {
					SiZeMaP(k, v)
				}
			}
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableEnclavePubKCacheMap)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.PubKs) > 0 {
			MaRsHaLmAp := func(k string, v string) (protoiface.MarshalOutput, error) {
				baseI := i
				i -= len(v)
				copy(dAtA[i:], v)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
				i -= len(k)
				copy(dAtA[i:], k)
				i = runtime.EncodeVarint(dAtA, i, uint64(len(k)))
				i--
				dAtA[i] = 0xa
				i = runtime.EncodeVarint(dAtA, i, uint64(baseI-i))
				i--
				dAtA[i] = 0xa
				return protoiface.MarshalOutput{}, nil
			}
			if options.Deterministic {
				keysForPubKs := make([]string, 0, len(x.PubKs))
				for k := range x.PubKs {
					keysForPubKs = append(keysForPubKs, string(k))
				}
				sort.Slice(keysForPubKs, func(i, j int) bool {
					return keysForPubKs[i] < keysForPubKs[j]
				})
				for iNdEx := len(keysForPubKs) - 1; iNdEx >= 0; iNdEx-- {
					v := x.PubKs[string(keysForPubKs[iNdEx])]
					out, err := MaRsHaLmAp(keysForPubKs[iNdEx], v)
					if err != nil {
						return out, err
					}
				}
			} else {
				for k := range x.PubKs {
					v := x.PubKs[k]
					out, err := MaRsHaLmAp(k, v)
					if err != nil {
						return out, err
					}
				}
			}
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableEnclavePubKCacheMap)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableEnclavePubKCacheMap: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableEnclavePubKCacheMap: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PubKs", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.PubKs == nil {
					x.PubKs = make(map[string]string)
				}
				var mapkey string
				var mapvalue string
				for iNdEx < postIndex {
					entryPreIndex := iNdEx
					var wire uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
						}
						if iNdEx >= l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						wire |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					fieldNum := int32(wire >> 3)
					if fieldNum == 1 {
						var stringLenmapkey uint64
						for shift := uint(0); ; shift += 7 {
							if shift >= 64 {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
							}
							if iNdEx >= l {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
							}
							b := dAtA[iNdEx]
							iNdEx++
							stringLenmapkey |= uint64(b&0x7F) << shift
							if b < 0x80 {
								break
							}
						}
						intStringLenmapkey := int(stringLenmapkey)
						if intStringLenmapkey < 0 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
						}
						postStringIndexmapkey := iNdEx + intStringLenmapkey
						if postStringIndexmapkey < 0 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
						}
						if postStringIndexmapkey > l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
						iNdEx = postStringIndexmapkey
					} else if fieldNum == 2 {
						var stringLenmapvalue uint64
						for shift := uint(0); ; shift += 7 {
							if shift >= 64 {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
							}
							if iNdEx >= l {
								return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
							}
							b := dAtA[iNdEx]
							iNdEx++
							stringLenmapvalue |= uint64(b&0x7F) << shift
							if b < 0x80 {
								break
							}
						}
						intStringLenmapvalue := int(stringLenmapvalue)
						if intStringLenmapvalue < 0 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
						}
						postStringIndexmapvalue := iNdEx + intStringLenmapvalue
						if postStringIndexmapvalue < 0 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
						}
						if postStringIndexmapvalue > l {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
						iNdEx = postStringIndexmapvalue
					} else {
						iNdEx = entryPreIndex
						skippy, err := runtime.Skip(dAtA[iNdEx:])
						if err != nil {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
						}
						if (skippy < 0) || (iNdEx+skippy) < 0 {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
						}
						if (iNdEx + skippy) > postIndex {
							return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
						}
						iNdEx += skippy
					}
				}
				x.PubKs[mapkey] = mapvalue
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_EncryptableSharedEnclaveParams                     protoreflect.MessageDescriptor
	fd_EncryptableSharedEnclaveParams_JarID               protoreflect.FieldDescriptor
	fd_EncryptableSharedEnclaveParams_JarArmorPrivK       protoreflect.FieldDescriptor
	fd_EncryptableSharedEnclaveParams_JarPrivK            protoreflect.FieldDescriptor
	fd_EncryptableSharedEnclaveParams_JarPubK             protoreflect.FieldDescriptor
	fd_EncryptableSharedEnclaveParams_RegulatorID         protoreflect.FieldDescriptor
	fd_EncryptableSharedEnclaveParams_RegulatorArmorPrivK protoreflect.FieldDescriptor
	fd_EncryptableSharedEnclaveParams_RegulatorPrivK      protoreflect.FieldDescriptor
	fd_EncryptableSharedEnclaveParams_RegulatorPubK       protoreflect.FieldDescriptor
	fd_EncryptableSharedEnclaveParams_SSIntervalOwners    protoreflect.FieldDescriptor
	fd_EncryptableSharedEnclaveParams_SSIntervalPubKCache protoreflect.FieldDescriptor
)

func init() {
	file_qadena_qadena_encryptable_proto_init()
	md_EncryptableSharedEnclaveParams = File_qadena_qadena_encryptable_proto.Messages().ByName("EncryptableSharedEnclaveParams")
	fd_EncryptableSharedEnclaveParams_JarID = md_EncryptableSharedEnclaveParams.Fields().ByName("JarID")
	fd_EncryptableSharedEnclaveParams_JarArmorPrivK = md_EncryptableSharedEnclaveParams.Fields().ByName("JarArmorPrivK")
	fd_EncryptableSharedEnclaveParams_JarPrivK = md_EncryptableSharedEnclaveParams.Fields().ByName("JarPrivK")
	fd_EncryptableSharedEnclaveParams_JarPubK = md_EncryptableSharedEnclaveParams.Fields().ByName("JarPubK")
	fd_EncryptableSharedEnclaveParams_RegulatorID = md_EncryptableSharedEnclaveParams.Fields().ByName("RegulatorID")
	fd_EncryptableSharedEnclaveParams_RegulatorArmorPrivK = md_EncryptableSharedEnclaveParams.Fields().ByName("RegulatorArmorPrivK")
	fd_EncryptableSharedEnclaveParams_RegulatorPrivK = md_EncryptableSharedEnclaveParams.Fields().ByName("RegulatorPrivK")
	fd_EncryptableSharedEnclaveParams_RegulatorPubK = md_EncryptableSharedEnclaveParams.Fields().ByName("RegulatorPubK")
	fd_EncryptableSharedEnclaveParams_SSIntervalOwners = md_EncryptableSharedEnclaveParams.Fields().ByName("SSIntervalOwners")
	fd_EncryptableSharedEnclaveParams_SSIntervalPubKCache = md_EncryptableSharedEnclaveParams.Fields().ByName("SSIntervalPubKCache")
}

var _ protoreflect.Message = (*fastReflection_EncryptableSharedEnclaveParams)(nil)

type fastReflection_EncryptableSharedEnclaveParams EncryptableSharedEnclaveParams

func (x *EncryptableSharedEnclaveParams) ProtoReflect() protoreflect.Message {
	return (*fastReflection_EncryptableSharedEnclaveParams)(x)
}

func (x *EncryptableSharedEnclaveParams) slowProtoReflect() protoreflect.Message {
	mi := &file_qadena_qadena_encryptable_proto_msgTypes[27]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_EncryptableSharedEnclaveParams_messageType fastReflection_EncryptableSharedEnclaveParams_messageType
var _ protoreflect.MessageType = fastReflection_EncryptableSharedEnclaveParams_messageType{}

type fastReflection_EncryptableSharedEnclaveParams_messageType struct{}

func (x fastReflection_EncryptableSharedEnclaveParams_messageType) Zero() protoreflect.Message {
	return (*fastReflection_EncryptableSharedEnclaveParams)(nil)
}
func (x fastReflection_EncryptableSharedEnclaveParams_messageType) New() protoreflect.Message {
	return new(fastReflection_EncryptableSharedEnclaveParams)
}
func (x fastReflection_EncryptableSharedEnclaveParams_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableSharedEnclaveParams
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_EncryptableSharedEnclaveParams) Descriptor() protoreflect.MessageDescriptor {
	return md_EncryptableSharedEnclaveParams
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_EncryptableSharedEnclaveParams) Type() protoreflect.MessageType {
	return _fastReflection_EncryptableSharedEnclaveParams_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_EncryptableSharedEnclaveParams) New() protoreflect.Message {
	return new(fastReflection_EncryptableSharedEnclaveParams)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_EncryptableSharedEnclaveParams) Interface() protoreflect.ProtoMessage {
	return (*EncryptableSharedEnclaveParams)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_EncryptableSharedEnclaveParams) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.JarID != "" {
		value := protoreflect.ValueOfString(x.JarID)
		if !f(fd_EncryptableSharedEnclaveParams_JarID, value) {
			return
		}
	}
	if x.JarArmorPrivK != "" {
		value := protoreflect.ValueOfString(x.JarArmorPrivK)
		if !f(fd_EncryptableSharedEnclaveParams_JarArmorPrivK, value) {
			return
		}
	}
	if x.JarPrivK != "" {
		value := protoreflect.ValueOfString(x.JarPrivK)
		if !f(fd_EncryptableSharedEnclaveParams_JarPrivK, value) {
			return
		}
	}
	if x.JarPubK != "" {
		value := protoreflect.ValueOfString(x.JarPubK)
		if !f(fd_EncryptableSharedEnclaveParams_JarPubK, value) {
			return
		}
	}
	if x.RegulatorID != "" {
		value := protoreflect.ValueOfString(x.RegulatorID)
		if !f(fd_EncryptableSharedEnclaveParams_RegulatorID, value) {
			return
		}
	}
	if x.RegulatorArmorPrivK != "" {
		value := protoreflect.ValueOfString(x.RegulatorArmorPrivK)
		if !f(fd_EncryptableSharedEnclaveParams_RegulatorArmorPrivK, value) {
			return
		}
	}
	if x.RegulatorPrivK != "" {
		value := protoreflect.ValueOfString(x.RegulatorPrivK)
		if !f(fd_EncryptableSharedEnclaveParams_RegulatorPrivK, value) {
			return
		}
	}
	if x.RegulatorPubK != "" {
		value := protoreflect.ValueOfString(x.RegulatorPubK)
		if !f(fd_EncryptableSharedEnclaveParams_RegulatorPubK, value) {
			return
		}
	}
	if x.SSIntervalOwners != nil {
		value := protoreflect.ValueOfMessage(x.SSIntervalOwners.ProtoReflect())
		if !f(fd_EncryptableSharedEnclaveParams_SSIntervalOwners, value) {
			return
		}
	}
	if x.SSIntervalPubKCache != nil {
		value := protoreflect.ValueOfMessage(x.SSIntervalPubKCache.ProtoReflect())
		if !f(fd_EncryptableSharedEnclaveParams_SSIntervalPubKCache, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_EncryptableSharedEnclaveParams) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSharedEnclaveParams.JarID":
		return x.JarID != ""
	case "qadena.qadena.EncryptableSharedEnclaveParams.JarArmorPrivK":
		return x.JarArmorPrivK != ""
	case "qadena.qadena.EncryptableSharedEnclaveParams.JarPrivK":
		return x.JarPrivK != ""
	case "qadena.qadena.EncryptableSharedEnclaveParams.JarPubK":
		return x.JarPubK != ""
	case "qadena.qadena.EncryptableSharedEnclaveParams.RegulatorID":
		return x.RegulatorID != ""
	case "qadena.qadena.EncryptableSharedEnclaveParams.RegulatorArmorPrivK":
		return x.RegulatorArmorPrivK != ""
	case "qadena.qadena.EncryptableSharedEnclaveParams.RegulatorPrivK":
		return x.RegulatorPrivK != ""
	case "qadena.qadena.EncryptableSharedEnclaveParams.RegulatorPubK":
		return x.RegulatorPubK != ""
	case "qadena.qadena.EncryptableSharedEnclaveParams.SSIntervalOwners":
		return x.SSIntervalOwners != nil
	case "qadena.qadena.EncryptableSharedEnclaveParams.SSIntervalPubKCache":
		return x.SSIntervalPubKCache != nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSharedEnclaveParams"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSharedEnclaveParams does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableSharedEnclaveParams) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSharedEnclaveParams.JarID":
		x.JarID = ""
	case "qadena.qadena.EncryptableSharedEnclaveParams.JarArmorPrivK":
		x.JarArmorPrivK = ""
	case "qadena.qadena.EncryptableSharedEnclaveParams.JarPrivK":
		x.JarPrivK = ""
	case "qadena.qadena.EncryptableSharedEnclaveParams.JarPubK":
		x.JarPubK = ""
	case "qadena.qadena.EncryptableSharedEnclaveParams.RegulatorID":
		x.RegulatorID = ""
	case "qadena.qadena.EncryptableSharedEnclaveParams.RegulatorArmorPrivK":
		x.RegulatorArmorPrivK = ""
	case "qadena.qadena.EncryptableSharedEnclaveParams.RegulatorPrivK":
		x.RegulatorPrivK = ""
	case "qadena.qadena.EncryptableSharedEnclaveParams.RegulatorPubK":
		x.RegulatorPubK = ""
	case "qadena.qadena.EncryptableSharedEnclaveParams.SSIntervalOwners":
		x.SSIntervalOwners = nil
	case "qadena.qadena.EncryptableSharedEnclaveParams.SSIntervalPubKCache":
		x.SSIntervalPubKCache = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSharedEnclaveParams"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSharedEnclaveParams does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_EncryptableSharedEnclaveParams) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "qadena.qadena.EncryptableSharedEnclaveParams.JarID":
		value := x.JarID
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableSharedEnclaveParams.JarArmorPrivK":
		value := x.JarArmorPrivK
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableSharedEnclaveParams.JarPrivK":
		value := x.JarPrivK
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableSharedEnclaveParams.JarPubK":
		value := x.JarPubK
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableSharedEnclaveParams.RegulatorID":
		value := x.RegulatorID
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableSharedEnclaveParams.RegulatorArmorPrivK":
		value := x.RegulatorArmorPrivK
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableSharedEnclaveParams.RegulatorPrivK":
		value := x.RegulatorPrivK
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableSharedEnclaveParams.RegulatorPubK":
		value := x.RegulatorPubK
		return protoreflect.ValueOfString(value)
	case "qadena.qadena.EncryptableSharedEnclaveParams.SSIntervalOwners":
		value := x.SSIntervalOwners
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	case "qadena.qadena.EncryptableSharedEnclaveParams.SSIntervalPubKCache":
		value := x.SSIntervalPubKCache
		return protoreflect.ValueOfMessage(value.ProtoReflect())
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSharedEnclaveParams"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSharedEnclaveParams does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableSharedEnclaveParams) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSharedEnclaveParams.JarID":
		x.JarID = value.Interface().(string)
	case "qadena.qadena.EncryptableSharedEnclaveParams.JarArmorPrivK":
		x.JarArmorPrivK = value.Interface().(string)
	case "qadena.qadena.EncryptableSharedEnclaveParams.JarPrivK":
		x.JarPrivK = value.Interface().(string)
	case "qadena.qadena.EncryptableSharedEnclaveParams.JarPubK":
		x.JarPubK = value.Interface().(string)
	case "qadena.qadena.EncryptableSharedEnclaveParams.RegulatorID":
		x.RegulatorID = value.Interface().(string)
	case "qadena.qadena.EncryptableSharedEnclaveParams.RegulatorArmorPrivK":
		x.RegulatorArmorPrivK = value.Interface().(string)
	case "qadena.qadena.EncryptableSharedEnclaveParams.RegulatorPrivK":
		x.RegulatorPrivK = value.Interface().(string)
	case "qadena.qadena.EncryptableSharedEnclaveParams.RegulatorPubK":
		x.RegulatorPubK = value.Interface().(string)
	case "qadena.qadena.EncryptableSharedEnclaveParams.SSIntervalOwners":
		x.SSIntervalOwners = value.Message().Interface().(*EncryptableEnclaveSSOwnerMap)
	case "qadena.qadena.EncryptableSharedEnclaveParams.SSIntervalPubKCache":
		x.SSIntervalPubKCache = value.Message().Interface().(*EncryptableEnclavePubKCacheMap)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSharedEnclaveParams"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSharedEnclaveParams does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableSharedEnclaveParams) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSharedEnclaveParams.SSIntervalOwners":
		if x.SSIntervalOwners == nil {
			x.SSIntervalOwners = new(EncryptableEnclaveSSOwnerMap)
		}
		return protoreflect.ValueOfMessage(x.SSIntervalOwners.ProtoReflect())
	case "qadena.qadena.EncryptableSharedEnclaveParams.SSIntervalPubKCache":
		if x.SSIntervalPubKCache == nil {
			x.SSIntervalPubKCache = new(EncryptableEnclavePubKCacheMap)
		}
		return protoreflect.ValueOfMessage(x.SSIntervalPubKCache.ProtoReflect())
	case "qadena.qadena.EncryptableSharedEnclaveParams.JarID":
		panic(fmt.Errorf("field JarID of message qadena.qadena.EncryptableSharedEnclaveParams is not mutable"))
	case "qadena.qadena.EncryptableSharedEnclaveParams.JarArmorPrivK":
		panic(fmt.Errorf("field JarArmorPrivK of message qadena.qadena.EncryptableSharedEnclaveParams is not mutable"))
	case "qadena.qadena.EncryptableSharedEnclaveParams.JarPrivK":
		panic(fmt.Errorf("field JarPrivK of message qadena.qadena.EncryptableSharedEnclaveParams is not mutable"))
	case "qadena.qadena.EncryptableSharedEnclaveParams.JarPubK":
		panic(fmt.Errorf("field JarPubK of message qadena.qadena.EncryptableSharedEnclaveParams is not mutable"))
	case "qadena.qadena.EncryptableSharedEnclaveParams.RegulatorID":
		panic(fmt.Errorf("field RegulatorID of message qadena.qadena.EncryptableSharedEnclaveParams is not mutable"))
	case "qadena.qadena.EncryptableSharedEnclaveParams.RegulatorArmorPrivK":
		panic(fmt.Errorf("field RegulatorArmorPrivK of message qadena.qadena.EncryptableSharedEnclaveParams is not mutable"))
	case "qadena.qadena.EncryptableSharedEnclaveParams.RegulatorPrivK":
		panic(fmt.Errorf("field RegulatorPrivK of message qadena.qadena.EncryptableSharedEnclaveParams is not mutable"))
	case "qadena.qadena.EncryptableSharedEnclaveParams.RegulatorPubK":
		panic(fmt.Errorf("field RegulatorPubK of message qadena.qadena.EncryptableSharedEnclaveParams is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSharedEnclaveParams"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSharedEnclaveParams does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_EncryptableSharedEnclaveParams) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "qadena.qadena.EncryptableSharedEnclaveParams.JarID":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableSharedEnclaveParams.JarArmorPrivK":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableSharedEnclaveParams.JarPrivK":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableSharedEnclaveParams.JarPubK":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableSharedEnclaveParams.RegulatorID":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableSharedEnclaveParams.RegulatorArmorPrivK":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableSharedEnclaveParams.RegulatorPrivK":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableSharedEnclaveParams.RegulatorPubK":
		return protoreflect.ValueOfString("")
	case "qadena.qadena.EncryptableSharedEnclaveParams.SSIntervalOwners":
		m := new(EncryptableEnclaveSSOwnerMap)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	case "qadena.qadena.EncryptableSharedEnclaveParams.SSIntervalPubKCache":
		m := new(EncryptableEnclavePubKCacheMap)
		return protoreflect.ValueOfMessage(m.ProtoReflect())
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: qadena.qadena.EncryptableSharedEnclaveParams"))
		}
		panic(fmt.Errorf("message qadena.qadena.EncryptableSharedEnclaveParams does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_EncryptableSharedEnclaveParams) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in qadena.qadena.EncryptableSharedEnclaveParams", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_EncryptableSharedEnclaveParams) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_EncryptableSharedEnclaveParams) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_EncryptableSharedEnclaveParams) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_EncryptableSharedEnclaveParams) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*EncryptableSharedEnclaveParams)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.JarID)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.JarArmorPrivK)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.JarPrivK)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.JarPubK)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.RegulatorID)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.RegulatorArmorPrivK)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.RegulatorPrivK)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.RegulatorPubK)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.SSIntervalOwners != nil {
			l = options.Size(x.SSIntervalOwners)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.SSIntervalPubKCache != nil {
			l = options.Size(x.SSIntervalPubKCache)
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableSharedEnclaveParams)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.SSIntervalPubKCache != nil {
			encoded, err := options.Marshal(x.SSIntervalPubKCache)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x52
		}
		if x.SSIntervalOwners != nil {
			encoded, err := options.Marshal(x.SSIntervalOwners)
			if err != nil {
				return protoiface.MarshalOutput{
					NoUnkeyedLiterals: input.NoUnkeyedLiterals,
					Buf:               input.Buf,
				}, err
			}
			i -= len(encoded)
			copy(dAtA[i:], encoded)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(encoded)))
			i--
			dAtA[i] = 0x4a
		}
		if len(x.RegulatorPubK) > 0 {
			i -= len(x.RegulatorPubK)
			copy(dAtA[i:], x.RegulatorPubK)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RegulatorPubK)))
			i--
			dAtA[i] = 0x42
		}
		if len(x.RegulatorPrivK) > 0 {
			i -= len(x.RegulatorPrivK)
			copy(dAtA[i:], x.RegulatorPrivK)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RegulatorPrivK)))
			i--
			dAtA[i] = 0x3a
		}
		if len(x.RegulatorArmorPrivK) > 0 {
			i -= len(x.RegulatorArmorPrivK)
			copy(dAtA[i:], x.RegulatorArmorPrivK)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RegulatorArmorPrivK)))
			i--
			dAtA[i] = 0x32
		}
		if len(x.RegulatorID) > 0 {
			i -= len(x.RegulatorID)
			copy(dAtA[i:], x.RegulatorID)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RegulatorID)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.JarPubK) > 0 {
			i -= len(x.JarPubK)
			copy(dAtA[i:], x.JarPubK)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.JarPubK)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.JarPrivK) > 0 {
			i -= len(x.JarPrivK)
			copy(dAtA[i:], x.JarPrivK)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.JarPrivK)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.JarArmorPrivK) > 0 {
			i -= len(x.JarArmorPrivK)
			copy(dAtA[i:], x.JarArmorPrivK)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.JarArmorPrivK)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.JarID) > 0 {
			i -= len(x.JarID)
			copy(dAtA[i:], x.JarID)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.JarID)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*EncryptableSharedEnclaveParams)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableSharedEnclaveParams: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: EncryptableSharedEnclaveParams: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field JarID", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.JarID = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field JarArmorPrivK", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.JarArmorPrivK = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field JarPrivK", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.JarPrivK = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field JarPubK", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.JarPubK = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RegulatorID", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RegulatorID = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 6:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RegulatorArmorPrivK", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RegulatorArmorPrivK = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RegulatorPrivK", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RegulatorPrivK = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 8:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RegulatorPubK", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RegulatorPubK = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 9:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SSIntervalOwners", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.SSIntervalOwners == nil {
					x.SSIntervalOwners = &EncryptableEnclaveSSOwnerMap{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.SSIntervalOwners); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			case 10:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SSIntervalPubKCache", wireType)
				}
				var msglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					msglen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if msglen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + msglen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if x.SSIntervalPubKCache == nil {
					x.SSIntervalPubKCache = &EncryptableEnclavePubKCacheMap{}
				}
				if err := options.Unmarshal(dAtA[iNdEx:postIndex], x.SSIntervalPubKCache); err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.27.0
// 	protoc        (unknown)
// source: qadena/qadena/encryptable.proto

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type EncryptableString struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Value string `protobuf:"bytes,1,opt,name=Value,proto3" json:"Value,omitempty"`
}

func (x *EncryptableString) Reset() {
	*x = EncryptableString{}
	if protoimpl.UnsafeEnabled {
		mi := &file_qadena_qadena_encryptable_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EncryptableString) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptableString) ProtoMessage() {}

// Deprecated: Use EncryptableString.ProtoReflect.Descriptor instead.
func (*EncryptableString) Descriptor() ([]byte, []int) {
	return file_qadena_qadena_encryptable_proto_rawDescGZIP(), []int{0}
}

func (x *EncryptableString) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

type EncryptableClaimCredentialExtraParms struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	EncCredentialInfoVShare  []byte                     `protobuf:"bytes,1,opt,name=EncCredentialInfoVShare,proto3" json:"EncCredentialInfoVShare,omitempty"`
	CredentialInfoVShareBind *VShareBindData            `protobuf:"bytes,2,opt,name=CredentialInfoVShareBind,proto3" json:"CredentialInfoVShareBind,omitempty"`
	WalletID                 string                     `protobuf:"bytes,3,opt,name=WalletID,proto3" json:"WalletID,omitempty"`
	FindCredentialPC         *BPedersenCommit           `protobuf:"bytes,4,opt,name=FindCredentialPC,proto3" json:"FindCredentialPC,omitempty"`
	NewCredentialPC          *BPedersenCommit           `protobuf:"bytes,5,opt,name=NewCredentialPC,proto3" json:"NewCredentialPC,omitempty"`
	EncWalletIDVShare        []byte                     `protobuf:"bytes,6,opt,name=EncWalletIDVShare,proto3" json:"EncWalletIDVShare,omitempty"`
	WalletIDVShareBind       *VShareBindData            `protobuf:"bytes,7,opt,name=WalletIDVShareBind,proto3" json:"WalletIDVShareBind,omitempty"`
	EncCredentialHashVShare  []byte                     `protobuf:"bytes,8,opt,name=EncCredentialHashVShare,proto3" json:"EncCredentialHashVShare,omitempty"`
	CredentialHashVShareBind *VShareBindData            `protobuf:"bytes,9,opt,name=CredentialHashVShareBind,proto3" json:"CredentialHashVShareBind,omitempty"`
	ZeroPC                   *EncryptablePedersenCommit `protobuf:"bytes,10,opt,name=ZeroPC,proto3" json:"ZeroPC,omitempty"`
	ClaimPC                  *BPedersenCommit           `protobuf:"bytes,11,opt,name=ClaimPC,proto3" json:"ClaimPC,omitempty"`
}

func (x *EncryptableClaimCredentialExtraParms) Reset() {
	*x = EncryptableClaimCredentialExtraParms{}
	if protoimpl.UnsafeEnabled {
		mi := &file_qadena_qadena_encryptable_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EncryptableClaimCredentialExtraParms) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptableClaimCredentialExtraParms) ProtoMessage() {}

// Deprecated: Use EncryptableClaimCredentialExtraParms.ProtoReflect.Descriptor instead.
func (*EncryptableClaimCredentialExtraParms) Descriptor() ([]byte, []int) {
	return file_qadena_qadena_encryptable_proto_rawDescGZIP(), []int{1}
}

func (x *EncryptableClaimCredentialExtraParms) GetEncCredentialInfoVShare() []byte {
	if x != nil {
		return x.EncCredentialInfoVShare
	}
	return nil
}

func (x *EncryptableClaimCredentialExtraParms) GetCredentialInfoVShareBind() *VShareBindData {
	if x != nil {
		return x.CredentialInfoVShareBind
	}
	return nil
}

func (x *EncryptableClaimCredentialExtraParms) GetWalletID() string {
	if x != nil {
		return x.WalletID
	}
	return ""
}

func (x *EncryptableClaimCredentialExtraParms) GetFindCredentialPC() *BPedersenCommit {
	if x != nil {
		return x.FindCredentialPC
	}
	return nil
}

func (x *EncryptableClaimCredentialExtraParms) GetNewCredentialPC() *BPedersenCommit {
	if x != nil {
		return x.NewCredentialPC
	}
	return nil
}

func (x *EncryptableClaimCredentialExtraParms) GetEncWalletIDVShare() []byte {
	if x != nil {
		return x.EncWalletIDVShare
	}
	return nil
}

func (x *EncryptableClaimCredentialExtraParms) GetWalletIDVShareBind() *VShareBindData {
	if x != nil {
		return x.WalletIDVShareBind
	}
	return nil
}

func (x *EncryptableClaimCredentialExtraParms) GetEncCredentialHashVShare() []byte {
	if x != nil {
		return x.EncCredentialHashVShare
	}
	return nil
}

func (x *EncryptableClaimCredentialExtraParms) GetCredentialHashVShareBind() *VShareBindData {
	if x != nil {
		return x.CredentialHashVShareBind
	}
	return nil
}

func (x *EncryptableClaimCredentialExtraParms) GetZeroPC() *EncryptablePedersenCommit {
	if x != nil {
		return x.ZeroPC
	}
	return nil
}

func (x *EncryptableClaimCredentialExtraParms) GetClaimPC() *BPedersenCommit {
	if x != nil {
		return x.ClaimPC
	}
	return nil
}

type EncryptableAuthorizedSignatory struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Nonce    string `protobuf:"bytes,1,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	WalletID string `protobuf:"bytes,2,opt,name=WalletID,proto3" json:"WalletID,omitempty"`
}

func (x *EncryptableAuthorizedSignatory) Reset() {
	*x = EncryptableAuthorizedSignatory{}
	if protoimpl.UnsafeEnabled {
		mi := &file_qadena_qadena_encryptable_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EncryptableAuthorizedSignatory) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptableAuthorizedSignatory) ProtoMessage() {}

// Deprecated: Use EncryptableAuthorizedSignatory.ProtoReflect.Descriptor instead.
func (*EncryptableAuthorizedSignatory) Descriptor() ([]byte, []int) {
	return file_qadena_qadena_encryptable_proto_rawDescGZIP(), []int{2}
}

func (x *EncryptableAuthorizedSignatory) GetNonce() string {
	if x != nil {
		return x.Nonce
	}
	return ""
}

func (x *EncryptableAuthorizedSignatory) GetWalletID() string {
	if x != nil {
		return x.WalletID
	}
	return ""
}

type EncryptableSignatory struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Nonce       string `protobuf:"bytes,1,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	Email       string `protobuf:"bytes,2,opt,name=Email,proto3" json:"Email,omitempty"`
	PhoneNumber string `protobuf:"bytes,3,opt,name=PhoneNumber,proto3" json:"PhoneNumber,omitempty"`
}

func (x *EncryptableSignatory) Reset() {
	*x = EncryptableSignatory{}
	if protoimpl.UnsafeEnabled {
		mi := &file_qadena_qadena_encryptable_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EncryptableSignatory) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptableSignatory) ProtoMessage() {}

// Deprecated: Use EncryptableSignatory.ProtoReflect.Descriptor instead.
func (*EncryptableSignatory) Descriptor() ([]byte, []int) {
	return file_qadena_qadena_encryptable_proto_rawDescGZIP(), []int{3}
}

func (x *EncryptableSignatory) GetNonce() string {
	if x != nil {
		return x.Nonce
	}
	return ""
}

func (x *EncryptableSignatory) GetEmail() string {
	if x != nil {
		return x.Email
	}
	return ""
}

func (x *EncryptableSignatory) GetPhoneNumber() string {
	if x != nil {
		return x.PhoneNumber
	}
	return ""
}

type EncryptableWalletAmount struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Nonce                    string                     `protobuf:"bytes,1,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	TransactionID            string                     `protobuf:"bytes,2,opt,name=TransactionID,proto3" json:"TransactionID,omitempty"`
	PedersenCommit           *EncryptablePedersenCommit `protobuf:"bytes,3,opt,name=PedersenCommit,proto3" json:"PedersenCommit,omitempty"`
	Note                     string                     `protobuf:"bytes,4,opt,name=Note,proto3" json:"Note,omitempty"`
	RequiredSenderPIN        string                     `protobuf:"bytes,5,opt,name=RequiredSenderPIN,proto3" json:"RequiredSenderPIN,omitempty"`
	RequiredSenderFirstName  string                     `protobuf:"bytes,6,opt,name=RequiredSenderFirstName,proto3" json:"RequiredSenderFirstName,omitempty"`
	RequiredSenderMiddleName string                     `protobuf:"bytes,7,opt,name=RequiredSenderMiddleName,proto3" json:"RequiredSenderMiddleName,omitempty"`
	RequiredSenderLastName   string                     `protobuf:"bytes,8,opt,name=RequiredSenderLastName,proto3" json:"RequiredSenderLastName,omitempty"`
}

func (x *EncryptableWalletAmount) Reset() {
	*x = EncryptableWalletAmount{}
	if protoimpl.UnsafeEnabled {
		mi := &file_qadena_qadena_encryptable_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EncryptableWalletAmount) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptableWalletAmount) ProtoMessage() {}

// Deprecated: Use EncryptableWalletAmount.ProtoReflect.Descriptor instead.
func (*EncryptableWalletAmount) Descriptor() ([]byte, []int) {
	return file_qadena_qadena_encryptable_proto_rawDescGZIP(), []int{4}
}

func (x *EncryptableWalletAmount) GetNonce() string {
	if x != nil {
		return x.Nonce
	}
	return ""
}

func (x *EncryptableWalletAmount) GetTransactionID() string {
	if x != nil {
		return x.TransactionID
	}
	return ""
}

func (x *EncryptableWalletAmount) GetPedersenCommit() *EncryptablePedersenCommit {
	if x != nil {
		return x.PedersenCommit
	}
	return nil
}

func (x *EncryptableWalletAmount) GetNote() string {
	if x != nil {
		return x.Note
	}
	return ""
}

func (x *EncryptableWalletAmount) GetRequiredSenderPIN() string {
	if x != nil {
		return x.RequiredSenderPIN
	}
	return ""
}

func (x *EncryptableWalletAmount) GetRequiredSenderFirstName() string {
	if x != nil {
		return x.RequiredSenderFirstName
	}
	return ""
}

func (x *EncryptableWalletAmount) GetRequiredSenderMiddleName() string {
	if x != nil {
		return x.RequiredSenderMiddleName
	}
	return ""
}

func (x *EncryptableWalletAmount) GetRequiredSenderLastName() string {
	if x != nil {
		return x.RequiredSenderLastName
	}
	return ""
}

type EncryptablePersonalInfoDetails struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	FirstName   string `protobuf:"bytes,1,opt,name=FirstName,proto3" json:"FirstName,omitempty"`
	MiddleName  string `protobuf:"bytes,2,opt,name=MiddleName,proto3" json:"MiddleName,omitempty"`
	LastName    string `protobuf:"bytes,3,opt,name=LastName,proto3" json:"LastName,omitempty"`
	Birthdate   string `protobuf:"bytes,4,opt,name=Birthdate,proto3" json:"Birthdate,omitempty"`
	Citizenship string `protobuf:"bytes,5,opt,name=Citizenship,proto3" json:"Citizenship,omitempty"` // e.g US,PH,...
	Residency   string `protobuf:"bytes,6,opt,name=Residency,proto3" json:"Residency,omitempty"`
	Gender      string `protobuf:"bytes,7,opt,name=Gender,proto3" json:"Gender,omitempty"`
}

func (x *EncryptablePersonalInfoDetails) Reset() {
	*x = EncryptablePersonalInfoDetails{}
	if protoimpl.UnsafeEnabled {
		mi := &file_qadena_qadena_encryptable_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EncryptablePersonalInfoDetails) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptablePersonalInfoDetails) ProtoMessage() {}

// Deprecated: Use EncryptablePersonalInfoDetails.ProtoReflect.Descriptor instead.
func (*EncryptablePersonalInfoDetails) Descriptor() ([]byte, []int) {
	return file_qadena_qadena_encryptable_proto_rawDescGZIP(), []int{5}
}

func (x *EncryptablePersonalInfoDetails) GetFirstName() string {
	if x != nil {
		return x.FirstName
	}
	return ""
}

func (x *EncryptablePersonalInfoDetails) GetMiddleName() string {
	if x != nil {
		return x.MiddleName
	}
	return ""
}

func (x *EncryptablePersonalInfoDetails) GetLastName() string {
	if x != nil {
		return x.LastName
	}
	return ""
}

func (x *EncryptablePersonalInfoDetails) GetBirthdate() string {
	if x != nil {
		return x.Birthdate
	}
	return ""
}

func (x *EncryptablePersonalInfoDetails) GetCitizenship() string {
	if x != nil {
		return x.Citizenship
	}
	return ""
}

func (x *EncryptablePersonalInfoDetails) GetResidency() string {
	if x != nil {
		return x.Residency
	}
	return ""
}

func (x *EncryptablePersonalInfoDetails) GetGender() string {
	if x != nil {
		return x.Gender
	}
	return ""
}

type EncryptablePersonalInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Nonce   string                          `protobuf:"bytes,1,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	PIN     string                          `protobuf:"bytes,2,opt,name=PIN,proto3" json:"PIN,omitempty"`
	Details *EncryptablePersonalInfoDetails `protobuf:"bytes,3,opt,name=Details,proto3" json:"Details,omitempty"`
}

func (x *EncryptablePersonalInfo) Reset() {
	*x = EncryptablePersonalInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_qadena_qadena_encryptable_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EncryptablePersonalInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptablePersonalInfo) ProtoMessage() {}

// Deprecated: Use EncryptablePersonalInfo.ProtoReflect.Descriptor instead.
func (*EncryptablePersonalInfo) Descriptor() ([]byte, []int) {
	return file_qadena_qadena_encryptable_proto_rawDescGZIP(), []int{6}
}

func (x *EncryptablePersonalInfo) GetNonce() string {
	if x != nil {
		return x.Nonce
	}
	return ""
}

func (x *EncryptablePersonalInfo) GetPIN() string {
	if x != nil {
		return x.PIN
	}
	return ""
}

func (x *EncryptablePersonalInfo) GetDetails() *EncryptablePersonalInfoDetails {
	if x != nil {
		return x.Details
	}
	return nil
}

type EncryptableSingleContactInfoDetails struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Contact string `protobuf:"bytes,1,opt,name=Contact,proto3" json:"Contact,omitempty"`
}

func (x *EncryptableSingleContactInfoDetails) Reset() {
	*x = EncryptableSingleContactInfoDetails{}
	if protoimpl.UnsafeEnabled {
		mi := &file_qadena_qadena_encryptable_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EncryptableSingleContactInfoDetails) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptableSingleContactInfoDetails) ProtoMessage() {}

// Deprecated: Use EncryptableSingleContactInfoDetails.ProtoReflect.Descriptor instead.
func (*EncryptableSingleContactInfoDetails) Descriptor() ([]byte, []int) {
	return file_qadena_qadena_encryptable_proto_rawDescGZIP(), []int{7}
}

func (x *EncryptableSingleContactInfoDetails) GetContact() string {
	if x != nil {
		return x.Contact
	}
	return ""
}

type EncryptableSingleContactInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Nonce   string                               `protobuf:"bytes,1,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	PIN     string                               `protobuf:"bytes,2,opt,name=PIN,proto3" json:"PIN,omitempty"`
	Details *EncryptableSingleContactInfoDetails `protobuf:"bytes,3,opt,name=Details,proto3" json:"Details,omitempty"`
}

func (x *EncryptableSingleContactInfo) Reset() {
	*x = EncryptableSingleContactInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_qadena_qadena_encryptable_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EncryptableSingleContactInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptableSingleContactInfo) ProtoMessage() {}

// Deprecated: Use EncryptableSingleContactInfo.ProtoReflect.Descriptor instead.
func (*EncryptableSingleContactInfo) Descriptor() ([]byte, []int) {
	return file_qadena_qadena_encryptable_proto_rawDescGZIP(), []int{8}
}

func (x *EncryptableSingleContactInfo) GetNonce() string {
	if x != nil {
		return x.Nonce
	}
	return ""
}

func (x *EncryptableSingleContactInfo) GetPIN() string {
	if x != nil {
		return x.PIN
	}
	return ""
}

func (x *EncryptableSingleContactInfo) GetDetails() *EncryptableSingleContactInfoDetails {
	if x != nil {
		return x.Details
	}
	return nil
}

type EncryptableValidatedCredential struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	CredentialType string           `protobuf:"bytes,1,opt,name=CredentialType,proto3" json:"CredentialType,omitempty"`
	PIN            string           `protobuf:"bytes,2,opt,name=PIN,proto3" json:"PIN,omitempty"`
	CredentialPC   *BPedersenCommit `protobuf:"bytes,3,opt,name=CredentialPC,proto3" json:"CredentialPC,omitempty"`
}

func (x *EncryptableValidatedCredential) Reset() {
	*x = EncryptableValidatedCredential{}
	if protoimpl.UnsafeEnabled {
		mi := &file_qadena_qadena_encryptable_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EncryptableValidatedCredential) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptableValidatedCredential) ProtoMessage() {}

// Deprecated: Use EncryptableValidatedCredential.ProtoReflect.Descriptor instead.
func (*EncryptableValidatedCredential) Descriptor() ([]byte, []int) {
	return file_qadena_qadena_encryptable_proto_rawDescGZIP(), []int{9}
}

func (x *EncryptableValidatedCredential) GetCredentialType() string {
	if x != nil {
		return x.CredentialType
	}
	return ""
}

func (x *EncryptableValidatedCredential) GetPIN() string {
	if x != nil {
		return x.PIN
	}
	return ""
}

func (x *EncryptableValidatedCredential) GetCredentialPC() *BPedersenCommit {
	if x != nil {
		return x.CredentialPC
	}
	return nil
}

type EncryptableValidatedCredentials struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Credentials []*EncryptableValidatedCredential `protobuf:"bytes,1,rep,name=Credentials,proto3" json:"Credentials,omitempty"`
}

func (x *EncryptableValidatedCredentials) Reset() {
	*x = EncryptableValidatedCredentials{}
	if protoimpl.UnsafeEnabled {
		mi := &file_qadena_qadena_encryptable_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EncryptableValidatedCredentials) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptableValidatedCredentials) ProtoMessage() {}

// Deprecated: Use EncryptableValidatedCredentials.ProtoReflect.Descriptor instead.
func (*EncryptableValidatedCredentials) Descriptor() ([]byte, []int) {
	return file_qadena_qadena_encryptable_proto_rawDescGZIP(), []int{10}
}

func (x *EncryptableValidatedCredentials) GetCredentials() []*EncryptableValidatedCredential {
	if x != nil {
		return x.Credentials
	}
	return nil
}

type EncryptableCreateWalletEWalletIDExtraParms struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ProofPC *BPedersenCommit `protobuf:"bytes,1,opt,name=ProofPC,proto3" json:"ProofPC,omitempty"`
}

func (x *EncryptableCreateWalletEWalletIDExtraParms) Reset() {
	*x = EncryptableCreateWalletEWalletIDExtraParms{}
	if protoimpl.UnsafeEnabled {
		mi := &file_qadena_qadena_encryptable_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EncryptableCreateWalletEWalletIDExtraParms) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptableCreateWalletEWalletIDExtraParms) ProtoMessage() {}

// Deprecated: Use EncryptableCreateWalletEWalletIDExtraParms.ProtoReflect.Descriptor instead.
func (*EncryptableCreateWalletEWalletIDExtraParms) Descriptor() ([]byte, []int) {
	return file_qadena_qadena_encryptable_proto_rawDescGZIP(), []int{11}
}

func (x *EncryptableCreateWalletEWalletIDExtraParms) GetProofPC() *BPedersenCommit {
	if x != nil {
		return x.ProofPC
	}
	return nil
}

type EncryptableCreateWalletEWalletID struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Nonce      string                                      `protobuf:"bytes,1,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	WalletID   string                                      `protobuf:"bytes,2,opt,name=WalletID,proto3" json:"WalletID,omitempty"`
	ExtraParms *EncryptableCreateWalletEWalletIDExtraParms `protobuf:"bytes,3,opt,name=ExtraParms,proto3" json:"ExtraParms,omitempty"`
}

func (x *EncryptableCreateWalletEWalletID) Reset() {
	*x = EncryptableCreateWalletEWalletID{}
	if protoimpl.UnsafeEnabled {
		mi := &file_qadena_qadena_encryptable_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EncryptableCreateWalletEWalletID) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptableCreateWalletEWalletID) ProtoMessage() {}

// Deprecated: Use EncryptableCreateWalletEWalletID.ProtoReflect.Descriptor instead.
func (*EncryptableCreateWalletEWalletID) Descriptor() ([]byte, []int) {
	return file_qadena_qadena_encryptable_proto_rawDescGZIP(), []int{12}
}

func (x *EncryptableCreateWalletEWalletID) GetNonce() string {
	if x != nil {
		return x.Nonce
	}
	return ""
}

func (x *EncryptableCreateWalletEWalletID) GetWalletID() string {
	if x != nil {
		return x.WalletID
	}
	return ""
}

func (x *EncryptableCreateWalletEWalletID) GetExtraParms() *EncryptableCreateWalletEWalletIDExtraParms {
	if x != nil {
		return x.ExtraParms
	}
	return nil
}

type EncryptableCreateWallet struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	DstEWalletID *EncryptableCreateWalletEWalletID `protobuf:"bytes,1,opt,name=DstEWalletID,proto3" json:"DstEWalletID,omitempty"`
}

func (x *EncryptableCreateWallet) Reset() {
	*x = EncryptableCreateWallet{}
	if protoimpl.UnsafeEnabled {
		mi := &file_qadena_qadena_encryptable_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EncryptableCreateWallet) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptableCreateWallet) ProtoMessage() {}

// Deprecated: Use EncryptableCreateWallet.ProtoReflect.Descriptor instead.
func (*EncryptableCreateWallet) Descriptor() ([]byte, []int) {
	return file_qadena_qadena_encryptable_proto_rawDescGZIP(), []int{13}
}

func (x *EncryptableCreateWallet) GetDstEWalletID() *EncryptableCreateWalletEWalletID {
	if x != nil {
		return x.DstEWalletID
	}
	return nil
}

type EncryptableTransferFundsEWalletIDExtraParms struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	AcceptPasswordPC                *BPedersenCommit `protobuf:"bytes,1,opt,name=AcceptPasswordPC,proto3" json:"AcceptPasswordPC,omitempty"`
	MatchFirstNameHashHex           []byte           `protobuf:"bytes,2,opt,name=MatchFirstNameHashHex,proto3" json:"MatchFirstNameHashHex,omitempty"`
	MatchMiddleNameHashHex          []byte           `protobuf:"bytes,3,opt,name=MatchMiddleNameHashHex,proto3" json:"MatchMiddleNameHashHex,omitempty"`
	MatchLastNameHashHex            []byte           `protobuf:"bytes,4,opt,name=MatchLastNameHashHex,proto3" json:"MatchLastNameHashHex,omitempty"`
	RequiredSenderFirstNameCheckPC  *BPedersenCommit `protobuf:"bytes,5,opt,name=RequiredSenderFirstNameCheckPC,proto3" json:"RequiredSenderFirstNameCheckPC,omitempty"`
	RequiredSenderFirstNameProofPC  *BPedersenCommit `protobuf:"bytes,6,opt,name=RequiredSenderFirstNameProofPC,proto3" json:"RequiredSenderFirstNameProofPC,omitempty"`
	RequiredSenderMiddleNameCheckPC *BPedersenCommit `protobuf:"bytes,7,opt,name=RequiredSenderMiddleNameCheckPC,proto3" json:"RequiredSenderMiddleNameCheckPC,omitempty"`
	RequiredSenderMiddleNameProofPC *BPedersenCommit `protobuf:"bytes,8,opt,name=RequiredSenderMiddleNameProofPC,proto3" json:"RequiredSenderMiddleNameProofPC,omitempty"`
	RequiredSenderLastNameCheckPC   *BPedersenCommit `protobuf:"bytes,9,opt,name=RequiredSenderLastNameCheckPC,proto3" json:"RequiredSenderLastNameCheckPC,omitempty"`
	RequiredSenderLastNameProofPC   *BPedersenCommit `protobuf:"bytes,10,opt,name=RequiredSenderLastNameProofPC,proto3" json:"RequiredSenderLastNameProofPC,omitempty"`
}

func (x *EncryptableTransferFundsEWalletIDExtraParms) Reset() {
	*x = EncryptableTransferFundsEWalletIDExtraParms{}
	if protoimpl.UnsafeEnabled {
		mi := &file_qadena_qadena_encryptable_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EncryptableTransferFundsEWalletIDExtraParms) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptableTransferFundsEWalletIDExtraParms) ProtoMessage() {}

// Deprecated: Use EncryptableTransferFundsEWalletIDExtraParms.ProtoReflect.Descriptor instead.
func (*EncryptableTransferFundsEWalletIDExtraParms) Descriptor() ([]byte, []int) {
	return file_qadena_qadena_encryptable_proto_rawDescGZIP(), []int{14}
}

func (x *EncryptableTransferFundsEWalletIDExtraParms) GetAcceptPasswordPC() *BPedersenCommit {
	if x != nil {
		return x.AcceptPasswordPC
	}
	return nil
}

func (x *EncryptableTransferFundsEWalletIDExtraParms) GetMatchFirstNameHashHex() []byte {
	if x != nil {
		return x.MatchFirstNameHashHex
	}
	return nil
}

func (x *EncryptableTransferFundsEWalletIDExtraParms) GetMatchMiddleNameHashHex() []byte {
	if x != nil {
		return x.MatchMiddleNameHashHex
	}
	return nil
}

func (x *EncryptableTransferFundsEWalletIDExtraParms) GetMatchLastNameHashHex() []byte {
	if x != nil {
		return x.MatchLastNameHashHex
	}
	return nil
}

func (x *EncryptableTransferFundsEWalletIDExtraParms) GetRequiredSenderFirstNameCheckPC() *BPedersenCommit {
	if x != nil {
		return x.RequiredSenderFirstNameCheckPC
	}
	return nil
}

func (x *EncryptableTransferFundsEWalletIDExtraParms) GetRequiredSenderFirstNameProofPC() *BPedersenCommit {
	if x != nil {
		return x.RequiredSenderFirstNameProofPC
	}
	return nil
}

func (x *EncryptableTransferFundsEWalletIDExtraParms) GetRequiredSenderMiddleNameCheckPC() *BPedersenCommit {
	if x != nil {
		return x.RequiredSenderMiddleNameCheckPC
	}
	return nil
}

func (x *EncryptableTransferFundsEWalletIDExtraParms) GetRequiredSenderMiddleNameProofPC() *BPedersenCommit {
	if x != nil {
		return x.RequiredSenderMiddleNameProofPC
	}
	return nil
}

func (x *EncryptableTransferFundsEWalletIDExtraParms) GetRequiredSenderLastNameCheckPC() *BPedersenCommit {
	if x != nil {
		return x.RequiredSenderLastNameCheckPC
	}
	return nil
}

func (x *EncryptableTransferFundsEWalletIDExtraParms) GetRequiredSenderLastNameProofPC() *BPedersenCommit {
	if x != nil {
		return x.RequiredSenderLastNameProofPC
	}
	return nil
}

type EncryptableTransferFundsEWalletID struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Nonce      string                                       `protobuf:"bytes,1,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	WalletID   string                                       `protobuf:"bytes,2,opt,name=WalletID,proto3" json:"WalletID,omitempty"`
	ExtraParms *EncryptableTransferFundsEWalletIDExtraParms `protobuf:"bytes,3,opt,name=ExtraParms,proto3" json:"ExtraParms,omitempty"`
}

func (x *EncryptableTransferFundsEWalletID) Reset() {
	*x = EncryptableTransferFundsEWalletID{}
	if protoimpl.UnsafeEnabled {
		mi := &file_qadena_qadena_encryptable_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EncryptableTransferFundsEWalletID) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptableTransferFundsEWalletID) ProtoMessage() {}

// Deprecated: Use EncryptableTransferFundsEWalletID.ProtoReflect.Descriptor instead.
func (*EncryptableTransferFundsEWalletID) Descriptor() ([]byte, []int) {
	return file_qadena_qadena_encryptable_proto_rawDescGZIP(), []int{15}
}

func (x *EncryptableTransferFundsEWalletID) GetNonce() string {
	if x != nil {
		return x.Nonce
	}
	return ""
}

func (x *EncryptableTransferFundsEWalletID) GetWalletID() string {
	if x != nil {
		return x.WalletID
	}
	return ""
}

func (x *EncryptableTransferFundsEWalletID) GetExtraParms() *EncryptableTransferFundsEWalletIDExtraParms {
	if x != nil {
		return x.ExtraParms
	}
	return nil
}

type EncryptableTransferFunds struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	HiddenTransferPC *EncryptablePedersenCommit         `protobuf:"bytes,1,opt,name=HiddenTransferPC,proto3" json:"HiddenTransferPC,omitempty"`
	DstEWalletID     *EncryptableTransferFundsEWalletID `protobuf:"bytes,2,opt,name=DstEWalletID,proto3" json:"DstEWalletID,omitempty"`
	OptInReason      string                             `protobuf:"bytes,3,opt,name=OptInReason,proto3" json:"OptInReason,omitempty"`
}

func (x *EncryptableTransferFunds) Reset() {
	*x = EncryptableTransferFunds{}
	if protoimpl.UnsafeEnabled {
		mi := &file_qadena_qadena_encryptable_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EncryptableTransferFunds) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptableTransferFunds) ProtoMessage() {}

// Deprecated: Use EncryptableTransferFunds.ProtoReflect.Descriptor instead.
func (*EncryptableTransferFunds) Descriptor() ([]byte, []int) {
	return file_qadena_qadena_encryptable_proto_rawDescGZIP(), []int{16}
}

func (x *EncryptableTransferFunds) GetHiddenTransferPC() *EncryptablePedersenCommit {
	if x != nil {
		return x.HiddenTransferPC
	}
	return nil
}

func (x *EncryptableTransferFunds) GetDstEWalletID() *EncryptableTransferFundsEWalletID {
	if x != nil {
		return x.DstEWalletID
	}
	return nil
}

func (x *EncryptableTransferFunds) GetOptInReason() string {
	if x != nil {
		return x.OptInReason
	}
	return ""
}

type EncryptableReceiveFundsEWalletIDExtraParms struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Queue string `protobuf:"bytes,1,opt,name=Queue,proto3" json:"Queue,omitempty"`
}

func (x *EncryptableReceiveFundsEWalletIDExtraParms) Reset() {
	*x = EncryptableReceiveFundsEWalletIDExtraParms{}
	if protoimpl.UnsafeEnabled {
		mi := &file_qadena_qadena_encryptable_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EncryptableReceiveFundsEWalletIDExtraParms) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptableReceiveFundsEWalletIDExtraParms) ProtoMessage() {}

// Deprecated: Use EncryptableReceiveFundsEWalletIDExtraParms.ProtoReflect.Descriptor instead.
func (*EncryptableReceiveFundsEWalletIDExtraParms) Descriptor() ([]byte, []int) {
	return file_qadena_qadena_encryptable_proto_rawDescGZIP(), []int{17}
}

func (x *EncryptableReceiveFundsEWalletIDExtraParms) GetQueue() string {
	if x != nil {
		return x.Queue
	}
	return ""
}

type EncryptableReceiveFundsEWalletID struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Nonce      string                                      `protobuf:"bytes,1,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	WalletID   string                                      `protobuf:"bytes,2,opt,name=WalletID,proto3" json:"WalletID,omitempty"`
	ExtraParms *EncryptableReceiveFundsEWalletIDExtraParms `protobuf:"bytes,3,opt,name=ExtraParms,proto3" json:"ExtraParms,omitempty"`
}

func (x *EncryptableReceiveFundsEWalletID) Reset() {
	*x = EncryptableReceiveFundsEWalletID{}
	if protoimpl.UnsafeEnabled {
		mi := &file_qadena_qadena_encryptable_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EncryptableReceiveFundsEWalletID) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptableReceiveFundsEWalletID) ProtoMessage() {}

// Deprecated: Use EncryptableReceiveFundsEWalletID.ProtoReflect.Descriptor instead.
func (*EncryptableReceiveFundsEWalletID) Descriptor() ([]byte, []int) {
	return file_qadena_qadena_encryptable_proto_rawDescGZIP(), []int{18}
}

func (x *EncryptableReceiveFundsEWalletID) GetNonce() string {
	if x != nil {
		return x.Nonce
	}
	return ""
}

func (x *EncryptableReceiveFundsEWalletID) GetWalletID() string {
	if x != nil {
		return x.WalletID
	}
	return ""
}

func (x *EncryptableReceiveFundsEWalletID) GetExtraParms() *EncryptableReceiveFundsEWalletIDExtraParms {
	if x != nil {
		return x.ExtraParms
	}
	return nil
}

type EncryptableSignRecoverKeyEWalletID struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Nonce    string `protobuf:"bytes,1,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	WalletID string `protobuf:"bytes,2,opt,name=WalletID,proto3" json:"WalletID,omitempty"`
}

func (x *EncryptableSignRecoverKeyEWalletID) Reset() {
	*x = EncryptableSignRecoverKeyEWalletID{}
	if protoimpl.UnsafeEnabled {
		mi := &file_qadena_qadena_encryptable_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EncryptableSignRecoverKeyEWalletID) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptableSignRecoverKeyEWalletID) ProtoMessage() {}

// Deprecated: Use EncryptableSignRecoverKeyEWalletID.ProtoReflect.Descriptor instead.
func (*EncryptableSignRecoverKeyEWalletID) Descriptor() ([]byte, []int) {
	return file_qadena_qadena_encryptable_proto_rawDescGZIP(), []int{19}
}

func (x *EncryptableSignRecoverKeyEWalletID) GetNonce() string {
	if x != nil {
		return x.Nonce
	}
	return ""
}

func (x *EncryptableSignRecoverKeyEWalletID) GetWalletID() string {
	if x != nil {
		return x.WalletID
	}
	return ""
}

type EncryptableReceiveFunds struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	EphEWalletID *EncryptableReceiveFundsEWalletID `protobuf:"bytes,1,opt,name=EphEWalletID,proto3" json:"EphEWalletID,omitempty"`
}

func (x *EncryptableReceiveFunds) Reset() {
	*x = EncryptableReceiveFunds{}
	if protoimpl.UnsafeEnabled {
		mi := &file_qadena_qadena_encryptable_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EncryptableReceiveFunds) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptableReceiveFunds) ProtoMessage() {}

// Deprecated: Use EncryptableReceiveFunds.ProtoReflect.Descriptor instead.
func (*EncryptableReceiveFunds) Descriptor() ([]byte, []int) {
	return file_qadena_qadena_encryptable_proto_rawDescGZIP(), []int{20}
}

func (x *EncryptableReceiveFunds) GetEphEWalletID() *EncryptableReceiveFundsEWalletID {
	if x != nil {
		return x.EphEWalletID
	}
	return nil
}

type EncryptableAnonTransferFunds struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	TotalTransferPrimePC  *EncryptablePedersenCommit `protobuf:"bytes,1,opt,name=TotalTransferPrimePC,proto3" json:"TotalTransferPrimePC,omitempty"`
	TransparentTransferBF *BInt                      `protobuf:"bytes,2,opt,name=TransparentTransferBF,proto3" json:"TransparentTransferBF,omitempty"`
}

func (x *EncryptableAnonTransferFunds) Reset() {
	*x = EncryptableAnonTransferFunds{}
	if protoimpl.UnsafeEnabled {
		mi := &file_qadena_qadena_encryptable_proto_msgTypes[21]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EncryptableAnonTransferFunds) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptableAnonTransferFunds) ProtoMessage() {}

// Deprecated: Use EncryptableAnonTransferFunds.ProtoReflect.Descriptor instead.
func (*EncryptableAnonTransferFunds) Descriptor() ([]byte, []int) {
	return file_qadena_qadena_encryptable_proto_rawDescGZIP(), []int{21}
}

func (x *EncryptableAnonTransferFunds) GetTotalTransferPrimePC() *EncryptablePedersenCommit {
	if x != nil {
		return x.TotalTransferPrimePC
	}
	return nil
}

func (x *EncryptableAnonTransferFunds) GetTransparentTransferBF() *BInt {
	if x != nil {
		return x.TransparentTransferBF
	}
	return nil
}

type EncryptableESuspiciousAmount struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Nonce         string        `protobuf:"bytes,1,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	USDCoinAmount *v1beta1.Coin `protobuf:"bytes,2,opt,name=USDCoinAmount,proto3" json:"USDCoinAmount,omitempty"`
	CoinAmount    *v1beta1.Coin `protobuf:"bytes,3,opt,name=CoinAmount,proto3" json:"CoinAmount,omitempty"`
}

func (x *EncryptableESuspiciousAmount) Reset() {
	*x = EncryptableESuspiciousAmount{}
	if protoimpl.UnsafeEnabled {
		mi := &file_qadena_qadena_encryptable_proto_msgTypes[22]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EncryptableESuspiciousAmount) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptableESuspiciousAmount) ProtoMessage() {}

// Deprecated: Use EncryptableESuspiciousAmount.ProtoReflect.Descriptor instead.
func (*EncryptableESuspiciousAmount) Descriptor() ([]byte, []int) {
	return file_qadena_qadena_encryptable_proto_rawDescGZIP(), []int{22}
}

func (x *EncryptableESuspiciousAmount) GetNonce() string {
	if x != nil {
		return x.Nonce
	}
	return ""
}

func (x *EncryptableESuspiciousAmount) GetUSDCoinAmount() *v1beta1.Coin {
	if x != nil {
		return x.USDCoinAmount
	}
	return nil
}

func (x *EncryptableESuspiciousAmount) GetCoinAmount() *v1beta1.Coin {
	if x != nil {
		return x.CoinAmount
	}
	return nil
}

type EncryptableSSIDAndPrivK struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	PubKID string `protobuf:"bytes,1,opt,name=PubKID,proto3" json:"PubKID,omitempty"`
	PubK   string `protobuf:"bytes,2,opt,name=PubK,proto3" json:"PubK,omitempty"`
	PrivK  string `protobuf:"bytes,3,opt,name=PrivK,proto3" json:"PrivK,omitempty"`
}

func (x *EncryptableSSIDAndPrivK) Reset() {
	*x = EncryptableSSIDAndPrivK{}
	if protoimpl.UnsafeEnabled {
		mi := &file_qadena_qadena_encryptable_proto_msgTypes[23]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EncryptableSSIDAndPrivK) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptableSSIDAndPrivK) ProtoMessage() {}

// Deprecated: Use EncryptableSSIDAndPrivK.ProtoReflect.Descriptor instead.
func (*EncryptableSSIDAndPrivK) Descriptor() ([]byte, []int) {
	return file_qadena_qadena_encryptable_proto_rawDescGZIP(), []int{23}
}

func (x *EncryptableSSIDAndPrivK) GetPubKID() string {
	if x != nil {
		return x.PubKID
	}
	return ""
}

func (x *EncryptableSSIDAndPrivK) GetPubK() string {
	if x != nil {
		return x.PubK
	}
	return ""
}

func (x *EncryptableSSIDAndPrivK) GetPrivK() string {
	if x != nil {
		return x.PrivK
	}
	return ""
}

type EncryptablePioneerIDs struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	PioneerIDs []string `protobuf:"bytes,1,rep,name=PioneerIDs,proto3" json:"PioneerIDs,omitempty"`
}

func (x *EncryptablePioneerIDs) Reset() {
	*x = EncryptablePioneerIDs{}
	if protoimpl.UnsafeEnabled {
		mi := &file_qadena_qadena_encryptable_proto_msgTypes[24]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EncryptablePioneerIDs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptablePioneerIDs) ProtoMessage() {}

// Deprecated: Use EncryptablePioneerIDs.ProtoReflect.Descriptor instead.
func (*EncryptablePioneerIDs) Descriptor() ([]byte, []int) {
	return file_qadena_qadena_encryptable_proto_rawDescGZIP(), []int{24}
}

func (x *EncryptablePioneerIDs) GetPioneerIDs() []string {
	if x != nil {
		return x.PioneerIDs
	}
	return nil
}

type EncryptableEnclaveSSOwnerMap struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Pioneers map[string]*EncryptablePioneerIDs `protobuf:"bytes,1,rep,name=Pioneers,proto3" json:"Pioneers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *EncryptableEnclaveSSOwnerMap) Reset() {
	*x = EncryptableEnclaveSSOwnerMap{}
	if protoimpl.UnsafeEnabled {
		mi := &file_qadena_qadena_encryptable_proto_msgTypes[25]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EncryptableEnclaveSSOwnerMap) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptableEnclaveSSOwnerMap) ProtoMessage() {}

// Deprecated: Use EncryptableEnclaveSSOwnerMap.ProtoReflect.Descriptor instead.
func (*EncryptableEnclaveSSOwnerMap) Descriptor() ([]byte, []int) {
	return file_qadena_qadena_encryptable_proto_rawDescGZIP(), []int{25}
}

func (x *EncryptableEnclaveSSOwnerMap) GetPioneers() map[string]*EncryptablePioneerIDs {
	if x != nil {
		return x.Pioneers
	}
	return nil
}

type EncryptableEnclavePubKCacheMap struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	PubKs map[string]string `protobuf:"bytes,1,rep,name=PubKs,proto3" json:"PubKs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *EncryptableEnclavePubKCacheMap) Reset() {
	*x = EncryptableEnclavePubKCacheMap{}
	if protoimpl.UnsafeEnabled {
		mi := &file_qadena_qadena_encryptable_proto_msgTypes[26]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EncryptableEnclavePubKCacheMap) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptableEnclavePubKCacheMap) ProtoMessage() {}

// Deprecated: Use EncryptableEnclavePubKCacheMap.ProtoReflect.Descriptor instead.
func (*EncryptableEnclavePubKCacheMap) Descriptor() ([]byte, []int) {
	return file_qadena_qadena_encryptable_proto_rawDescGZIP(), []int{26}
}

func (x *EncryptableEnclavePubKCacheMap) GetPubKs() map[string]string {
	if x != nil {
		return x.PubKs
	}
	return nil
}

type EncryptableSharedEnclaveParams struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	JarID               string `protobuf:"bytes,1,opt,name=JarID,proto3" json:"JarID,omitempty"`
	JarArmorPrivK       string `protobuf:"bytes,2,opt,name=JarArmorPrivK,proto3" json:"JarArmorPrivK,omitempty"`
	JarPrivK            string `protobuf:"bytes,3,opt,name=JarPrivK,proto3" json:"JarPrivK,omitempty"`
	JarPubK             string `protobuf:"bytes,4,opt,name=JarPubK,proto3" json:"JarPubK,omitempty"`
	RegulatorID         string `protobuf:"bytes,5,opt,name=RegulatorID,proto3" json:"RegulatorID,omitempty"`
	RegulatorArmorPrivK string `protobuf:"bytes,6,opt,name=RegulatorArmorPrivK,proto3" json:"RegulatorArmorPrivK,omitempty"`
	RegulatorPrivK      string `protobuf:"bytes,7,opt,name=RegulatorPrivK,proto3" json:"RegulatorPrivK,omitempty"`
	RegulatorPubK       string `protobuf:"bytes,8,opt,name=RegulatorPubK,proto3" json:"RegulatorPubK,omitempty"`
	// these only used temporarily to sync data from enclave to enclave
	SSIntervalOwners    *EncryptableEnclaveSSOwnerMap   `protobuf:"bytes,9,opt,name=SSIntervalOwners,proto3" json:"SSIntervalOwners,omitempty"`
	SSIntervalPubKCache *EncryptableEnclavePubKCacheMap `protobuf:"bytes,10,opt,name=SSIntervalPubKCache,proto3" json:"SSIntervalPubKCache,omitempty"`
}

func (x *EncryptableSharedEnclaveParams) Reset() {
	*x = EncryptableSharedEnclaveParams{}
	if protoimpl.UnsafeEnabled {
		mi := &file_qadena_qadena_encryptable_proto_msgTypes[27]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *EncryptableSharedEnclaveParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EncryptableSharedEnclaveParams) ProtoMessage() {}

// Deprecated: Use EncryptableSharedEnclaveParams.ProtoReflect.Descriptor instead.
func (*EncryptableSharedEnclaveParams) Descriptor() ([]byte, []int) {
	return file_qadena_qadena_encryptable_proto_rawDescGZIP(), []int{27}
}

func (x *EncryptableSharedEnclaveParams) GetJarID() string {
	if x != nil {
		return x.JarID
	}
	return ""
}

func (x *EncryptableSharedEnclaveParams) GetJarArmorPrivK() string {
	if x != nil {
		return x.JarArmorPrivK
	}
	return ""
}

func (x *EncryptableSharedEnclaveParams) GetJarPrivK() string {
	if x != nil {
		return x.JarPrivK
	}
	return ""
}

func (x *EncryptableSharedEnclaveParams) GetJarPubK() string {
	if x != nil {
		return x.JarPubK
	}
	return ""
}

func (x *EncryptableSharedEnclaveParams) GetRegulatorID() string {
	if x != nil {
		return x.RegulatorID
	}
	return ""
}

func (x *EncryptableSharedEnclaveParams) GetRegulatorArmorPrivK() string {
	if x != nil {
		return x.RegulatorArmorPrivK
	}
	return ""
}

func (x *EncryptableSharedEnclaveParams) GetRegulatorPrivK() string {
	if x != nil {
		return x.RegulatorPrivK
	}
	return ""
}

func (x *EncryptableSharedEnclaveParams) GetRegulatorPubK() string {
	if x != nil {
		return x.RegulatorPubK
	}
	return ""
}

func (x *EncryptableSharedEnclaveParams) GetSSIntervalOwners() *EncryptableEnclaveSSOwnerMap {
	if x != nil {
		return x.SSIntervalOwners
	}
	return nil
}

func (x *EncryptableSharedEnclaveParams) GetSSIntervalPubKCache() *EncryptableEnclavePubKCacheMap {
	if x != nil {
		return x.SSIntervalPubKCache
	}
	return nil
}

var File_qadena_qadena_encryptable_proto protoreflect.FileDescriptor

var file_qadena_qadena_encryptable_proto_rawDesc = []byte{
	0x0a, 0x1f, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2f, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2f,
	0x65, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x12, 0x0d, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61,
	0x1a, 0x11, 0x61, 0x6d, 0x69, 0x6e, 0x6f, 0x2f, 0x61, 0x6d, 0x69, 0x6e, 0x6f, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x1a, 0x17, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2f, 0x6d, 0x73, 0x67, 0x2f,
	0x76, 0x31, 0x2f, 0x6d, 0x73, 0x67, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x19, 0x63, 0x6f,
	0x73, 0x6d, 0x6f, 0x73, 0x5f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1e, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2f,
	0x62, 0x61, 0x73, 0x65, 0x2f, 0x76, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0x2f, 0x63, 0x6f, 0x69,
	0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x14, 0x67, 0x6f, 0x67, 0x6f, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x2f, 0x67, 0x6f, 0x67, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1a, 0x71,
	0x61, 0x64, 0x65, 0x6e, 0x61, 0x2f, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2f, 0x70, 0x61, 0x72,
	0x61, 0x6d, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x2a, 0x71, 0x61, 0x64, 0x65, 0x6e,
	0x61, 0x2f, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2f, 0x73, 0x75, 0x73, 0x70, 0x69, 0x63, 0x69,
	0x6f, 0x75, 0x73, 0x5f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x23, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2f, 0x71, 0x61,
	0x64, 0x65, 0x6e, 0x61, 0x2f, 0x70, 0x65, 0x64, 0x65, 0x72, 0x73, 0x65, 0x6e, 0x5f, 0x63, 0x6f,
	0x6d, 0x6d, 0x69, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1d, 0x71, 0x61, 0x64, 0x65,
	0x6e, 0x61, 0x2f, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2f, 0x62, 0x69, 0x6e, 0x64, 0x5f, 0x64,
	0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1f, 0x71, 0x61, 0x64, 0x65, 0x6e,
	0x61, 0x2f, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2f, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x5f, 0x70,
	0x72, 0x6f, 0x6f, 0x66, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x25, 0x71, 0x61, 0x64, 0x65,
	0x6e, 0x61, 0x2f, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2f, 0x62, 0x5f, 0x70, 0x65, 0x64, 0x65,
	0x72, 0x73, 0x65, 0x6e, 0x5f, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x1a, 0x25, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2f, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61,
	0x2f, 0x76, 0x5f, 0x73, 0x68, 0x61, 0x72, 0x65, 0x5f, 0x62, 0x69, 0x6e, 0x64, 0x5f, 0x64, 0x61,
	0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x19, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61,
	0x2f, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2f, 0x73, 0x68, 0x61, 0x72, 0x65, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x1a, 0x27, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2f, 0x71, 0x61, 0x64, 0x65,
	0x6e, 0x61, 0x2f, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x5f, 0x73, 0x68, 0x61, 0x72, 0x65, 0x5f,
	0x70, 0x72, 0x69, 0x76, 0x5f, 0x6b, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x21, 0x71, 0x61,
	0x64, 0x65, 0x6e, 0x61, 0x2f, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2f, 0x72, 0x65, 0x63, 0x6f,
	0x76, 0x65, 0x72, 0x5f, 0x73, 0x68, 0x61, 0x72, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a,
	0x23, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2f, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2f, 0x62,
	0x75, 0x6c, 0x6b, 0x5f, 0x63, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1a, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2f, 0x71, 0x61, 0x64,
	0x65, 0x6e, 0x61, 0x2f, 0x62, 0x69, 0x67, 0x69, 0x6e, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75,
	0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x22, 0x29, 0x0a, 0x11, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65,
	0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x12, 0x14, 0x0a, 0x05, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x22, 0xfb, 0x05, 0x0a,
	0x24, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x43, 0x6c, 0x61, 0x69,
	0x6d, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x45, 0x78, 0x74, 0x72, 0x61,
	0x50, 0x61, 0x72, 0x6d, 0x73, 0x12, 0x38, 0x0a, 0x17, 0x45, 0x6e, 0x63, 0x43, 0x72, 0x65, 0x64,
	0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x49, 0x6e, 0x66, 0x6f, 0x56, 0x53, 0x68, 0x61, 0x72, 0x65,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x17, 0x45, 0x6e, 0x63, 0x43, 0x72, 0x65, 0x64, 0x65,
	0x6e, 0x74, 0x69, 0x61, 0x6c, 0x49, 0x6e, 0x66, 0x6f, 0x56, 0x53, 0x68, 0x61, 0x72, 0x65, 0x12,
	0x59, 0x0a, 0x18, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x49, 0x6e, 0x66,
	0x6f, 0x56, 0x53, 0x68, 0x61, 0x72, 0x65, 0x42, 0x69, 0x6e, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1d, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e,
	0x61, 0x2e, 0x56, 0x53, 0x68, 0x61, 0x72, 0x65, 0x42, 0x69, 0x6e, 0x64, 0x44, 0x61, 0x74, 0x61,
	0x52, 0x18, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x49, 0x6e, 0x66, 0x6f,
	0x56, 0x53, 0x68, 0x61, 0x72, 0x65, 0x42, 0x69, 0x6e, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x57, 0x61,
	0x6c, 0x6c, 0x65, 0x74, 0x49, 0x44, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x57, 0x61,
	0x6c, 0x6c, 0x65, 0x74, 0x49, 0x44, 0x12, 0x4a, 0x0a, 0x10, 0x46, 0x69, 0x6e, 0x64, 0x43, 0x72,
	0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x50, 0x43, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x1e, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61,
	0x2e, 0x42, 0x50, 0x65, 0x64, 0x65, 0x72, 0x73, 0x65, 0x6e, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74,
	0x52, 0x10, 0x46, 0x69, 0x6e, 0x64, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c,
	0x50, 0x43, 0x12, 0x48, 0x0a, 0x0f, 0x4e, 0x65, 0x77, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74,
	0x69, 0x61, 0x6c, 0x50, 0x43, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x71, 0x61,
	0x64, 0x65, 0x6e, 0x61, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x42, 0x50, 0x65, 0x64,
	0x65, 0x72, 0x73, 0x65, 0x6e, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x52, 0x0f, 0x4e, 0x65, 0x77,
	0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x50, 0x43, 0x12, 0x2c, 0x0a, 0x11,
	0x45, 0x6e, 0x63, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x49, 0x44, 0x56, 0x53, 0x68, 0x61, 0x72,
	0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x11, 0x45, 0x6e, 0x63, 0x57, 0x61, 0x6c, 0x6c,
	0x65, 0x74, 0x49, 0x44, 0x56, 0x53, 0x68, 0x61, 0x72, 0x65, 0x12, 0x4d, 0x0a, 0x12, 0x57, 0x61,
	0x6c, 0x6c, 0x65, 0x74, 0x49, 0x44, 0x56, 0x53, 0x68, 0x61, 0x72, 0x65, 0x42, 0x69, 0x6e, 0x64,
	0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e,
	0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x56, 0x53, 0x68, 0x61, 0x72, 0x65, 0x42, 0x69, 0x6e,
	0x64, 0x44, 0x61, 0x74, 0x61, 0x52, 0x12, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x49, 0x44, 0x56,
	0x53, 0x68, 0x61, 0x72, 0x65, 0x42, 0x69, 0x6e, 0x64, 0x12, 0x38, 0x0a, 0x17, 0x45, 0x6e, 0x63,
	0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x48, 0x61, 0x73, 0x68, 0x56, 0x53,
	0x68, 0x61, 0x72, 0x65, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x17, 0x45, 0x6e, 0x63, 0x43,
	0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x48, 0x61, 0x73, 0x68, 0x56, 0x53, 0x68,
	0x61, 0x72, 0x65, 0x12, 0x59, 0x0a, 0x18, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61,
	0x6c, 0x48, 0x61, 0x73, 0x68, 0x56, 0x53, 0x68, 0x61, 0x72, 0x65, 0x42, 0x69, 0x6e, 0x64, 0x18,
	0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x71,
	0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x56, 0x53, 0x68, 0x61, 0x72, 0x65, 0x42, 0x69, 0x6e, 0x64,
	0x44, 0x61, 0x74, 0x61, 0x52, 0x18, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c,
	0x48, 0x61, 0x73, 0x68, 0x56, 0x53, 0x68, 0x61, 0x72, 0x65, 0x42, 0x69, 0x6e, 0x64, 0x12, 0x40,
	0x0a, 0x06, 0x5a, 0x65, 0x72, 0x6f, 0x50, 0x43, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x28,
	0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x45,
	0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x50, 0x65, 0x64, 0x65, 0x72, 0x73,
	0x65, 0x6e, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x52, 0x06, 0x5a, 0x65, 0x72, 0x6f, 0x50, 0x43,
	0x12, 0x38, 0x0a, 0x07, 0x43, 0x6c, 0x61, 0x69, 0x6d, 0x50, 0x43, 0x18, 0x0b, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1e, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e,
	0x61, 0x2e, 0x42, 0x50, 0x65, 0x64, 0x65, 0x72, 0x73, 0x65, 0x6e, 0x43, 0x6f, 0x6d, 0x6d, 0x69,
	0x74, 0x52, 0x07, 0x43, 0x6c, 0x61, 0x69, 0x6d, 0x50, 0x43, 0x22, 0x52, 0x0a, 0x1e, 0x45, 0x6e,
	0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69,
	0x7a, 0x65, 0x64, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x6f, 0x72, 0x79, 0x12, 0x14, 0x0a, 0x05,
	0x4e, 0x6f, 0x6e, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x4e, 0x6f, 0x6e,
	0x63, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x49, 0x44, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x49, 0x44, 0x22, 0x64,
	0x0a, 0x14, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x69, 0x67,
	0x6e, 0x61, 0x74, 0x6f, 0x72, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x4e, 0x6f, 0x6e, 0x63, 0x65, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x4e, 0x6f, 0x6e, 0x63, 0x65, 0x12, 0x14, 0x0a, 0x05,
	0x45, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x45, 0x6d, 0x61,
	0x69, 0x6c, 0x12, 0x20, 0x0a, 0x0b, 0x50, 0x68, 0x6f, 0x6e, 0x65, 0x4e, 0x75, 0x6d, 0x62, 0x65,
	0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x50, 0x68, 0x6f, 0x6e, 0x65, 0x4e, 0x75,
	0x6d, 0x62, 0x65, 0x72, 0x22, 0x97, 0x03, 0x0a, 0x17, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74,
	0x61, 0x62, 0x6c, 0x65, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74,
	0x12, 0x14, 0x0a, 0x05, 0x4e, 0x6f, 0x6e, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x05, 0x4e, 0x6f, 0x6e, 0x63, 0x65, 0x12, 0x24, 0x0a, 0x0d, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61,
	0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x44, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x54,
	0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x44, 0x12, 0x50, 0x0a, 0x0e,
	0x50, 0x65, 0x64, 0x65, 0x72, 0x73, 0x65, 0x6e, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x71, 0x61,
	0x64, 0x65, 0x6e, 0x61, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65,
	0x50, 0x65, 0x64, 0x65, 0x72, 0x73, 0x65, 0x6e, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x52, 0x0e,
	0x50, 0x65, 0x64, 0x65, 0x72, 0x73, 0x65, 0x6e, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x12, 0x12,
	0x0a, 0x04, 0x4e, 0x6f, 0x74, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x4e, 0x6f,
	0x74, 0x65, 0x12, 0x2c, 0x0a, 0x11, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x53, 0x65,
	0x6e, 0x64, 0x65, 0x72, 0x50, 0x49, 0x4e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x11, 0x52,
	0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x53, 0x65, 0x6e, 0x64, 0x65, 0x72, 0x50, 0x49, 0x4e,
	0x12, 0x38, 0x0a, 0x17, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x53, 0x65, 0x6e, 0x64,
	0x65, 0x72, 0x46, 0x69, 0x72, 0x73, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x17, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x53, 0x65, 0x6e, 0x64, 0x65,
	0x72, 0x46, 0x69, 0x72, 0x73, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x3a, 0x0a, 0x18, 0x52, 0x65,
	0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x53, 0x65, 0x6e, 0x64, 0x65, 0x72, 0x4d, 0x69, 0x64, 0x64,
	0x6c, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x18, 0x52, 0x65,
	0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x53, 0x65, 0x6e, 0x64, 0x65, 0x72, 0x4d, 0x69, 0x64, 0x64,
	0x6c, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x36, 0x0a, 0x16, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72,
	0x65, 0x64, 0x53, 0x65, 0x6e, 0x64, 0x65, 0x72, 0x4c, 0x61, 0x73, 0x74, 0x4e, 0x61, 0x6d, 0x65,
	0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x52, 0x16, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64,
	0x53, 0x65, 0x6e, 0x64, 0x65, 0x72, 0x4c, 0x61, 0x73, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x22, 0xf0,
	0x01, 0x0a, 0x1e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x50, 0x65,
	0x72, 0x73, 0x6f, 0x6e, 0x61, 0x6c, 0x49, 0x6e, 0x66, 0x6f, 0x44, 0x65, 0x74, 0x61, 0x69, 0x6c,
	0x73, 0x12, 0x1c, 0x0a, 0x09, 0x46, 0x69, 0x72, 0x73, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x46, 0x69, 0x72, 0x73, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x12,
	0x1e, 0x0a, 0x0a, 0x4d, 0x69, 0x64, 0x64, 0x6c, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x0a, 0x4d, 0x69, 0x64, 0x64, 0x6c, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x12,
	0x1a, 0x0a, 0x08, 0x4c, 0x61, 0x73, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x08, 0x4c, 0x61, 0x73, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x42,
	0x69, 0x72, 0x74, 0x68, 0x64, 0x61, 0x74, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09,
	0x42, 0x69, 0x72, 0x74, 0x68, 0x64, 0x61, 0x74, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x43, 0x69, 0x74,
	0x69, 0x7a, 0x65, 0x6e, 0x73, 0x68, 0x69, 0x70, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b,
	0x43, 0x69, 0x74, 0x69, 0x7a, 0x65, 0x6e, 0x73, 0x68, 0x69, 0x70, 0x12, 0x1c, 0x0a, 0x09, 0x52,
	0x65, 0x73, 0x69, 0x64, 0x65, 0x6e, 0x63, 0x79, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09,
	0x52, 0x65, 0x73, 0x69, 0x64, 0x65, 0x6e, 0x63, 0x79, 0x12, 0x16, 0x0a, 0x06, 0x47, 0x65, 0x6e,
	0x64, 0x65, 0x72, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x47, 0x65, 0x6e, 0x64, 0x65,
	0x72, 0x22, 0x8a, 0x01, 0x0a, 0x17, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c,
	0x65, 0x50, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x61, 0x6c, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x14, 0x0a,
	0x05, 0x4e, 0x6f, 0x6e, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x4e, 0x6f,
	0x6e, 0x63, 0x65, 0x12, 0x10, 0x0a, 0x03, 0x50, 0x49, 0x4e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x03, 0x50, 0x49, 0x4e, 0x12, 0x47, 0x0a, 0x07, 0x44, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e,
	0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62,
	0x6c, 0x65, 0x50, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x61, 0x6c, 0x49, 0x6e, 0x66, 0x6f, 0x44, 0x65,
	0x74, 0x61, 0x69, 0x6c, 0x73, 0x52, 0x07, 0x44, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x22, 0x3f,
	0x0a, 0x23, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x69, 0x6e,
	0x67, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x63, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x44, 0x65,
	0x74, 0x61, 0x69, 0x6c, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x63, 0x74,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x63, 0x74, 0x22,
	0x94, 0x01, 0x0a, 0x1c, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x53,
	0x69, 0x6e, 0x67, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x63, 0x74, 0x49, 0x6e, 0x66, 0x6f,
	0x12, 0x14, 0x0a, 0x05, 0x4e, 0x6f, 0x6e, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x05, 0x4e, 0x6f, 0x6e, 0x63, 0x65, 0x12, 0x10, 0x0a, 0x03, 0x50, 0x49, 0x4e, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x03, 0x50, 0x49, 0x4e, 0x12, 0x4c, 0x0a, 0x07, 0x44, 0x65, 0x74, 0x61,
	0x69, 0x6c, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x32, 0x2e, 0x71, 0x61, 0x64, 0x65,
	0x6e, 0x61, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70,
	0x74, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x69, 0x6e, 0x67, 0x6c, 0x65, 0x43, 0x6f, 0x6e, 0x74, 0x61,
	0x63, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x44, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x52, 0x07, 0x44,
	0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x22, 0x9e, 0x01, 0x0a, 0x1e, 0x45, 0x6e, 0x63, 0x72, 0x79,
	0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x64, 0x43,
	0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x12, 0x26, 0x0a, 0x0e, 0x43, 0x72, 0x65,
	0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x0e, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x54, 0x79, 0x70,
	0x65, 0x12, 0x10, 0x0a, 0x03, 0x50, 0x49, 0x4e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03,
	0x50, 0x49, 0x4e, 0x12, 0x42, 0x0a, 0x0c, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61,
	0x6c, 0x50, 0x43, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x71, 0x61, 0x64, 0x65,
	0x6e, 0x61, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x42, 0x50, 0x65, 0x64, 0x65, 0x72,
	0x73, 0x65, 0x6e, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x52, 0x0c, 0x43, 0x72, 0x65, 0x64, 0x65,
	0x6e, 0x74, 0x69, 0x61, 0x6c, 0x50, 0x43, 0x22, 0x72, 0x0a, 0x1f, 0x45, 0x6e, 0x63, 0x72, 0x79,
	0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x64, 0x43,
	0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73, 0x12, 0x4f, 0x0a, 0x0b, 0x43, 0x72,
	0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x2d, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e,
	0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x56, 0x61, 0x6c, 0x69, 0x64,
	0x61, 0x74, 0x65, 0x64, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x52, 0x0b,
	0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73, 0x22, 0x66, 0x0a, 0x2a, 0x45,
	0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65,
	0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x45, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x49, 0x44, 0x45,
	0x78, 0x74, 0x72, 0x61, 0x50, 0x61, 0x72, 0x6d, 0x73, 0x12, 0x38, 0x0a, 0x07, 0x50, 0x72, 0x6f,
	0x6f, 0x66, 0x50, 0x43, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x71, 0x61, 0x64,
	0x65, 0x6e, 0x61, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x42, 0x50, 0x65, 0x64, 0x65,
	0x72, 0x73, 0x65, 0x6e, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x52, 0x07, 0x50, 0x72, 0x6f, 0x6f,
	0x66, 0x50, 0x43, 0x22, 0xaf, 0x01, 0x0a, 0x20, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61,
	0x62, 0x6c, 0x65, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x45,
	0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x49, 0x44, 0x12, 0x14, 0x0a, 0x05, 0x4e, 0x6f, 0x6e, 0x63,
	0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x4e, 0x6f, 0x6e, 0x63, 0x65, 0x12, 0x1a,
	0x0a, 0x08, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x49, 0x44, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x08, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x49, 0x44, 0x12, 0x59, 0x0a, 0x0a, 0x45, 0x78,
	0x74, 0x72, 0x61, 0x50, 0x61, 0x72, 0x6d, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x39,
	0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x45,
	0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65,
	0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x45, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x49, 0x44, 0x45,
	0x78, 0x74, 0x72, 0x61, 0x50, 0x61, 0x72, 0x6d, 0x73, 0x52, 0x0a, 0x45, 0x78, 0x74, 0x72, 0x61,
	0x50, 0x61, 0x72, 0x6d, 0x73, 0x22, 0x6e, 0x0a, 0x17, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74,
	0x61, 0x62, 0x6c, 0x65, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74,
	0x12, 0x53, 0x0a, 0x0c, 0x44, 0x73, 0x74, 0x45, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x49, 0x44,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e,
	0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62,
	0x6c, 0x65, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x45, 0x57,
	0x61, 0x6c, 0x6c, 0x65, 0x74, 0x49, 0x44, 0x52, 0x0c, 0x44, 0x73, 0x74, 0x45, 0x57, 0x61, 0x6c,
	0x6c, 0x65, 0x74, 0x49, 0x44, 0x22, 0x8b, 0x07, 0x0a, 0x2b, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70,
	0x74, 0x61, 0x62, 0x6c, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x46, 0x75, 0x6e,
	0x64, 0x73, 0x45, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x49, 0x44, 0x45, 0x78, 0x74, 0x72, 0x61,
	0x50, 0x61, 0x72, 0x6d, 0x73, 0x12, 0x4a, 0x0a, 0x10, 0x41, 0x63, 0x63, 0x65, 0x70, 0x74, 0x50,
	0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x50, 0x43, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1e, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e,
	0x42, 0x50, 0x65, 0x64, 0x65, 0x72, 0x73, 0x65, 0x6e, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x52,
	0x10, 0x41, 0x63, 0x63, 0x65, 0x70, 0x74, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x50,
	0x43, 0x12, 0x34, 0x0a, 0x15, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x46, 0x69, 0x72, 0x73, 0x74, 0x4e,
	0x61, 0x6d, 0x65, 0x48, 0x61, 0x73, 0x68, 0x48, 0x65, 0x78, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c,
	0x52, 0x15, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x46, 0x69, 0x72, 0x73, 0x74, 0x4e, 0x61, 0x6d, 0x65,
	0x48, 0x61, 0x73, 0x68, 0x48, 0x65, 0x78, 0x12, 0x36, 0x0a, 0x16, 0x4d, 0x61, 0x74, 0x63, 0x68,
	0x4d, 0x69, 0x64, 0x64, 0x6c, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x48, 0x61, 0x73, 0x68, 0x48, 0x65,
	0x78, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x16, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x4d, 0x69,
	0x64, 0x64, 0x6c, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x48, 0x61, 0x73, 0x68, 0x48, 0x65, 0x78, 0x12,
	0x32, 0x0a, 0x14, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x4c, 0x61, 0x73, 0x74, 0x4e, 0x61, 0x6d, 0x65,
	0x48, 0x61, 0x73, 0x68, 0x48, 0x65, 0x78, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x14, 0x4d,
	0x61, 0x74, 0x63, 0x68, 0x4c, 0x61, 0x73, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x48, 0x61, 0x73, 0x68,
	0x48, 0x65, 0x78, 0x12, 0x66, 0x0a, 0x1e, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x53,
	0x65, 0x6e, 0x64, 0x65, 0x72, 0x46, 0x69, 0x72, 0x73, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x43, 0x68,
	0x65, 0x63, 0x6b, 0x50, 0x43, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x71, 0x61,
	0x64, 0x65, 0x6e, 0x61, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x42, 0x50, 0x65, 0x64,
	0x65, 0x72, 0x73, 0x65, 0x6e, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x52, 0x1e, 0x52, 0x65, 0x71,
	0x75, 0x69, 0x72, 0x65, 0x64, 0x53, 0x65, 0x6e, 0x64, 0x65, 0x72, 0x46, 0x69, 0x72, 0x73, 0x74,
	0x4e, 0x61, 0x6d, 0x65, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x50, 0x43, 0x12, 0x66, 0x0a, 0x1e, 0x52,
	0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x53, 0x65, 0x6e, 0x64, 0x65, 0x72, 0x46, 0x69, 0x72,
	0x73, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x50, 0x43, 0x18, 0x06, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x71, 0x61, 0x64,
	0x65, 0x6e, 0x61, 0x2e, 0x42, 0x50, 0x65, 0x64, 0x65, 0x72, 0x73, 0x65, 0x6e, 0x43, 0x6f, 0x6d,
	0x6d, 0x69, 0x74, 0x52, 0x1e, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x53, 0x65, 0x6e,
	0x64, 0x65, 0x72, 0x46, 0x69, 0x72, 0x73, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x50, 0x72, 0x6f, 0x6f,
	0x66, 0x50, 0x43, 0x12, 0x68, 0x0a, 0x1f, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x53,
	0x65, 0x6e, 0x64, 0x65, 0x72, 0x4d, 0x69, 0x64, 0x64, 0x6c, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x43,
	0x68, 0x65, 0x63, 0x6b, 0x50, 0x43, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x71,
	0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x42, 0x50, 0x65,
	0x64, 0x65, 0x72, 0x73, 0x65, 0x6e, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x52, 0x1f, 0x52, 0x65,
	0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x53, 0x65, 0x6e, 0x64, 0x65, 0x72, 0x4d, 0x69, 0x64, 0x64,
	0x6c, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x50, 0x43, 0x12, 0x68, 0x0a,
	0x1f, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x53, 0x65, 0x6e, 0x64, 0x65, 0x72, 0x4d,
	0x69, 0x64, 0x64, 0x6c, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x50, 0x43,
	0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e,
	0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x42, 0x50, 0x65, 0x64, 0x65, 0x72, 0x73, 0x65, 0x6e,
	0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x52, 0x1f, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64,
	0x53, 0x65, 0x6e, 0x64, 0x65, 0x72, 0x4d, 0x69, 0x64, 0x64, 0x6c, 0x65, 0x4e, 0x61, 0x6d, 0x65,
	0x50, 0x72, 0x6f, 0x6f, 0x66, 0x50, 0x43, 0x12, 0x64, 0x0a, 0x1d, 0x52, 0x65, 0x71, 0x75, 0x69,
	0x72, 0x65, 0x64, 0x53, 0x65, 0x6e, 0x64, 0x65, 0x72, 0x4c, 0x61, 0x73, 0x74, 0x4e, 0x61, 0x6d,
	0x65, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x50, 0x43, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1e,
	0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x42,
	0x50, 0x65, 0x64, 0x65, 0x72, 0x73, 0x65, 0x6e, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x52, 0x1d,
	0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x53, 0x65, 0x6e, 0x64, 0x65, 0x72, 0x4c, 0x61,
	0x73, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x50, 0x43, 0x12, 0x64, 0x0a,
	0x1d, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x53, 0x65, 0x6e, 0x64, 0x65, 0x72, 0x4c,
	0x61, 0x73, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x50, 0x72, 0x6f, 0x6f, 0x66, 0x50, 0x43, 0x18, 0x0a,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x71, 0x61,
	0x64, 0x65, 0x6e, 0x61, 0x2e, 0x42, 0x50, 0x65, 0x64, 0x65, 0x72, 0x73, 0x65, 0x6e, 0x43, 0x6f,
	0x6d, 0x6d, 0x69, 0x74, 0x52, 0x1d, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x53, 0x65,
	0x6e, 0x64, 0x65, 0x72, 0x4c, 0x61, 0x73, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x50, 0x72, 0x6f, 0x6f,
	0x66, 0x50, 0x43, 0x22, 0xb1, 0x01, 0x0a, 0x21, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61,
	0x62, 0x6c, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x46, 0x75, 0x6e, 0x64, 0x73,
	0x45, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x49, 0x44, 0x12, 0x14, 0x0a, 0x05, 0x4e, 0x6f, 0x6e,
	0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x4e, 0x6f, 0x6e, 0x63, 0x65, 0x12,
	0x1a, 0x0a, 0x08, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x49, 0x44, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x08, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x49, 0x44, 0x12, 0x5a, 0x0a, 0x0a, 0x45,
	0x78, 0x74, 0x72, 0x61, 0x50, 0x61, 0x72, 0x6d, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x3a, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e,
	0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73,
	0x66, 0x65, 0x72, 0x46, 0x75, 0x6e, 0x64, 0x73, 0x45, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x49,
	0x44, 0x45, 0x78, 0x74, 0x72, 0x61, 0x50, 0x61, 0x72, 0x6d, 0x73, 0x52, 0x0a, 0x45, 0x78, 0x74,
	0x72, 0x61, 0x50, 0x61, 0x72, 0x6d, 0x73, 0x22, 0xe8, 0x01, 0x0a, 0x18, 0x45, 0x6e, 0x63, 0x72,
	0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x46,
	0x75, 0x6e, 0x64, 0x73, 0x12, 0x54, 0x0a, 0x10, 0x48, 0x69, 0x64, 0x64, 0x65, 0x6e, 0x54, 0x72,
	0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x50, 0x43, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x28,
	0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x45,
	0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x50, 0x65, 0x64, 0x65, 0x72, 0x73,
	0x65, 0x6e, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x52, 0x10, 0x48, 0x69, 0x64, 0x64, 0x65, 0x6e,
	0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x50, 0x43, 0x12, 0x54, 0x0a, 0x0c, 0x44, 0x73,
	0x74, 0x45, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x49, 0x44, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x30, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61,
	0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x54, 0x72, 0x61, 0x6e,
	0x73, 0x66, 0x65, 0x72, 0x46, 0x75, 0x6e, 0x64, 0x73, 0x45, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74,
	0x49, 0x44, 0x52, 0x0c, 0x44, 0x73, 0x74, 0x45, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x49, 0x44,
	0x12, 0x20, 0x0a, 0x0b, 0x4f, 0x70, 0x74, 0x49, 0x6e, 0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x4f, 0x70, 0x74, 0x49, 0x6e, 0x52, 0x65, 0x61, 0x73,
	0x6f, 0x6e, 0x22, 0x42, 0x0a, 0x2a, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c,
	0x65, 0x52, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x46, 0x75, 0x6e, 0x64, 0x73, 0x45, 0x57, 0x61,
	0x6c, 0x6c, 0x65, 0x74, 0x49, 0x44, 0x45, 0x78, 0x74, 0x72, 0x61, 0x50, 0x61, 0x72, 0x6d, 0x73,
	0x12, 0x14, 0x0a, 0x05, 0x51, 0x75, 0x65, 0x75, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x05, 0x51, 0x75, 0x65, 0x75, 0x65, 0x22, 0xaf, 0x01, 0x0a, 0x20, 0x45, 0x6e, 0x63, 0x72, 0x79,
	0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x52, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x46, 0x75, 0x6e,
	0x64, 0x73, 0x45, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x49, 0x44, 0x12, 0x14, 0x0a, 0x05, 0x4e,
	0x6f, 0x6e, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x4e, 0x6f, 0x6e, 0x63,
	0x65, 0x12, 0x1a, 0x0a, 0x08, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x49, 0x44, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x08, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x49, 0x44, 0x12, 0x59, 0x0a,
	0x0a, 0x45, 0x78, 0x74, 0x72, 0x61, 0x50, 0x61, 0x72, 0x6d, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x39, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e,
	0x61, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x52, 0x65, 0x63,
	0x65, 0x69, 0x76, 0x65, 0x46, 0x75, 0x6e, 0x64, 0x73, 0x45, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74,
	0x49, 0x44, 0x45, 0x78, 0x74, 0x72, 0x61, 0x50, 0x61, 0x72, 0x6d, 0x73, 0x52, 0x0a, 0x45, 0x78,
	0x74, 0x72, 0x61, 0x50, 0x61, 0x72, 0x6d, 0x73, 0x22, 0x56, 0x0a, 0x22, 0x45, 0x6e, 0x63, 0x72,
	0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x69, 0x67, 0x6e, 0x52, 0x65, 0x63, 0x6f, 0x76,
	0x65, 0x72, 0x4b, 0x65, 0x79, 0x45, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x49, 0x44, 0x12, 0x14,
	0x0a, 0x05, 0x4e, 0x6f, 0x6e, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x4e,
	0x6f, 0x6e, 0x63, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x49, 0x44,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x49, 0x44,
	0x22, 0x6e, 0x0a, 0x17, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x52,
	0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x46, 0x75, 0x6e, 0x64, 0x73, 0x12, 0x53, 0x0a, 0x0c, 0x45,
	0x70, 0x68, 0x45, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x2f, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e,
	0x61, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x52, 0x65, 0x63,
	0x65, 0x69, 0x76, 0x65, 0x46, 0x75, 0x6e, 0x64, 0x73, 0x45, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74,
	0x49, 0x44, 0x52, 0x0c, 0x45, 0x70, 0x68, 0x45, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x49, 0x44,
	0x22, 0xc7, 0x01, 0x0a, 0x1c, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65,
	0x41, 0x6e, 0x6f, 0x6e, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x46, 0x75, 0x6e, 0x64,
	0x73, 0x12, 0x5c, 0x0a, 0x14, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66,
	0x65, 0x72, 0x50, 0x72, 0x69, 0x6d, 0x65, 0x50, 0x43, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x28, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e,
	0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x50, 0x65, 0x64, 0x65, 0x72,
	0x73, 0x65, 0x6e, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x52, 0x14, 0x54, 0x6f, 0x74, 0x61, 0x6c,
	0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x50, 0x72, 0x69, 0x6d, 0x65, 0x50, 0x43, 0x12,
	0x49, 0x0a, 0x15, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x54, 0x72,
	0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x42, 0x46, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x13,
	0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x42,
	0x49, 0x6e, 0x74, 0x52, 0x15, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74,
	0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x42, 0x46, 0x22, 0xb0, 0x01, 0x0a, 0x1c, 0x45,
	0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x45, 0x53, 0x75, 0x73, 0x70, 0x69,
	0x63, 0x69, 0x6f, 0x75, 0x73, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x4e,
	0x6f, 0x6e, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x4e, 0x6f, 0x6e, 0x63,
	0x65, 0x12, 0x3f, 0x0a, 0x0d, 0x55, 0x53, 0x44, 0x43, 0x6f, 0x69, 0x6e, 0x41, 0x6d, 0x6f, 0x75,
	0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f,
	0x73, 0x2e, 0x62, 0x61, 0x73, 0x65, 0x2e, 0x76, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0x2e, 0x43,
	0x6f, 0x69, 0x6e, 0x52, 0x0d, 0x55, 0x53, 0x44, 0x43, 0x6f, 0x69, 0x6e, 0x41, 0x6d, 0x6f, 0x75,
	0x6e, 0x74, 0x12, 0x39, 0x0a, 0x0a, 0x43, 0x6f, 0x69, 0x6e, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x2e,
	0x62, 0x61, 0x73, 0x65, 0x2e, 0x76, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0x2e, 0x43, 0x6f, 0x69,
	0x6e, 0x52, 0x0a, 0x43, 0x6f, 0x69, 0x6e, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x22, 0x5b, 0x0a,
	0x17, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x53, 0x49, 0x44,
	0x41, 0x6e, 0x64, 0x50, 0x72, 0x69, 0x76, 0x4b, 0x12, 0x16, 0x0a, 0x06, 0x50, 0x75, 0x62, 0x4b,
	0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x50, 0x75, 0x62, 0x4b, 0x49, 0x44,
	0x12, 0x12, 0x0a, 0x04, 0x50, 0x75, 0x62, 0x4b, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,
	0x50, 0x75, 0x62, 0x4b, 0x12, 0x14, 0x0a, 0x05, 0x50, 0x72, 0x69, 0x76, 0x4b, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x05, 0x50, 0x72, 0x69, 0x76, 0x4b, 0x22, 0x37, 0x0a, 0x15, 0x45, 0x6e,
	0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x50, 0x69, 0x6f, 0x6e, 0x65, 0x65, 0x72,
	0x49, 0x44, 0x73, 0x12, 0x1e, 0x0a, 0x0a, 0x50, 0x69, 0x6f, 0x6e, 0x65, 0x65, 0x72, 0x49, 0x44,
	0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0a, 0x50, 0x69, 0x6f, 0x6e, 0x65, 0x65, 0x72,
	0x49, 0x44, 0x73, 0x22, 0xd8, 0x01, 0x0a, 0x1c, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61,
	0x62, 0x6c, 0x65, 0x45, 0x6e, 0x63, 0x6c, 0x61, 0x76, 0x65, 0x53, 0x53, 0x4f, 0x77, 0x6e, 0x65,
	0x72, 0x4d, 0x61, 0x70, 0x12, 0x55, 0x0a, 0x08, 0x50, 0x69, 0x6f, 0x6e, 0x65, 0x65, 0x72, 0x73,
	0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x39, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e,
	0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62,
	0x6c, 0x65, 0x45, 0x6e, 0x63, 0x6c, 0x61, 0x76, 0x65, 0x53, 0x53, 0x4f, 0x77, 0x6e, 0x65, 0x72,
	0x4d, 0x61, 0x70, 0x2e, 0x50, 0x69, 0x6f, 0x6e, 0x65, 0x65, 0x72, 0x73, 0x45, 0x6e, 0x74, 0x72,
	0x79, 0x52, 0x08, 0x50, 0x69, 0x6f, 0x6e, 0x65, 0x65, 0x72, 0x73, 0x1a, 0x61, 0x0a, 0x0d, 0x50,
	0x69, 0x6f, 0x6e, 0x65, 0x65, 0x72, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03,
	0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x3a,
	0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e,
	0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x45, 0x6e,
	0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x50, 0x69, 0x6f, 0x6e, 0x65, 0x65, 0x72,
	0x49, 0x44, 0x73, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0xaa,
	0x01, 0x0a, 0x1e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x45, 0x6e,
	0x63, 0x6c, 0x61, 0x76, 0x65, 0x50, 0x75, 0x62, 0x4b, 0x43, 0x61, 0x63, 0x68, 0x65, 0x4d, 0x61,
	0x70, 0x12, 0x4e, 0x0a, 0x05, 0x50, 0x75, 0x62, 0x4b, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x38, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61,
	0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x45, 0x6e, 0x63, 0x6c,
	0x61, 0x76, 0x65, 0x50, 0x75, 0x62, 0x4b, 0x43, 0x61, 0x63, 0x68, 0x65, 0x4d, 0x61, 0x70, 0x2e,
	0x50, 0x75, 0x62, 0x4b, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x05, 0x50, 0x75, 0x62, 0x4b,
	0x73, 0x1a, 0x38, 0x0a, 0x0a, 0x50, 0x75, 0x62, 0x4b, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12,
	0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65,
	0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0xee, 0x03, 0x0a, 0x1e,
	0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x68, 0x61, 0x72, 0x65,
	0x64, 0x45, 0x6e, 0x63, 0x6c, 0x61, 0x76, 0x65, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x12, 0x14,
	0x0a, 0x05, 0x4a, 0x61, 0x72, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x4a,
	0x61, 0x72, 0x49, 0x44, 0x12, 0x24, 0x0a, 0x0d, 0x4a, 0x61, 0x72, 0x41, 0x72, 0x6d, 0x6f, 0x72,
	0x50, 0x72, 0x69, 0x76, 0x4b, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x4a, 0x61, 0x72,
	0x41, 0x72, 0x6d, 0x6f, 0x72, 0x50, 0x72, 0x69, 0x76, 0x4b, 0x12, 0x1a, 0x0a, 0x08, 0x4a, 0x61,
	0x72, 0x50, 0x72, 0x69, 0x76, 0x4b, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x4a, 0x61,
	0x72, 0x50, 0x72, 0x69, 0x76, 0x4b, 0x12, 0x18, 0x0a, 0x07, 0x4a, 0x61, 0x72, 0x50, 0x75, 0x62,
	0x4b, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x4a, 0x61, 0x72, 0x50, 0x75, 0x62, 0x4b,
	0x12, 0x20, 0x0a, 0x0b, 0x52, 0x65, 0x67, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x49, 0x44, 0x18,
	0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x52, 0x65, 0x67, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72,
	0x49, 0x44, 0x12, 0x30, 0x0a, 0x13, 0x52, 0x65, 0x67, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x41,
	0x72, 0x6d, 0x6f, 0x72, 0x50, 0x72, 0x69, 0x76, 0x4b, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x13, 0x52, 0x65, 0x67, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x41, 0x72, 0x6d, 0x6f, 0x72, 0x50,
	0x72, 0x69, 0x76, 0x4b, 0x12, 0x26, 0x0a, 0x0e, 0x52, 0x65, 0x67, 0x75, 0x6c, 0x61, 0x74, 0x6f,
	0x72, 0x50, 0x72, 0x69, 0x76, 0x4b, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x52, 0x65,
	0x67, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x50, 0x72, 0x69, 0x76, 0x4b, 0x12, 0x24, 0x0a, 0x0d,
	0x52, 0x65, 0x67, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x50, 0x75, 0x62, 0x4b, 0x18, 0x08, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x0d, 0x52, 0x65, 0x67, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x50, 0x75,
	0x62, 0x4b, 0x12, 0x57, 0x0a, 0x10, 0x53, 0x53, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c,
	0x4f, 0x77, 0x6e, 0x65, 0x72, 0x73, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2b, 0x2e, 0x71,
	0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x45, 0x6e, 0x63,
	0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x45, 0x6e, 0x63, 0x6c, 0x61, 0x76, 0x65, 0x53,
	0x53, 0x4f, 0x77, 0x6e, 0x65, 0x72, 0x4d, 0x61, 0x70, 0x52, 0x10, 0x53, 0x53, 0x49, 0x6e, 0x74,
	0x65, 0x72, 0x76, 0x61, 0x6c, 0x4f, 0x77, 0x6e, 0x65, 0x72, 0x73, 0x12, 0x5f, 0x0a, 0x13, 0x53,
	0x53, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x50, 0x75, 0x62, 0x4b, 0x43, 0x61, 0x63,
	0x68, 0x65, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e,
	0x61, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74,
	0x61, 0x62, 0x6c, 0x65, 0x45, 0x6e, 0x63, 0x6c, 0x61, 0x76, 0x65, 0x50, 0x75, 0x62, 0x4b, 0x43,
	0x61, 0x63, 0x68, 0x65, 0x4d, 0x61, 0x70, 0x52, 0x13, 0x53, 0x53, 0x49, 0x6e, 0x74, 0x65, 0x72,
	0x76, 0x61, 0x6c, 0x50, 0x75, 0x62, 0x4b, 0x43, 0x61, 0x63, 0x68, 0x65, 0x42, 0x9a, 0x01, 0x0a,
	0x11, 0x63, 0x6f, 0x6d, 0x2e, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x71, 0x61, 0x64, 0x65,
	0x6e, 0x61, 0x42, 0x10, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x50,
	0x72, 0x6f, 0x74, 0x6f, 0x50, 0x01, 0x5a, 0x1e, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64,
	0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x2f,
	0x71, 0x61, 0x64, 0x65, 0x6e, 0x61, 0xa2, 0x02, 0x03, 0x51, 0x51, 0x58, 0xaa, 0x02, 0x0d, 0x51,
	0x61, 0x64, 0x65, 0x6e, 0x61, 0x2e, 0x51, 0x61, 0x64, 0x65, 0x6e, 0x61, 0xca, 0x02, 0x0d, 0x51,
	0x61, 0x64, 0x65, 0x6e, 0x61, 0x5c, 0x51, 0x61, 0x64, 0x65, 0x6e, 0x61, 0xe2, 0x02, 0x19, 0x51,
	0x61, 0x64, 0x65, 0x6e, 0x61, 0x5c, 0x51, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x5c, 0x47, 0x50, 0x42,
	0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0xea, 0x02, 0x0e, 0x51, 0x61, 0x64, 0x65, 0x6e,
	0x61, 0x3a, 0x3a, 0x51, 0x61, 0x64, 0x65, 0x6e, 0x61, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x33,
}

var (
	file_qadena_qadena_encryptable_proto_rawDescOnce sync.Once
	file_qadena_qadena_encryptable_proto_rawDescData = file_qadena_qadena_encryptable_proto_rawDesc
)

func file_qadena_qadena_encryptable_proto_rawDescGZIP() []byte {
	file_qadena_qadena_encryptable_proto_rawDescOnce.Do(func() {
		file_qadena_qadena_encryptable_proto_rawDescData = protoimpl.X.CompressGZIP(file_qadena_qadena_encryptable_proto_rawDescData)
	})
	return file_qadena_qadena_encryptable_proto_rawDescData
}

var file_qadena_qadena_encryptable_proto_msgTypes = make([]protoimpl.MessageInfo, 30)
var file_qadena_qadena_encryptable_proto_goTypes = []interface{}{
	(*EncryptableString)(nil),                           // 0: qadena.qadena.EncryptableString
	(*EncryptableClaimCredentialExtraParms)(nil),        // 1: qadena.qadena.EncryptableClaimCredentialExtraParms
	(*EncryptableAuthorizedSignatory)(nil),              // 2: qadena.qadena.EncryptableAuthorizedSignatory
	(*EncryptableSignatory)(nil),                        // 3: qadena.qadena.EncryptableSignatory
	(*EncryptableWalletAmount)(nil),                     // 4: qadena.qadena.EncryptableWalletAmount
	(*EncryptablePersonalInfoDetails)(nil),              // 5: qadena.qadena.EncryptablePersonalInfoDetails
	(*EncryptablePersonalInfo)(nil),                     // 6: qadena.qadena.EncryptablePersonalInfo
	(*EncryptableSingleContactInfoDetails)(nil),         // 7: qadena.qadena.EncryptableSingleContactInfoDetails
	(*EncryptableSingleContactInfo)(nil),                // 8: qadena.qadena.EncryptableSingleContactInfo
	(*EncryptableValidatedCredential)(nil),              // 9: qadena.qadena.EncryptableValidatedCredential
	(*EncryptableValidatedCredentials)(nil),             // 10: qadena.qadena.EncryptableValidatedCredentials
	(*EncryptableCreateWalletEWalletIDExtraParms)(nil),  // 11: qadena.qadena.EncryptableCreateWalletEWalletIDExtraParms
	(*EncryptableCreateWalletEWalletID)(nil),            // 12: qadena.qadena.EncryptableCreateWalletEWalletID
	(*EncryptableCreateWallet)(nil),                     // 13: qadena.qadena.EncryptableCreateWallet
	(*EncryptableTransferFundsEWalletIDExtraParms)(nil), // 14: qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms
	(*EncryptableTransferFundsEWalletID)(nil),           // 15: qadena.qadena.EncryptableTransferFundsEWalletID
	(*EncryptableTransferFunds)(nil),                    // 16: qadena.qadena.EncryptableTransferFunds
	(*EncryptableReceiveFundsEWalletIDExtraParms)(nil),  // 17: qadena.qadena.EncryptableReceiveFundsEWalletIDExtraParms
	(*EncryptableReceiveFundsEWalletID)(nil),            // 18: qadena.qadena.EncryptableReceiveFundsEWalletID
	(*EncryptableSignRecoverKeyEWalletID)(nil),          // 19: qadena.qadena.EncryptableSignRecoverKeyEWalletID
	(*EncryptableReceiveFunds)(nil),                     // 20: qadena.qadena.EncryptableReceiveFunds
	(*EncryptableAnonTransferFunds)(nil),                // 21: qadena.qadena.EncryptableAnonTransferFunds
	(*EncryptableESuspiciousAmount)(nil),                // 22: qadena.qadena.EncryptableESuspiciousAmount
	(*EncryptableSSIDAndPrivK)(nil),                     // 23: qadena.qadena.EncryptableSSIDAndPrivK
	(*EncryptablePioneerIDs)(nil),                       // 24: qadena.qadena.EncryptablePioneerIDs
	(*EncryptableEnclaveSSOwnerMap)(nil),                // 25: qadena.qadena.EncryptableEnclaveSSOwnerMap
	(*EncryptableEnclavePubKCacheMap)(nil),              // 26: qadena.qadena.EncryptableEnclavePubKCacheMap
	(*EncryptableSharedEnclaveParams)(nil),              // 27: qadena.qadena.EncryptableSharedEnclaveParams
	nil,                                                 // 28: qadena.qadena.EncryptableEnclaveSSOwnerMap.PioneersEntry
	nil,                                                 // 29: qadena.qadena.EncryptableEnclavePubKCacheMap.PubKsEntry
	(*VShareBindData)(nil),                              // 30: qadena.qadena.VShareBindData
	(*BPedersenCommit)(nil),                             // 31: qadena.qadena.BPedersenCommit
	(*EncryptablePedersenCommit)(nil),                   // 32: qadena.qadena.EncryptablePedersenCommit
	(*BInt)(nil),                                        // 33: qadena.qadena.BInt
	(*v1beta1.Coin)(nil),                                // 34: cosmos.base.v1beta1.Coin
}
var file_qadena_qadena_encryptable_proto_depIdxs = []int32{
	30, // 0: qadena.qadena.EncryptableClaimCredentialExtraParms.CredentialInfoVShareBind:type_name -> qadena.qadena.VShareBindData
	31, // 1: qadena.qadena.EncryptableClaimCredentialExtraParms.FindCredentialPC:type_name -> qadena.qadena.BPedersenCommit
	31, // 2: qadena.qadena.EncryptableClaimCredentialExtraParms.NewCredentialPC:type_name -> qadena.qadena.BPedersenCommit
	30, // 3: qadena.qadena.EncryptableClaimCredentialExtraParms.WalletIDVShareBind:type_name -> qadena.qadena.VShareBindData
	30, // 4: qadena.qadena.EncryptableClaimCredentialExtraParms.CredentialHashVShareBind:type_name -> qadena.qadena.VShareBindData
	32, // 5: qadena.qadena.EncryptableClaimCredentialExtraParms.ZeroPC:type_name -> qadena.qadena.EncryptablePedersenCommit
	31, // 6: qadena.qadena.EncryptableClaimCredentialExtraParms.ClaimPC:type_name -> qadena.qadena.BPedersenCommit
	32, // 7: qadena.qadena.EncryptableWalletAmount.PedersenCommit:type_name -> qadena.qadena.EncryptablePedersenCommit
	5,  // 8: qadena.qadena.EncryptablePersonalInfo.Details:type_name -> qadena.qadena.EncryptablePersonalInfoDetails
	7,  // 9: qadena.qadena.EncryptableSingleContactInfo.Details:type_name -> qadena.qadena.EncryptableSingleContactInfoDetails
	31, // 10: qadena.qadena.EncryptableValidatedCredential.CredentialPC:type_name -> qadena.qadena.BPedersenCommit
	9,  // 11: qadena.qadena.EncryptableValidatedCredentials.Credentials:type_name -> qadena.qadena.EncryptableValidatedCredential
	31, // 12: qadena.qadena.EncryptableCreateWalletEWalletIDExtraParms.ProofPC:type_name -> qadena.qadena.BPedersenCommit
	11, // 13: qadena.qadena.EncryptableCreateWalletEWalletID.ExtraParms:type_name -> qadena.qadena.EncryptableCreateWalletEWalletIDExtraParms
	12, // 14: qadena.qadena.EncryptableCreateWallet.DstEWalletID:type_name -> qadena.qadena.EncryptableCreateWalletEWalletID
	31, // 15: qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.AcceptPasswordPC:type_name -> qadena.qadena.BPedersenCommit
	31, // 16: qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderFirstNameCheckPC:type_name -> qadena.qadena.BPedersenCommit
	31, // 17: qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderFirstNameProofPC:type_name -> qadena.qadena.BPedersenCommit
	31, // 18: qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderMiddleNameCheckPC:type_name -> qadena.qadena.BPedersenCommit
	31, // 19: qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderMiddleNameProofPC:type_name -> qadena.qadena.BPedersenCommit
	31, // 20: qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderLastNameCheckPC:type_name -> qadena.qadena.BPedersenCommit
	31, // 21: qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms.RequiredSenderLastNameProofPC:type_name -> qadena.qadena.BPedersenCommit
	14, // 22: qadena.qadena.EncryptableTransferFundsEWalletID.ExtraParms:type_name -> qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms
	32, // 23: qadena.qadena.EncryptableTransferFunds.HiddenTransferPC:type_name -> qadena.qadena.EncryptablePedersenCommit
	15, // 24: qadena.qadena.EncryptableTransferFunds.DstEWalletID:type_name -> qadena.qadena.EncryptableTransferFundsEWalletID
	17, // 25: qadena.qadena.EncryptableReceiveFundsEWalletID.ExtraParms:type_name -> qadena.qadena.EncryptableReceiveFundsEWalletIDExtraParms
	18, // 26: qadena.qadena.EncryptableReceiveFunds.EphEWalletID:type_name -> qadena.qadena.EncryptableReceiveFundsEWalletID
	32, // 27: qadena.qadena.EncryptableAnonTransferFunds.TotalTransferPrimePC:type_name -> qadena.qadena.EncryptablePedersenCommit
	33, // 28: qadena.qadena.EncryptableAnonTransferFunds.TransparentTransferBF:type_name -> qadena.qadena.BInt
	34, // 29: qadena.qadena.EncryptableESuspiciousAmount.USDCoinAmount:type_name -> cosmos.base.v1beta1.Coin
	34, // 30: qadena.qadena.EncryptableESuspiciousAmount.CoinAmount:type_name -> cosmos.base.v1beta1.Coin
	28, // 31: qadena.qadena.EncryptableEnclaveSSOwnerMap.Pioneers:type_name -> qadena.qadena.EncryptableEnclaveSSOwnerMap.PioneersEntry
	29, // 32: qadena.qadena.EncryptableEnclavePubKCacheMap.PubKs:type_name -> qadena.qadena.EncryptableEnclavePubKCacheMap.PubKsEntry
	25, // 33: qadena.qadena.EncryptableSharedEnclaveParams.SSIntervalOwners:type_name -> qadena.qadena.EncryptableEnclaveSSOwnerMap
	26, // 34: qadena.qadena.EncryptableSharedEnclaveParams.SSIntervalPubKCache:type_name -> qadena.qadena.EncryptableEnclavePubKCacheMap
	24, // 35: qadena.qadena.EncryptableEnclaveSSOwnerMap.PioneersEntry.value:type_name -> qadena.qadena.EncryptablePioneerIDs
	36, // [36:36] is the sub-list for method output_type
	36, // [36:36] is the sub-list for method input_type
	36, // [36:36] is the sub-list for extension type_name
	36, // [36:36] is the sub-list for extension extendee
	0,  // [0:36] is the sub-list for field type_name
}

func init() { file_qadena_qadena_encryptable_proto_init() }
func file_qadena_qadena_encryptable_proto_init() {
	if File_qadena_qadena_encryptable_proto != nil {
		return
	}
	file_qadena_qadena_params_proto_init()
	file_qadena_qadena_suspicious_transaction_proto_init()
	file_qadena_qadena_pedersen_commit_proto_init()
	file_qadena_qadena_bind_data_proto_init()
	file_qadena_qadena_range_proof_proto_init()
	file_qadena_qadena_b_pedersen_commit_proto_init()
	file_qadena_qadena_v_share_bind_data_proto_init()
	file_qadena_qadena_share_proto_init()
	file_qadena_qadena_secret_share_priv_k_proto_init()
	file_qadena_qadena_recover_share_proto_init()
	file_qadena_qadena_bulk_credential_proto_init()
	file_qadena_qadena_bigint_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_qadena_qadena_encryptable_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EncryptableString); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_qadena_qadena_encryptable_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EncryptableClaimCredentialExtraParms); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_qadena_qadena_encryptable_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EncryptableAuthorizedSignatory); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_qadena_qadena_encryptable_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EncryptableSignatory); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_qadena_qadena_encryptable_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EncryptableWalletAmount); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_qadena_qadena_encryptable_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EncryptablePersonalInfoDetails); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_qadena_qadena_encryptable_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EncryptablePersonalInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_qadena_qadena_encryptable_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EncryptableSingleContactInfoDetails); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_qadena_qadena_encryptable_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EncryptableSingleContactInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_qadena_qadena_encryptable_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EncryptableValidatedCredential); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_qadena_qadena_encryptable_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EncryptableValidatedCredentials); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_qadena_qadena_encryptable_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EncryptableCreateWalletEWalletIDExtraParms); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_qadena_qadena_encryptable_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EncryptableCreateWalletEWalletID); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_qadena_qadena_encryptable_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EncryptableCreateWallet); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_qadena_qadena_encryptable_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EncryptableTransferFundsEWalletIDExtraParms); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_qadena_qadena_encryptable_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EncryptableTransferFundsEWalletID); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_qadena_qadena_encryptable_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EncryptableTransferFunds); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_qadena_qadena_encryptable_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EncryptableReceiveFundsEWalletIDExtraParms); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_qadena_qadena_encryptable_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EncryptableReceiveFundsEWalletID); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_qadena_qadena_encryptable_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EncryptableSignRecoverKeyEWalletID); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_qadena_qadena_encryptable_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EncryptableReceiveFunds); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_qadena_qadena_encryptable_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EncryptableAnonTransferFunds); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_qadena_qadena_encryptable_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EncryptableESuspiciousAmount); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_qadena_qadena_encryptable_proto_msgTypes[23].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EncryptableSSIDAndPrivK); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_qadena_qadena_encryptable_proto_msgTypes[24].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EncryptablePioneerIDs); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_qadena_qadena_encryptable_proto_msgTypes[25].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EncryptableEnclaveSSOwnerMap); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_qadena_qadena_encryptable_proto_msgTypes[26].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EncryptableEnclavePubKCacheMap); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_qadena_qadena_encryptable_proto_msgTypes[27].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*EncryptableSharedEnclaveParams); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_qadena_qadena_encryptable_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   30,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_qadena_qadena_encryptable_proto_goTypes,
		DependencyIndexes: file_qadena_qadena_encryptable_proto_depIdxs,
		MessageInfos:      file_qadena_qadena_encryptable_proto_msgTypes,
	}.Build()
	File_qadena_qadena_encryptable_proto = out.File
	file_qadena_qadena_encryptable_proto_rawDesc = nil
	file_qadena_qadena_encryptable_proto_goTypes = nil
	file_qadena_qadena_encryptable_proto_depIdxs = nil
}
