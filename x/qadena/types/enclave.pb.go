// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: qadena/qadena/enclave.proto

package types

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// The request message containing the user's name.
type HelloRequest struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *HelloRequest) Reset()         { *m = HelloRequest{} }
func (m *HelloRequest) String() string { return proto.CompactTextString(m) }
func (*HelloRequest) ProtoMessage()    {}
func (*HelloRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{0}
}
func (m *HelloRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HelloRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HelloRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HelloRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HelloRequest.Merge(m, src)
}
func (m *HelloRequest) XXX_Size() int {
	return m.Size()
}
func (m *HelloRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HelloRequest.DiscardUnknown(m)
}

var xxx_messageInfo_HelloRequest proto.InternalMessageInfo

func (m *HelloRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// The response message containing the greetings
type HelloReply struct {
	Message string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *HelloReply) Reset()         { *m = HelloReply{} }
func (m *HelloReply) String() string { return proto.CompactTextString(m) }
func (*HelloReply) ProtoMessage()    {}
func (*HelloReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{1}
}
func (m *HelloReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HelloReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HelloReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HelloReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HelloReply.Merge(m, src)
}
func (m *HelloReply) XXX_Size() int {
	return m.Size()
}
func (m *HelloReply) XXX_DiscardUnknown() {
	xxx_messageInfo_HelloReply.DiscardUnknown(m)
}

var xxx_messageInfo_HelloReply proto.InternalMessageInfo

func (m *HelloReply) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type MsgEndBlock struct {
}

func (m *MsgEndBlock) Reset()         { *m = MsgEndBlock{} }
func (m *MsgEndBlock) String() string { return proto.CompactTextString(m) }
func (*MsgEndBlock) ProtoMessage()    {}
func (*MsgEndBlock) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{2}
}
func (m *MsgEndBlock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgEndBlock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgEndBlock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgEndBlock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgEndBlock.Merge(m, src)
}
func (m *MsgEndBlock) XXX_Size() int {
	return m.Size()
}
func (m *MsgEndBlock) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgEndBlock.DiscardUnknown(m)
}

var xxx_messageInfo_MsgEndBlock proto.InternalMessageInfo

type EndBlockReply struct {
}

func (m *EndBlockReply) Reset()         { *m = EndBlockReply{} }
func (m *EndBlockReply) String() string { return proto.CompactTextString(m) }
func (*EndBlockReply) ProtoMessage()    {}
func (*EndBlockReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{3}
}
func (m *EndBlockReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EndBlockReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EndBlockReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EndBlockReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EndBlockReply.Merge(m, src)
}
func (m *EndBlockReply) XXX_Size() int {
	return m.Size()
}
func (m *EndBlockReply) XXX_DiscardUnknown() {
	xxx_messageInfo_EndBlockReply.DiscardUnknown(m)
}

var xxx_messageInfo_EndBlockReply proto.InternalMessageInfo

type QueryGetSubWalletIDByOriginalWalletIDResponse struct {
	SubWalletID string `protobuf:"bytes,1,opt,name=subWalletID,proto3" json:"subWalletID,omitempty"`
}

func (m *QueryGetSubWalletIDByOriginalWalletIDResponse) Reset() {
	*m = QueryGetSubWalletIDByOriginalWalletIDResponse{}
}
func (m *QueryGetSubWalletIDByOriginalWalletIDResponse) String() string {
	return proto.CompactTextString(m)
}
func (*QueryGetSubWalletIDByOriginalWalletIDResponse) ProtoMessage() {}
func (*QueryGetSubWalletIDByOriginalWalletIDResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{4}
}
func (m *QueryGetSubWalletIDByOriginalWalletIDResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryGetSubWalletIDByOriginalWalletIDResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryGetSubWalletIDByOriginalWalletIDResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryGetSubWalletIDByOriginalWalletIDResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryGetSubWalletIDByOriginalWalletIDResponse.Merge(m, src)
}
func (m *QueryGetSubWalletIDByOriginalWalletIDResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryGetSubWalletIDByOriginalWalletIDResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryGetSubWalletIDByOriginalWalletIDResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryGetSubWalletIDByOriginalWalletIDResponse proto.InternalMessageInfo

func (m *QueryGetSubWalletIDByOriginalWalletIDResponse) GetSubWalletID() string {
	if m != nil {
		return m.SubWalletID
	}
	return ""
}

type StoreHash struct {
	Key  string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Hash string `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *StoreHash) Reset()         { *m = StoreHash{} }
func (m *StoreHash) String() string { return proto.CompactTextString(m) }
func (*StoreHash) ProtoMessage()    {}
func (*StoreHash) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{5}
}
func (m *StoreHash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreHash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoreHash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoreHash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreHash.Merge(m, src)
}
func (m *StoreHash) XXX_Size() int {
	return m.Size()
}
func (m *StoreHash) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreHash.DiscardUnknown(m)
}

var xxx_messageInfo_StoreHash proto.InternalMessageInfo

func (m *StoreHash) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *StoreHash) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

type MsgGetStoreHash struct {
}

func (m *MsgGetStoreHash) Reset()         { *m = MsgGetStoreHash{} }
func (m *MsgGetStoreHash) String() string { return proto.CompactTextString(m) }
func (*MsgGetStoreHash) ProtoMessage()    {}
func (*MsgGetStoreHash) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{6}
}
func (m *MsgGetStoreHash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgGetStoreHash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgGetStoreHash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgGetStoreHash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgGetStoreHash.Merge(m, src)
}
func (m *MsgGetStoreHash) XXX_Size() int {
	return m.Size()
}
func (m *MsgGetStoreHash) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgGetStoreHash.DiscardUnknown(m)
}

var xxx_messageInfo_MsgGetStoreHash proto.InternalMessageInfo

type GetStoreHashReply struct {
	Hashes []*StoreHash `protobuf:"bytes,1,rep,name=hashes,proto3" json:"hashes,omitempty"`
}

func (m *GetStoreHashReply) Reset()         { *m = GetStoreHashReply{} }
func (m *GetStoreHashReply) String() string { return proto.CompactTextString(m) }
func (*GetStoreHashReply) ProtoMessage()    {}
func (*GetStoreHashReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{7}
}
func (m *GetStoreHashReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetStoreHashReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetStoreHashReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetStoreHashReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStoreHashReply.Merge(m, src)
}
func (m *GetStoreHashReply) XXX_Size() int {
	return m.Size()
}
func (m *GetStoreHashReply) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStoreHashReply.DiscardUnknown(m)
}

var xxx_messageInfo_GetStoreHashReply proto.InternalMessageInfo

func (m *GetStoreHashReply) GetHashes() []*StoreHash {
	if m != nil {
		return m.Hashes
	}
	return nil
}

type MsgAddAsValidator struct {
}

func (m *MsgAddAsValidator) Reset()         { *m = MsgAddAsValidator{} }
func (m *MsgAddAsValidator) String() string { return proto.CompactTextString(m) }
func (*MsgAddAsValidator) ProtoMessage()    {}
func (*MsgAddAsValidator) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{8}
}
func (m *MsgAddAsValidator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddAsValidator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddAsValidator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddAsValidator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddAsValidator.Merge(m, src)
}
func (m *MsgAddAsValidator) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddAsValidator) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddAsValidator.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddAsValidator proto.InternalMessageInfo

type MsgSyncEnclave struct {
	PioneerID              string `protobuf:"bytes,1,opt,name=pioneerID,proto3" json:"pioneerID,omitempty"`
	ExternalAddress        string `protobuf:"bytes,2,opt,name=externalAddress,proto3" json:"externalAddress,omitempty"`
	PioneerArmorPrivK      string `protobuf:"bytes,3,opt,name=pioneerArmorPrivK,proto3" json:"pioneerArmorPrivK,omitempty"`
	PioneerArmorPassPhrase string `protobuf:"bytes,4,opt,name=pioneerArmorPassPhrase,proto3" json:"pioneerArmorPassPhrase,omitempty"`
	SeedNode               string `protobuf:"bytes,5,opt,name=seedNode,proto3" json:"seedNode,omitempty"`
}

func (m *MsgSyncEnclave) Reset()         { *m = MsgSyncEnclave{} }
func (m *MsgSyncEnclave) String() string { return proto.CompactTextString(m) }
func (*MsgSyncEnclave) ProtoMessage()    {}
func (*MsgSyncEnclave) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{9}
}
func (m *MsgSyncEnclave) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSyncEnclave) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSyncEnclave.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSyncEnclave) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSyncEnclave.Merge(m, src)
}
func (m *MsgSyncEnclave) XXX_Size() int {
	return m.Size()
}
func (m *MsgSyncEnclave) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSyncEnclave.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSyncEnclave proto.InternalMessageInfo

func (m *MsgSyncEnclave) GetPioneerID() string {
	if m != nil {
		return m.PioneerID
	}
	return ""
}

func (m *MsgSyncEnclave) GetExternalAddress() string {
	if m != nil {
		return m.ExternalAddress
	}
	return ""
}

func (m *MsgSyncEnclave) GetPioneerArmorPrivK() string {
	if m != nil {
		return m.PioneerArmorPrivK
	}
	return ""
}

func (m *MsgSyncEnclave) GetPioneerArmorPassPhrase() string {
	if m != nil {
		return m.PioneerArmorPassPhrase
	}
	return ""
}

func (m *MsgSyncEnclave) GetSeedNode() string {
	if m != nil {
		return m.SeedNode
	}
	return ""
}

type MsgUpgradeEnclave struct {
	RemoteReport []byte `protobuf:"bytes,1,opt,name=remoteReport,proto3" json:"remoteReport,omitempty"`
	EnclavePubK  string `protobuf:"bytes,2,opt,name=enclavePubK,proto3" json:"enclavePubK,omitempty"`
}

func (m *MsgUpgradeEnclave) Reset()         { *m = MsgUpgradeEnclave{} }
func (m *MsgUpgradeEnclave) String() string { return proto.CompactTextString(m) }
func (*MsgUpgradeEnclave) ProtoMessage()    {}
func (*MsgUpgradeEnclave) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{10}
}
func (m *MsgUpgradeEnclave) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpgradeEnclave) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpgradeEnclave.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpgradeEnclave) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpgradeEnclave.Merge(m, src)
}
func (m *MsgUpgradeEnclave) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpgradeEnclave) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpgradeEnclave.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpgradeEnclave proto.InternalMessageInfo

func (m *MsgUpgradeEnclave) GetRemoteReport() []byte {
	if m != nil {
		return m.RemoteReport
	}
	return nil
}

func (m *MsgUpgradeEnclave) GetEnclavePubK() string {
	if m != nil {
		return m.EnclavePubK
	}
	return ""
}

type UpgradeEnclaveReply struct {
	RemoteReport                      []byte `protobuf:"bytes,1,opt,name=remoteReport,proto3" json:"remoteReport,omitempty"`
	EncEnclavePrivateStateEnclavePubK []byte `protobuf:"bytes,2,opt,name=encEnclavePrivateStateEnclavePubK,proto3" json:"encEnclavePrivateStateEnclavePubK,omitempty"`
}

func (m *UpgradeEnclaveReply) Reset()         { *m = UpgradeEnclaveReply{} }
func (m *UpgradeEnclaveReply) String() string { return proto.CompactTextString(m) }
func (*UpgradeEnclaveReply) ProtoMessage()    {}
func (*UpgradeEnclaveReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{11}
}
func (m *UpgradeEnclaveReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpgradeEnclaveReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpgradeEnclaveReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpgradeEnclaveReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpgradeEnclaveReply.Merge(m, src)
}
func (m *UpgradeEnclaveReply) XXX_Size() int {
	return m.Size()
}
func (m *UpgradeEnclaveReply) XXX_DiscardUnknown() {
	xxx_messageInfo_UpgradeEnclaveReply.DiscardUnknown(m)
}

var xxx_messageInfo_UpgradeEnclaveReply proto.InternalMessageInfo

func (m *UpgradeEnclaveReply) GetRemoteReport() []byte {
	if m != nil {
		return m.RemoteReport
	}
	return nil
}

func (m *UpgradeEnclaveReply) GetEncEnclavePrivateStateEnclavePubK() []byte {
	if m != nil {
		return m.EncEnclavePrivateStateEnclavePubK
	}
	return nil
}

type MsgExportPrivateKey struct {
	PubKID string `protobuf:"bytes,1,opt,name=pubKID,proto3" json:"pubKID,omitempty"`
}

func (m *MsgExportPrivateKey) Reset()         { *m = MsgExportPrivateKey{} }
func (m *MsgExportPrivateKey) String() string { return proto.CompactTextString(m) }
func (*MsgExportPrivateKey) ProtoMessage()    {}
func (*MsgExportPrivateKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{12}
}
func (m *MsgExportPrivateKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgExportPrivateKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgExportPrivateKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgExportPrivateKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgExportPrivateKey.Merge(m, src)
}
func (m *MsgExportPrivateKey) XXX_Size() int {
	return m.Size()
}
func (m *MsgExportPrivateKey) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgExportPrivateKey.DiscardUnknown(m)
}

var xxx_messageInfo_MsgExportPrivateKey proto.InternalMessageInfo

func (m *MsgExportPrivateKey) GetPubKID() string {
	if m != nil {
		return m.PubKID
	}
	return ""
}

type MsgRemovePrivateKey struct {
	PubKID string `protobuf:"bytes,1,opt,name=pubKID,proto3" json:"pubKID,omitempty"`
}

func (m *MsgRemovePrivateKey) Reset()         { *m = MsgRemovePrivateKey{} }
func (m *MsgRemovePrivateKey) String() string { return proto.CompactTextString(m) }
func (*MsgRemovePrivateKey) ProtoMessage()    {}
func (*MsgRemovePrivateKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{13}
}
func (m *MsgRemovePrivateKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRemovePrivateKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRemovePrivateKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRemovePrivateKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRemovePrivateKey.Merge(m, src)
}
func (m *MsgRemovePrivateKey) XXX_Size() int {
	return m.Size()
}
func (m *MsgRemovePrivateKey) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRemovePrivateKey.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRemovePrivateKey proto.InternalMessageInfo

func (m *MsgRemovePrivateKey) GetPubKID() string {
	if m != nil {
		return m.PubKID
	}
	return ""
}

type MsgExportPrivateState struct {
}

func (m *MsgExportPrivateState) Reset()         { *m = MsgExportPrivateState{} }
func (m *MsgExportPrivateState) String() string { return proto.CompactTextString(m) }
func (*MsgExportPrivateState) ProtoMessage()    {}
func (*MsgExportPrivateState) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{14}
}
func (m *MsgExportPrivateState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgExportPrivateState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgExportPrivateState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgExportPrivateState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgExportPrivateState.Merge(m, src)
}
func (m *MsgExportPrivateState) XXX_Size() int {
	return m.Size()
}
func (m *MsgExportPrivateState) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgExportPrivateState.DiscardUnknown(m)
}

var xxx_messageInfo_MsgExportPrivateState proto.InternalMessageInfo

type MsgUpdateSSIntervalKey struct {
}

func (m *MsgUpdateSSIntervalKey) Reset()         { *m = MsgUpdateSSIntervalKey{} }
func (m *MsgUpdateSSIntervalKey) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateSSIntervalKey) ProtoMessage()    {}
func (*MsgUpdateSSIntervalKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{15}
}
func (m *MsgUpdateSSIntervalKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateSSIntervalKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateSSIntervalKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateSSIntervalKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateSSIntervalKey.Merge(m, src)
}
func (m *MsgUpdateSSIntervalKey) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateSSIntervalKey) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateSSIntervalKey.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateSSIntervalKey proto.InternalMessageInfo

type UpdateSSIntervalKeyReply struct {
}

func (m *UpdateSSIntervalKeyReply) Reset()         { *m = UpdateSSIntervalKeyReply{} }
func (m *UpdateSSIntervalKeyReply) String() string { return proto.CompactTextString(m) }
func (*UpdateSSIntervalKeyReply) ProtoMessage()    {}
func (*UpdateSSIntervalKeyReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{16}
}
func (m *UpdateSSIntervalKeyReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateSSIntervalKeyReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateSSIntervalKeyReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateSSIntervalKeyReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateSSIntervalKeyReply.Merge(m, src)
}
func (m *UpdateSSIntervalKeyReply) XXX_Size() int {
	return m.Size()
}
func (m *UpdateSSIntervalKeyReply) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateSSIntervalKeyReply.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateSSIntervalKeyReply proto.InternalMessageInfo

type RemovePrivateKeyReply struct {
}

func (m *RemovePrivateKeyReply) Reset()         { *m = RemovePrivateKeyReply{} }
func (m *RemovePrivateKeyReply) String() string { return proto.CompactTextString(m) }
func (*RemovePrivateKeyReply) ProtoMessage()    {}
func (*RemovePrivateKeyReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{17}
}
func (m *RemovePrivateKeyReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemovePrivateKeyReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemovePrivateKeyReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemovePrivateKeyReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemovePrivateKeyReply.Merge(m, src)
}
func (m *RemovePrivateKeyReply) XXX_Size() int {
	return m.Size()
}
func (m *RemovePrivateKeyReply) XXX_DiscardUnknown() {
	xxx_messageInfo_RemovePrivateKeyReply.DiscardUnknown(m)
}

var xxx_messageInfo_RemovePrivateKeyReply proto.InternalMessageInfo

type ExportPrivateKeyReply struct {
	PrivK string `protobuf:"bytes,1,opt,name=privK,proto3" json:"privK,omitempty"`
}

func (m *ExportPrivateKeyReply) Reset()         { *m = ExportPrivateKeyReply{} }
func (m *ExportPrivateKeyReply) String() string { return proto.CompactTextString(m) }
func (*ExportPrivateKeyReply) ProtoMessage()    {}
func (*ExportPrivateKeyReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{18}
}
func (m *ExportPrivateKeyReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExportPrivateKeyReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExportPrivateKeyReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExportPrivateKeyReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExportPrivateKeyReply.Merge(m, src)
}
func (m *ExportPrivateKeyReply) XXX_Size() int {
	return m.Size()
}
func (m *ExportPrivateKeyReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ExportPrivateKeyReply.DiscardUnknown(m)
}

var xxx_messageInfo_ExportPrivateKeyReply proto.InternalMessageInfo

func (m *ExportPrivateKeyReply) GetPrivK() string {
	if m != nil {
		return m.PrivK
	}
	return ""
}

type ExportPrivateStateReply struct {
	State string `protobuf:"bytes,1,opt,name=state,proto3" json:"state,omitempty"`
}

func (m *ExportPrivateStateReply) Reset()         { *m = ExportPrivateStateReply{} }
func (m *ExportPrivateStateReply) String() string { return proto.CompactTextString(m) }
func (*ExportPrivateStateReply) ProtoMessage()    {}
func (*ExportPrivateStateReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{19}
}
func (m *ExportPrivateStateReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExportPrivateStateReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExportPrivateStateReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExportPrivateStateReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExportPrivateStateReply.Merge(m, src)
}
func (m *ExportPrivateStateReply) XXX_Size() int {
	return m.Size()
}
func (m *ExportPrivateStateReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ExportPrivateStateReply.DiscardUnknown(m)
}

var xxx_messageInfo_ExportPrivateStateReply proto.InternalMessageInfo

func (m *ExportPrivateStateReply) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

type ValidateAuthenticateServiceProviderRequest struct {
	PubKID              string `protobuf:"bytes,1,opt,name=pubKID,proto3" json:"pubKID,omitempty"`
	ServiceProviderType string `protobuf:"bytes,2,opt,name=serviceProviderType,proto3" json:"serviceProviderType,omitempty"`
}

func (m *ValidateAuthenticateServiceProviderRequest) Reset() {
	*m = ValidateAuthenticateServiceProviderRequest{}
}
func (m *ValidateAuthenticateServiceProviderRequest) String() string {
	return proto.CompactTextString(m)
}
func (*ValidateAuthenticateServiceProviderRequest) ProtoMessage() {}
func (*ValidateAuthenticateServiceProviderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{20}
}
func (m *ValidateAuthenticateServiceProviderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateAuthenticateServiceProviderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateAuthenticateServiceProviderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateAuthenticateServiceProviderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateAuthenticateServiceProviderRequest.Merge(m, src)
}
func (m *ValidateAuthenticateServiceProviderRequest) XXX_Size() int {
	return m.Size()
}
func (m *ValidateAuthenticateServiceProviderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateAuthenticateServiceProviderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateAuthenticateServiceProviderRequest proto.InternalMessageInfo

func (m *ValidateAuthenticateServiceProviderRequest) GetPubKID() string {
	if m != nil {
		return m.PubKID
	}
	return ""
}

func (m *ValidateAuthenticateServiceProviderRequest) GetServiceProviderType() string {
	if m != nil {
		return m.ServiceProviderType
	}
	return ""
}

type ValidateAuthenticateServiceProviderReply struct {
	Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *ValidateAuthenticateServiceProviderReply) Reset() {
	*m = ValidateAuthenticateServiceProviderReply{}
}
func (m *ValidateAuthenticateServiceProviderReply) String() string { return proto.CompactTextString(m) }
func (*ValidateAuthenticateServiceProviderReply) ProtoMessage()    {}
func (*ValidateAuthenticateServiceProviderReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{21}
}
func (m *ValidateAuthenticateServiceProviderReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateAuthenticateServiceProviderReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateAuthenticateServiceProviderReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateAuthenticateServiceProviderReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateAuthenticateServiceProviderReply.Merge(m, src)
}
func (m *ValidateAuthenticateServiceProviderReply) XXX_Size() int {
	return m.Size()
}
func (m *ValidateAuthenticateServiceProviderReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateAuthenticateServiceProviderReply.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateAuthenticateServiceProviderReply proto.InternalMessageInfo

func (m *ValidateAuthenticateServiceProviderReply) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type MsgInitEnclave struct {
	PioneerID              string `protobuf:"bytes,1,opt,name=pioneerID,proto3" json:"pioneerID,omitempty"`
	ExternalAddress        string `protobuf:"bytes,2,opt,name=externalAddress,proto3" json:"externalAddress,omitempty"`
	PioneerArmorPrivK      string `protobuf:"bytes,3,opt,name=pioneerArmorPrivK,proto3" json:"pioneerArmorPrivK,omitempty"`
	PioneerArmorPassPhrase string `protobuf:"bytes,4,opt,name=pioneerArmorPassPhrase,proto3" json:"pioneerArmorPassPhrase,omitempty"`
	JarID                  string `protobuf:"bytes,5,opt,name=jarID,proto3" json:"jarID,omitempty"`
	RegulatorID            string `protobuf:"bytes,6,opt,name=regulatorID,proto3" json:"regulatorID,omitempty"`
	SignerID               string `protobuf:"bytes,7,opt,name=signerID,proto3" json:"signerID,omitempty"`
	UniqueID               string `protobuf:"bytes,8,opt,name=uniqueID,proto3" json:"uniqueID,omitempty"`
}

func (m *MsgInitEnclave) Reset()         { *m = MsgInitEnclave{} }
func (m *MsgInitEnclave) String() string { return proto.CompactTextString(m) }
func (*MsgInitEnclave) ProtoMessage()    {}
func (*MsgInitEnclave) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{22}
}
func (m *MsgInitEnclave) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgInitEnclave) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgInitEnclave.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgInitEnclave) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgInitEnclave.Merge(m, src)
}
func (m *MsgInitEnclave) XXX_Size() int {
	return m.Size()
}
func (m *MsgInitEnclave) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgInitEnclave.DiscardUnknown(m)
}

var xxx_messageInfo_MsgInitEnclave proto.InternalMessageInfo

func (m *MsgInitEnclave) GetPioneerID() string {
	if m != nil {
		return m.PioneerID
	}
	return ""
}

func (m *MsgInitEnclave) GetExternalAddress() string {
	if m != nil {
		return m.ExternalAddress
	}
	return ""
}

func (m *MsgInitEnclave) GetPioneerArmorPrivK() string {
	if m != nil {
		return m.PioneerArmorPrivK
	}
	return ""
}

func (m *MsgInitEnclave) GetPioneerArmorPassPhrase() string {
	if m != nil {
		return m.PioneerArmorPassPhrase
	}
	return ""
}

func (m *MsgInitEnclave) GetJarID() string {
	if m != nil {
		return m.JarID
	}
	return ""
}

func (m *MsgInitEnclave) GetRegulatorID() string {
	if m != nil {
		return m.RegulatorID
	}
	return ""
}

func (m *MsgInitEnclave) GetSignerID() string {
	if m != nil {
		return m.SignerID
	}
	return ""
}

func (m *MsgInitEnclave) GetUniqueID() string {
	if m != nil {
		return m.UniqueID
	}
	return ""
}

type VShareSignatory struct {
	EncSignatoryVShare []byte          `protobuf:"bytes,1,opt,name=encSignatoryVShare,proto3" json:"encSignatoryVShare,omitempty"`
	VShareBind         *VShareBindData `protobuf:"bytes,2,opt,name=vShareBind,proto3" json:"vShareBind,omitempty"`
}

func (m *VShareSignatory) Reset()         { *m = VShareSignatory{} }
func (m *VShareSignatory) String() string { return proto.CompactTextString(m) }
func (*VShareSignatory) ProtoMessage()    {}
func (*VShareSignatory) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{23}
}
func (m *VShareSignatory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VShareSignatory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VShareSignatory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VShareSignatory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VShareSignatory.Merge(m, src)
}
func (m *VShareSignatory) XXX_Size() int {
	return m.Size()
}
func (m *VShareSignatory) XXX_DiscardUnknown() {
	xxx_messageInfo_VShareSignatory.DiscardUnknown(m)
}

var xxx_messageInfo_VShareSignatory proto.InternalMessageInfo

func (m *VShareSignatory) GetEncSignatoryVShare() []byte {
	if m != nil {
		return m.EncSignatoryVShare
	}
	return nil
}

func (m *VShareSignatory) GetVShareBind() *VShareBindData {
	if m != nil {
		return m.VShareBind
	}
	return nil
}

type ValidateAuthorizedSignerRequest struct {
	Creator             string             `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	RequestingSignatory *VShareSignatory   `protobuf:"bytes,2,opt,name=requestingSignatory,proto3" json:"requestingSignatory,omitempty"`
	RequiredSignatory   []*VShareSignatory `protobuf:"bytes,3,rep,name=requiredSignatory,proto3" json:"requiredSignatory,omitempty"`
	CompletedSignatory  []*VShareSignatory `protobuf:"bytes,4,rep,name=completedSignatory,proto3" json:"completedSignatory,omitempty"`
}

func (m *ValidateAuthorizedSignerRequest) Reset()         { *m = ValidateAuthorizedSignerRequest{} }
func (m *ValidateAuthorizedSignerRequest) String() string { return proto.CompactTextString(m) }
func (*ValidateAuthorizedSignerRequest) ProtoMessage()    {}
func (*ValidateAuthorizedSignerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{24}
}
func (m *ValidateAuthorizedSignerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateAuthorizedSignerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateAuthorizedSignerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateAuthorizedSignerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateAuthorizedSignerRequest.Merge(m, src)
}
func (m *ValidateAuthorizedSignerRequest) XXX_Size() int {
	return m.Size()
}
func (m *ValidateAuthorizedSignerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateAuthorizedSignerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateAuthorizedSignerRequest proto.InternalMessageInfo

func (m *ValidateAuthorizedSignerRequest) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *ValidateAuthorizedSignerRequest) GetRequestingSignatory() *VShareSignatory {
	if m != nil {
		return m.RequestingSignatory
	}
	return nil
}

func (m *ValidateAuthorizedSignerRequest) GetRequiredSignatory() []*VShareSignatory {
	if m != nil {
		return m.RequiredSignatory
	}
	return nil
}

func (m *ValidateAuthorizedSignerRequest) GetCompletedSignatory() []*VShareSignatory {
	if m != nil {
		return m.CompletedSignatory
	}
	return nil
}

type ValidateAuthorizedSignerReply struct {
	Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *ValidateAuthorizedSignerReply) Reset()         { *m = ValidateAuthorizedSignerReply{} }
func (m *ValidateAuthorizedSignerReply) String() string { return proto.CompactTextString(m) }
func (*ValidateAuthorizedSignerReply) ProtoMessage()    {}
func (*ValidateAuthorizedSignerReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{25}
}
func (m *ValidateAuthorizedSignerReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateAuthorizedSignerReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateAuthorizedSignerReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateAuthorizedSignerReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateAuthorizedSignerReply.Merge(m, src)
}
func (m *ValidateAuthorizedSignerReply) XXX_Size() int {
	return m.Size()
}
func (m *ValidateAuthorizedSignerReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateAuthorizedSignerReply.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateAuthorizedSignerReply proto.InternalMessageInfo

func (m *ValidateAuthorizedSignerReply) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type ValidateAuthorizedSignatoryRequest struct {
	Creator          string             `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	Signatory        *VShareSignatory   `protobuf:"bytes,2,opt,name=signatory,proto3" json:"signatory,omitempty"`
	CurrentSignatory []*VShareSignatory `protobuf:"bytes,3,rep,name=currentSignatory,proto3" json:"currentSignatory,omitempty"`
}

func (m *ValidateAuthorizedSignatoryRequest) Reset()         { *m = ValidateAuthorizedSignatoryRequest{} }
func (m *ValidateAuthorizedSignatoryRequest) String() string { return proto.CompactTextString(m) }
func (*ValidateAuthorizedSignatoryRequest) ProtoMessage()    {}
func (*ValidateAuthorizedSignatoryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{26}
}
func (m *ValidateAuthorizedSignatoryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateAuthorizedSignatoryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateAuthorizedSignatoryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateAuthorizedSignatoryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateAuthorizedSignatoryRequest.Merge(m, src)
}
func (m *ValidateAuthorizedSignatoryRequest) XXX_Size() int {
	return m.Size()
}
func (m *ValidateAuthorizedSignatoryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateAuthorizedSignatoryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateAuthorizedSignatoryRequest proto.InternalMessageInfo

func (m *ValidateAuthorizedSignatoryRequest) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *ValidateAuthorizedSignatoryRequest) GetSignatory() *VShareSignatory {
	if m != nil {
		return m.Signatory
	}
	return nil
}

func (m *ValidateAuthorizedSignatoryRequest) GetCurrentSignatory() []*VShareSignatory {
	if m != nil {
		return m.CurrentSignatory
	}
	return nil
}

type ValidateAuthorizedSignatoryReply struct {
	Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *ValidateAuthorizedSignatoryReply) Reset()         { *m = ValidateAuthorizedSignatoryReply{} }
func (m *ValidateAuthorizedSignatoryReply) String() string { return proto.CompactTextString(m) }
func (*ValidateAuthorizedSignatoryReply) ProtoMessage()    {}
func (*ValidateAuthorizedSignatoryReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{27}
}
func (m *ValidateAuthorizedSignatoryReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateAuthorizedSignatoryReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateAuthorizedSignatoryReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateAuthorizedSignatoryReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateAuthorizedSignatoryReply.Merge(m, src)
}
func (m *ValidateAuthorizedSignatoryReply) XXX_Size() int {
	return m.Size()
}
func (m *ValidateAuthorizedSignatoryReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateAuthorizedSignatoryReply.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateAuthorizedSignatoryReply proto.InternalMessageInfo

func (m *ValidateAuthorizedSignatoryReply) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type MsgUpdateHeight struct {
	Height     int64 `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	IsProposer bool  `protobuf:"varint,2,opt,name=isProposer,proto3" json:"isProposer,omitempty"`
}

func (m *MsgUpdateHeight) Reset()         { *m = MsgUpdateHeight{} }
func (m *MsgUpdateHeight) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateHeight) ProtoMessage()    {}
func (*MsgUpdateHeight) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{28}
}
func (m *MsgUpdateHeight) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateHeight) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateHeight.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateHeight) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateHeight.Merge(m, src)
}
func (m *MsgUpdateHeight) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateHeight) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateHeight.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateHeight proto.InternalMessageInfo

func (m *MsgUpdateHeight) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *MsgUpdateHeight) GetIsProposer() bool {
	if m != nil {
		return m.IsProposer
	}
	return false
}

type MsgScanTransactions struct {
	Timestamp    time.Time         `protobuf:"bytes,1,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	Height       int64             `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	Msg          *MsgTransferFunds `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg,omitempty"`
	Exchangerate string            `protobuf:"bytes,4,opt,name=exchangerate,proto3" json:"exchangerate,omitempty"`
}

func (m *MsgScanTransactions) Reset()         { *m = MsgScanTransactions{} }
func (m *MsgScanTransactions) String() string { return proto.CompactTextString(m) }
func (*MsgScanTransactions) ProtoMessage()    {}
func (*MsgScanTransactions) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{29}
}
func (m *MsgScanTransactions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgScanTransactions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgScanTransactions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgScanTransactions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgScanTransactions.Merge(m, src)
}
func (m *MsgScanTransactions) XXX_Size() int {
	return m.Size()
}
func (m *MsgScanTransactions) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgScanTransactions.DiscardUnknown(m)
}

var xxx_messageInfo_MsgScanTransactions proto.InternalMessageInfo

func (m *MsgScanTransactions) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func (m *MsgScanTransactions) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *MsgScanTransactions) GetMsg() *MsgTransferFunds {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *MsgScanTransactions) GetExchangerate() string {
	if m != nil {
		return m.Exchangerate
	}
	return ""
}

type MsgSyncWallets struct {
	Clear bool `protobuf:"varint,1,opt,name=clear,proto3" json:"clear,omitempty"`
}

func (m *MsgSyncWallets) Reset()         { *m = MsgSyncWallets{} }
func (m *MsgSyncWallets) String() string { return proto.CompactTextString(m) }
func (*MsgSyncWallets) ProtoMessage()    {}
func (*MsgSyncWallets) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{30}
}
func (m *MsgSyncWallets) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSyncWallets) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSyncWallets.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSyncWallets) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSyncWallets.Merge(m, src)
}
func (m *MsgSyncWallets) XXX_Size() int {
	return m.Size()
}
func (m *MsgSyncWallets) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSyncWallets.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSyncWallets proto.InternalMessageInfo

func (m *MsgSyncWallets) GetClear() bool {
	if m != nil {
		return m.Clear
	}
	return false
}

type SyncWalletsReply struct {
	Wallets []*Wallet `protobuf:"bytes,1,rep,name=wallets,proto3" json:"wallets,omitempty"`
}

func (m *SyncWalletsReply) Reset()         { *m = SyncWalletsReply{} }
func (m *SyncWalletsReply) String() string { return proto.CompactTextString(m) }
func (*SyncWalletsReply) ProtoMessage()    {}
func (*SyncWalletsReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{31}
}
func (m *SyncWalletsReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncWalletsReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncWalletsReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncWalletsReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncWalletsReply.Merge(m, src)
}
func (m *SyncWalletsReply) XXX_Size() int {
	return m.Size()
}
func (m *SyncWalletsReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncWalletsReply.DiscardUnknown(m)
}

var xxx_messageInfo_SyncWalletsReply proto.InternalMessageInfo

func (m *SyncWalletsReply) GetWallets() []*Wallet {
	if m != nil {
		return m.Wallets
	}
	return nil
}

type MsgSyncCredentials struct {
	Clear bool `protobuf:"varint,1,opt,name=clear,proto3" json:"clear,omitempty"`
}

func (m *MsgSyncCredentials) Reset()         { *m = MsgSyncCredentials{} }
func (m *MsgSyncCredentials) String() string { return proto.CompactTextString(m) }
func (*MsgSyncCredentials) ProtoMessage()    {}
func (*MsgSyncCredentials) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{32}
}
func (m *MsgSyncCredentials) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSyncCredentials) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSyncCredentials.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSyncCredentials) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSyncCredentials.Merge(m, src)
}
func (m *MsgSyncCredentials) XXX_Size() int {
	return m.Size()
}
func (m *MsgSyncCredentials) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSyncCredentials.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSyncCredentials proto.InternalMessageInfo

func (m *MsgSyncCredentials) GetClear() bool {
	if m != nil {
		return m.Clear
	}
	return false
}

type SyncCredentialsReply struct {
	Credentials []*Credential `protobuf:"bytes,1,rep,name=credentials,proto3" json:"credentials,omitempty"`
}

func (m *SyncCredentialsReply) Reset()         { *m = SyncCredentialsReply{} }
func (m *SyncCredentialsReply) String() string { return proto.CompactTextString(m) }
func (*SyncCredentialsReply) ProtoMessage()    {}
func (*SyncCredentialsReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{33}
}
func (m *SyncCredentialsReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncCredentialsReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncCredentialsReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncCredentialsReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncCredentialsReply.Merge(m, src)
}
func (m *SyncCredentialsReply) XXX_Size() int {
	return m.Size()
}
func (m *SyncCredentialsReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncCredentialsReply.DiscardUnknown(m)
}

var xxx_messageInfo_SyncCredentialsReply proto.InternalMessageInfo

func (m *SyncCredentialsReply) GetCredentials() []*Credential {
	if m != nil {
		return m.Credentials
	}
	return nil
}

type MsgSyncRecoverKeys struct {
	Clear bool `protobuf:"varint,1,opt,name=clear,proto3" json:"clear,omitempty"`
}

func (m *MsgSyncRecoverKeys) Reset()         { *m = MsgSyncRecoverKeys{} }
func (m *MsgSyncRecoverKeys) String() string { return proto.CompactTextString(m) }
func (*MsgSyncRecoverKeys) ProtoMessage()    {}
func (*MsgSyncRecoverKeys) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{34}
}
func (m *MsgSyncRecoverKeys) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSyncRecoverKeys) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSyncRecoverKeys.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSyncRecoverKeys) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSyncRecoverKeys.Merge(m, src)
}
func (m *MsgSyncRecoverKeys) XXX_Size() int {
	return m.Size()
}
func (m *MsgSyncRecoverKeys) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSyncRecoverKeys.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSyncRecoverKeys proto.InternalMessageInfo

func (m *MsgSyncRecoverKeys) GetClear() bool {
	if m != nil {
		return m.Clear
	}
	return false
}

type SyncRecoverKeysReply struct {
	RecoverKeys []*RecoverKey `protobuf:"bytes,1,rep,name=recoverKeys,proto3" json:"recoverKeys,omitempty"`
}

func (m *SyncRecoverKeysReply) Reset()         { *m = SyncRecoverKeysReply{} }
func (m *SyncRecoverKeysReply) String() string { return proto.CompactTextString(m) }
func (*SyncRecoverKeysReply) ProtoMessage()    {}
func (*SyncRecoverKeysReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{35}
}
func (m *SyncRecoverKeysReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncRecoverKeysReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncRecoverKeysReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncRecoverKeysReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncRecoverKeysReply.Merge(m, src)
}
func (m *SyncRecoverKeysReply) XXX_Size() int {
	return m.Size()
}
func (m *SyncRecoverKeysReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncRecoverKeysReply.DiscardUnknown(m)
}

var xxx_messageInfo_SyncRecoverKeysReply proto.InternalMessageInfo

func (m *SyncRecoverKeysReply) GetRecoverKeys() []*RecoverKey {
	if m != nil {
		return m.RecoverKeys
	}
	return nil
}

type SetSecretSharePrivateKeyReply struct {
	Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *SetSecretSharePrivateKeyReply) Reset()         { *m = SetSecretSharePrivateKeyReply{} }
func (m *SetSecretSharePrivateKeyReply) String() string { return proto.CompactTextString(m) }
func (*SetSecretSharePrivateKeyReply) ProtoMessage()    {}
func (*SetSecretSharePrivateKeyReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{36}
}
func (m *SetSecretSharePrivateKeyReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetSecretSharePrivateKeyReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetSecretSharePrivateKeyReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetSecretSharePrivateKeyReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetSecretSharePrivateKeyReply.Merge(m, src)
}
func (m *SetSecretSharePrivateKeyReply) XXX_Size() int {
	return m.Size()
}
func (m *SetSecretSharePrivateKeyReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SetSecretSharePrivateKeyReply.DiscardUnknown(m)
}

var xxx_messageInfo_SetSecretSharePrivateKeyReply proto.InternalMessageInfo

func (m *SetSecretSharePrivateKeyReply) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type MsgSyncSuspiciousTransactions struct {
	Clear bool `protobuf:"varint,1,opt,name=clear,proto3" json:"clear,omitempty"`
}

func (m *MsgSyncSuspiciousTransactions) Reset()         { *m = MsgSyncSuspiciousTransactions{} }
func (m *MsgSyncSuspiciousTransactions) String() string { return proto.CompactTextString(m) }
func (*MsgSyncSuspiciousTransactions) ProtoMessage()    {}
func (*MsgSyncSuspiciousTransactions) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{37}
}
func (m *MsgSyncSuspiciousTransactions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSyncSuspiciousTransactions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSyncSuspiciousTransactions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSyncSuspiciousTransactions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSyncSuspiciousTransactions.Merge(m, src)
}
func (m *MsgSyncSuspiciousTransactions) XXX_Size() int {
	return m.Size()
}
func (m *MsgSyncSuspiciousTransactions) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSyncSuspiciousTransactions.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSyncSuspiciousTransactions proto.InternalMessageInfo

func (m *MsgSyncSuspiciousTransactions) GetClear() bool {
	if m != nil {
		return m.Clear
	}
	return false
}

type SyncSuspiciousTransactionsReply struct {
	SuspiciousTransactions []*SuspiciousTransaction `protobuf:"bytes,1,rep,name=suspiciousTransactions,proto3" json:"suspiciousTransactions,omitempty"`
}

func (m *SyncSuspiciousTransactionsReply) Reset()         { *m = SyncSuspiciousTransactionsReply{} }
func (m *SyncSuspiciousTransactionsReply) String() string { return proto.CompactTextString(m) }
func (*SyncSuspiciousTransactionsReply) ProtoMessage()    {}
func (*SyncSuspiciousTransactionsReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{38}
}
func (m *SyncSuspiciousTransactionsReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncSuspiciousTransactionsReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncSuspiciousTransactionsReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncSuspiciousTransactionsReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncSuspiciousTransactionsReply.Merge(m, src)
}
func (m *SyncSuspiciousTransactionsReply) XXX_Size() int {
	return m.Size()
}
func (m *SyncSuspiciousTransactionsReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncSuspiciousTransactionsReply.DiscardUnknown(m)
}

var xxx_messageInfo_SyncSuspiciousTransactionsReply proto.InternalMessageInfo

func (m *SyncSuspiciousTransactionsReply) GetSuspiciousTransactions() []*SuspiciousTransaction {
	if m != nil {
		return m.SuspiciousTransactions
	}
	return nil
}

type InitEnclaveReply struct {
	Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *InitEnclaveReply) Reset()         { *m = InitEnclaveReply{} }
func (m *InitEnclaveReply) String() string { return proto.CompactTextString(m) }
func (*InitEnclaveReply) ProtoMessage()    {}
func (*InitEnclaveReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{39}
}
func (m *InitEnclaveReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InitEnclaveReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InitEnclaveReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InitEnclaveReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InitEnclaveReply.Merge(m, src)
}
func (m *InitEnclaveReply) XXX_Size() int {
	return m.Size()
}
func (m *InitEnclaveReply) XXX_DiscardUnknown() {
	xxx_messageInfo_InitEnclaveReply.DiscardUnknown(m)
}

var xxx_messageInfo_InitEnclaveReply proto.InternalMessageInfo

func (m *InitEnclaveReply) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type UpdateHeightReply struct {
	Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *UpdateHeightReply) Reset()         { *m = UpdateHeightReply{} }
func (m *UpdateHeightReply) String() string { return proto.CompactTextString(m) }
func (*UpdateHeightReply) ProtoMessage()    {}
func (*UpdateHeightReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{40}
}
func (m *UpdateHeightReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateHeightReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateHeightReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateHeightReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateHeightReply.Merge(m, src)
}
func (m *UpdateHeightReply) XXX_Size() int {
	return m.Size()
}
func (m *UpdateHeightReply) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateHeightReply.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateHeightReply proto.InternalMessageInfo

func (m *UpdateHeightReply) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type MsgTransactionComplete struct {
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (m *MsgTransactionComplete) Reset()         { *m = MsgTransactionComplete{} }
func (m *MsgTransactionComplete) String() string { return proto.CompactTextString(m) }
func (*MsgTransactionComplete) ProtoMessage()    {}
func (*MsgTransactionComplete) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{41}
}
func (m *MsgTransactionComplete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTransactionComplete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTransactionComplete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTransactionComplete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTransactionComplete.Merge(m, src)
}
func (m *MsgTransactionComplete) XXX_Size() int {
	return m.Size()
}
func (m *MsgTransactionComplete) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTransactionComplete.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTransactionComplete proto.InternalMessageInfo

func (m *MsgTransactionComplete) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type TransactionCompleteReply struct {
	Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *TransactionCompleteReply) Reset()         { *m = TransactionCompleteReply{} }
func (m *TransactionCompleteReply) String() string { return proto.CompactTextString(m) }
func (*TransactionCompleteReply) ProtoMessage()    {}
func (*TransactionCompleteReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{42}
}
func (m *TransactionCompleteReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionCompleteReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionCompleteReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionCompleteReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionCompleteReply.Merge(m, src)
}
func (m *TransactionCompleteReply) XXX_Size() int {
	return m.Size()
}
func (m *TransactionCompleteReply) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionCompleteReply.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionCompleteReply proto.InternalMessageInfo

func (m *TransactionCompleteReply) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type SyncEnclaveReply struct {
	Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *SyncEnclaveReply) Reset()         { *m = SyncEnclaveReply{} }
func (m *SyncEnclaveReply) String() string { return proto.CompactTextString(m) }
func (*SyncEnclaveReply) ProtoMessage()    {}
func (*SyncEnclaveReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{43}
}
func (m *SyncEnclaveReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncEnclaveReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncEnclaveReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncEnclaveReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncEnclaveReply.Merge(m, src)
}
func (m *SyncEnclaveReply) XXX_Size() int {
	return m.Size()
}
func (m *SyncEnclaveReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncEnclaveReply.DiscardUnknown(m)
}

var xxx_messageInfo_SyncEnclaveReply proto.InternalMessageInfo

func (m *SyncEnclaveReply) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type AddAsValidatorReply struct {
	Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *AddAsValidatorReply) Reset()         { *m = AddAsValidatorReply{} }
func (m *AddAsValidatorReply) String() string { return proto.CompactTextString(m) }
func (*AddAsValidatorReply) ProtoMessage()    {}
func (*AddAsValidatorReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{44}
}
func (m *AddAsValidatorReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddAsValidatorReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddAsValidatorReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddAsValidatorReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddAsValidatorReply.Merge(m, src)
}
func (m *AddAsValidatorReply) XXX_Size() int {
	return m.Size()
}
func (m *AddAsValidatorReply) XXX_DiscardUnknown() {
	xxx_messageInfo_AddAsValidatorReply.DiscardUnknown(m)
}

var xxx_messageInfo_AddAsValidatorReply proto.InternalMessageInfo

func (m *AddAsValidatorReply) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type SetWalletReply struct {
	Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *SetWalletReply) Reset()         { *m = SetWalletReply{} }
func (m *SetWalletReply) String() string { return proto.CompactTextString(m) }
func (*SetWalletReply) ProtoMessage()    {}
func (*SetWalletReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{45}
}
func (m *SetWalletReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetWalletReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetWalletReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetWalletReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetWalletReply.Merge(m, src)
}
func (m *SetWalletReply) XXX_Size() int {
	return m.Size()
}
func (m *SetWalletReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SetWalletReply.DiscardUnknown(m)
}

var xxx_messageInfo_SetWalletReply proto.InternalMessageInfo

func (m *SetWalletReply) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type SetEnclaveIdentityReply struct {
	Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *SetEnclaveIdentityReply) Reset()         { *m = SetEnclaveIdentityReply{} }
func (m *SetEnclaveIdentityReply) String() string { return proto.CompactTextString(m) }
func (*SetEnclaveIdentityReply) ProtoMessage()    {}
func (*SetEnclaveIdentityReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{46}
}
func (m *SetEnclaveIdentityReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetEnclaveIdentityReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetEnclaveIdentityReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetEnclaveIdentityReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetEnclaveIdentityReply.Merge(m, src)
}
func (m *SetEnclaveIdentityReply) XXX_Size() int {
	return m.Size()
}
func (m *SetEnclaveIdentityReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SetEnclaveIdentityReply.DiscardUnknown(m)
}

var xxx_messageInfo_SetEnclaveIdentityReply proto.InternalMessageInfo

func (m *SetEnclaveIdentityReply) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type PioneerUpdateEnclaveIdentity struct {
	EnclaveIdentity *EnclaveIdentity `protobuf:"bytes,1,opt,name=enclaveIdentity,proto3" json:"enclaveIdentity,omitempty"`
	RemoteReport    []byte           `protobuf:"bytes,2,opt,name=remoteReport,proto3" json:"remoteReport,omitempty"`
}

func (m *PioneerUpdateEnclaveIdentity) Reset()         { *m = PioneerUpdateEnclaveIdentity{} }
func (m *PioneerUpdateEnclaveIdentity) String() string { return proto.CompactTextString(m) }
func (*PioneerUpdateEnclaveIdentity) ProtoMessage()    {}
func (*PioneerUpdateEnclaveIdentity) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{47}
}
func (m *PioneerUpdateEnclaveIdentity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PioneerUpdateEnclaveIdentity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PioneerUpdateEnclaveIdentity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PioneerUpdateEnclaveIdentity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PioneerUpdateEnclaveIdentity.Merge(m, src)
}
func (m *PioneerUpdateEnclaveIdentity) XXX_Size() int {
	return m.Size()
}
func (m *PioneerUpdateEnclaveIdentity) XXX_DiscardUnknown() {
	xxx_messageInfo_PioneerUpdateEnclaveIdentity.DiscardUnknown(m)
}

var xxx_messageInfo_PioneerUpdateEnclaveIdentity proto.InternalMessageInfo

func (m *PioneerUpdateEnclaveIdentity) GetEnclaveIdentity() *EnclaveIdentity {
	if m != nil {
		return m.EnclaveIdentity
	}
	return nil
}

func (m *PioneerUpdateEnclaveIdentity) GetRemoteReport() []byte {
	if m != nil {
		return m.RemoteReport
	}
	return nil
}

type UpdateEnclaveIdentityReply struct {
	Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *UpdateEnclaveIdentityReply) Reset()         { *m = UpdateEnclaveIdentityReply{} }
func (m *UpdateEnclaveIdentityReply) String() string { return proto.CompactTextString(m) }
func (*UpdateEnclaveIdentityReply) ProtoMessage()    {}
func (*UpdateEnclaveIdentityReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{48}
}
func (m *UpdateEnclaveIdentityReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateEnclaveIdentityReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateEnclaveIdentityReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateEnclaveIdentityReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateEnclaveIdentityReply.Merge(m, src)
}
func (m *UpdateEnclaveIdentityReply) XXX_Size() int {
	return m.Size()
}
func (m *UpdateEnclaveIdentityReply) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateEnclaveIdentityReply.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateEnclaveIdentityReply proto.InternalMessageInfo

func (m *UpdateEnclaveIdentityReply) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type SetProtectKeyReply struct {
	Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *SetProtectKeyReply) Reset()         { *m = SetProtectKeyReply{} }
func (m *SetProtectKeyReply) String() string { return proto.CompactTextString(m) }
func (*SetProtectKeyReply) ProtoMessage()    {}
func (*SetProtectKeyReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{49}
}
func (m *SetProtectKeyReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetProtectKeyReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetProtectKeyReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetProtectKeyReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetProtectKeyReply.Merge(m, src)
}
func (m *SetProtectKeyReply) XXX_Size() int {
	return m.Size()
}
func (m *SetProtectKeyReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SetProtectKeyReply.DiscardUnknown(m)
}

var xxx_messageInfo_SetProtectKeyReply proto.InternalMessageInfo

func (m *SetProtectKeyReply) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type SetRecoverKeyReply struct {
	Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *SetRecoverKeyReply) Reset()         { *m = SetRecoverKeyReply{} }
func (m *SetRecoverKeyReply) String() string { return proto.CompactTextString(m) }
func (*SetRecoverKeyReply) ProtoMessage()    {}
func (*SetRecoverKeyReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{50}
}
func (m *SetRecoverKeyReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetRecoverKeyReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetRecoverKeyReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetRecoverKeyReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetRecoverKeyReply.Merge(m, src)
}
func (m *SetRecoverKeyReply) XXX_Size() int {
	return m.Size()
}
func (m *SetRecoverKeyReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SetRecoverKeyReply.DiscardUnknown(m)
}

var xxx_messageInfo_SetRecoverKeyReply proto.InternalMessageInfo

func (m *SetRecoverKeyReply) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type SetCredentialReply struct {
	Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *SetCredentialReply) Reset()         { *m = SetCredentialReply{} }
func (m *SetCredentialReply) String() string { return proto.CompactTextString(m) }
func (*SetCredentialReply) ProtoMessage()    {}
func (*SetCredentialReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{51}
}
func (m *SetCredentialReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetCredentialReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetCredentialReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetCredentialReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetCredentialReply.Merge(m, src)
}
func (m *SetCredentialReply) XXX_Size() int {
	return m.Size()
}
func (m *SetCredentialReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SetCredentialReply.DiscardUnknown(m)
}

var xxx_messageInfo_SetCredentialReply proto.InternalMessageInfo

func (m *SetCredentialReply) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type RemoveCredentialReply struct {
	Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *RemoveCredentialReply) Reset()         { *m = RemoveCredentialReply{} }
func (m *RemoveCredentialReply) String() string { return proto.CompactTextString(m) }
func (*RemoveCredentialReply) ProtoMessage()    {}
func (*RemoveCredentialReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{52}
}
func (m *RemoveCredentialReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveCredentialReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveCredentialReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveCredentialReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveCredentialReply.Merge(m, src)
}
func (m *RemoveCredentialReply) XXX_Size() int {
	return m.Size()
}
func (m *RemoveCredentialReply) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveCredentialReply.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveCredentialReply proto.InternalMessageInfo

func (m *RemoveCredentialReply) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type RecoverKeyReply struct {
	Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *RecoverKeyReply) Reset()         { *m = RecoverKeyReply{} }
func (m *RecoverKeyReply) String() string { return proto.CompactTextString(m) }
func (*RecoverKeyReply) ProtoMessage()    {}
func (*RecoverKeyReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{53}
}
func (m *RecoverKeyReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoverKeyReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecoverKeyReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecoverKeyReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoverKeyReply.Merge(m, src)
}
func (m *RecoverKeyReply) XXX_Size() int {
	return m.Size()
}
func (m *RecoverKeyReply) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoverKeyReply.DiscardUnknown(m)
}

var xxx_messageInfo_RecoverKeyReply proto.InternalMessageInfo

func (m *RecoverKeyReply) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type SignRecoverKeyReply struct {
	Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *SignRecoverKeyReply) Reset()         { *m = SignRecoverKeyReply{} }
func (m *SignRecoverKeyReply) String() string { return proto.CompactTextString(m) }
func (*SignRecoverKeyReply) ProtoMessage()    {}
func (*SignRecoverKeyReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{54}
}
func (m *SignRecoverKeyReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignRecoverKeyReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignRecoverKeyReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignRecoverKeyReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignRecoverKeyReply.Merge(m, src)
}
func (m *SignRecoverKeyReply) XXX_Size() int {
	return m.Size()
}
func (m *SignRecoverKeyReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SignRecoverKeyReply.DiscardUnknown(m)
}

var xxx_messageInfo_SignRecoverKeyReply proto.InternalMessageInfo

func (m *SignRecoverKeyReply) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type SetPublicKeyReply struct {
	Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *SetPublicKeyReply) Reset()         { *m = SetPublicKeyReply{} }
func (m *SetPublicKeyReply) String() string { return proto.CompactTextString(m) }
func (*SetPublicKeyReply) ProtoMessage()    {}
func (*SetPublicKeyReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{55}
}
func (m *SetPublicKeyReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetPublicKeyReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetPublicKeyReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetPublicKeyReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetPublicKeyReply.Merge(m, src)
}
func (m *SetPublicKeyReply) XXX_Size() int {
	return m.Size()
}
func (m *SetPublicKeyReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SetPublicKeyReply.DiscardUnknown(m)
}

var xxx_messageInfo_SetPublicKeyReply proto.InternalMessageInfo

func (m *SetPublicKeyReply) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type SetJarRegulatorReply struct {
	Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *SetJarRegulatorReply) Reset()         { *m = SetJarRegulatorReply{} }
func (m *SetJarRegulatorReply) String() string { return proto.CompactTextString(m) }
func (*SetJarRegulatorReply) ProtoMessage()    {}
func (*SetJarRegulatorReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{56}
}
func (m *SetJarRegulatorReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetJarRegulatorReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetJarRegulatorReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetJarRegulatorReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetJarRegulatorReply.Merge(m, src)
}
func (m *SetJarRegulatorReply) XXX_Size() int {
	return m.Size()
}
func (m *SetJarRegulatorReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SetJarRegulatorReply.DiscardUnknown(m)
}

var xxx_messageInfo_SetJarRegulatorReply proto.InternalMessageInfo

func (m *SetJarRegulatorReply) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type SetPioneerJarReply struct {
	Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *SetPioneerJarReply) Reset()         { *m = SetPioneerJarReply{} }
func (m *SetPioneerJarReply) String() string { return proto.CompactTextString(m) }
func (*SetPioneerJarReply) ProtoMessage()    {}
func (*SetPioneerJarReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{57}
}
func (m *SetPioneerJarReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetPioneerJarReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetPioneerJarReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetPioneerJarReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetPioneerJarReply.Merge(m, src)
}
func (m *SetPioneerJarReply) XXX_Size() int {
	return m.Size()
}
func (m *SetPioneerJarReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SetPioneerJarReply.DiscardUnknown(m)
}

var xxx_messageInfo_SetPioneerJarReply proto.InternalMessageInfo

func (m *SetPioneerJarReply) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type SetIntervalPublicKeyIdReply struct {
	Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *SetIntervalPublicKeyIdReply) Reset()         { *m = SetIntervalPublicKeyIdReply{} }
func (m *SetIntervalPublicKeyIdReply) String() string { return proto.CompactTextString(m) }
func (*SetIntervalPublicKeyIdReply) ProtoMessage()    {}
func (*SetIntervalPublicKeyIdReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{58}
}
func (m *SetIntervalPublicKeyIdReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetIntervalPublicKeyIdReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetIntervalPublicKeyIdReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetIntervalPublicKeyIdReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetIntervalPublicKeyIdReply.Merge(m, src)
}
func (m *SetIntervalPublicKeyIdReply) XXX_Size() int {
	return m.Size()
}
func (m *SetIntervalPublicKeyIdReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SetIntervalPublicKeyIdReply.DiscardUnknown(m)
}

var xxx_messageInfo_SetIntervalPublicKeyIdReply proto.InternalMessageInfo

func (m *SetIntervalPublicKeyIdReply) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type ValidateDestinationWalletReply struct {
	Status int32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *ValidateDestinationWalletReply) Reset()         { *m = ValidateDestinationWalletReply{} }
func (m *ValidateDestinationWalletReply) String() string { return proto.CompactTextString(m) }
func (*ValidateDestinationWalletReply) ProtoMessage()    {}
func (*ValidateDestinationWalletReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{59}
}
func (m *ValidateDestinationWalletReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateDestinationWalletReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateDestinationWalletReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateDestinationWalletReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateDestinationWalletReply.Merge(m, src)
}
func (m *ValidateDestinationWalletReply) XXX_Size() int {
	return m.Size()
}
func (m *ValidateDestinationWalletReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateDestinationWalletReply.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateDestinationWalletReply proto.InternalMessageInfo

func (m *ValidateDestinationWalletReply) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type ValidateCredentialReply struct {
	Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *ValidateCredentialReply) Reset()         { *m = ValidateCredentialReply{} }
func (m *ValidateCredentialReply) String() string { return proto.CompactTextString(m) }
func (*ValidateCredentialReply) ProtoMessage()    {}
func (*ValidateCredentialReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{60}
}
func (m *ValidateCredentialReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateCredentialReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateCredentialReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateCredentialReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateCredentialReply.Merge(m, src)
}
func (m *ValidateCredentialReply) XXX_Size() int {
	return m.Size()
}
func (m *ValidateCredentialReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateCredentialReply.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateCredentialReply proto.InternalMessageInfo

func (m *ValidateCredentialReply) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type ValidateTransferPrimeReply struct {
	UpdateSourceWallet bool `protobuf:"varint,1,opt,name=updateSourceWallet,proto3" json:"updateSourceWallet,omitempty"`
}

func (m *ValidateTransferPrimeReply) Reset()         { *m = ValidateTransferPrimeReply{} }
func (m *ValidateTransferPrimeReply) String() string { return proto.CompactTextString(m) }
func (*ValidateTransferPrimeReply) ProtoMessage()    {}
func (*ValidateTransferPrimeReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{61}
}
func (m *ValidateTransferPrimeReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateTransferPrimeReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateTransferPrimeReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateTransferPrimeReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateTransferPrimeReply.Merge(m, src)
}
func (m *ValidateTransferPrimeReply) XXX_Size() int {
	return m.Size()
}
func (m *ValidateTransferPrimeReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateTransferPrimeReply.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateTransferPrimeReply proto.InternalMessageInfo

func (m *ValidateTransferPrimeReply) GetUpdateSourceWallet() bool {
	if m != nil {
		return m.UpdateSourceWallet
	}
	return false
}

type ValidateTransferDoublePrimeReply struct {
	UpdateDestinationWallet bool `protobuf:"varint,1,opt,name=updateDestinationWallet,proto3" json:"updateDestinationWallet,omitempty"`
}

func (m *ValidateTransferDoublePrimeReply) Reset()         { *m = ValidateTransferDoublePrimeReply{} }
func (m *ValidateTransferDoublePrimeReply) String() string { return proto.CompactTextString(m) }
func (*ValidateTransferDoublePrimeReply) ProtoMessage()    {}
func (*ValidateTransferDoublePrimeReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{62}
}
func (m *ValidateTransferDoublePrimeReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateTransferDoublePrimeReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateTransferDoublePrimeReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateTransferDoublePrimeReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateTransferDoublePrimeReply.Merge(m, src)
}
func (m *ValidateTransferDoublePrimeReply) XXX_Size() int {
	return m.Size()
}
func (m *ValidateTransferDoublePrimeReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateTransferDoublePrimeReply.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateTransferDoublePrimeReply proto.InternalMessageInfo

func (m *ValidateTransferDoublePrimeReply) GetUpdateDestinationWallet() bool {
	if m != nil {
		return m.UpdateDestinationWallet
	}
	return false
}

type ScanTransactionReply struct {
	Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *ScanTransactionReply) Reset()         { *m = ScanTransactionReply{} }
func (m *ScanTransactionReply) String() string { return proto.CompactTextString(m) }
func (*ScanTransactionReply) ProtoMessage()    {}
func (*ScanTransactionReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{63}
}
func (m *ScanTransactionReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScanTransactionReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScanTransactionReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScanTransactionReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScanTransactionReply.Merge(m, src)
}
func (m *ScanTransactionReply) XXX_Size() int {
	return m.Size()
}
func (m *ScanTransactionReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ScanTransactionReply.DiscardUnknown(m)
}

var xxx_messageInfo_ScanTransactionReply proto.InternalMessageInfo

func (m *ScanTransactionReply) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

// these are used to marshal strings and arrays of strings, needed by the persistent KV implementation in the enclave
type EnclaveStoreStringArray struct {
	A []string `protobuf:"bytes,1,rep,name=a,proto3" json:"a,omitempty"`
}

func (m *EnclaveStoreStringArray) Reset()         { *m = EnclaveStoreStringArray{} }
func (m *EnclaveStoreStringArray) String() string { return proto.CompactTextString(m) }
func (*EnclaveStoreStringArray) ProtoMessage()    {}
func (*EnclaveStoreStringArray) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{64}
}
func (m *EnclaveStoreStringArray) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnclaveStoreStringArray) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnclaveStoreStringArray.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnclaveStoreStringArray) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnclaveStoreStringArray.Merge(m, src)
}
func (m *EnclaveStoreStringArray) XXX_Size() int {
	return m.Size()
}
func (m *EnclaveStoreStringArray) XXX_DiscardUnknown() {
	xxx_messageInfo_EnclaveStoreStringArray.DiscardUnknown(m)
}

var xxx_messageInfo_EnclaveStoreStringArray proto.InternalMessageInfo

func (m *EnclaveStoreStringArray) GetA() []string {
	if m != nil {
		return m.A
	}
	return nil
}

type EnclaveStoreString struct {
	S string `protobuf:"bytes,1,opt,name=s,proto3" json:"s,omitempty"`
}

func (m *EnclaveStoreString) Reset()         { *m = EnclaveStoreString{} }
func (m *EnclaveStoreString) String() string { return proto.CompactTextString(m) }
func (*EnclaveStoreString) ProtoMessage()    {}
func (*EnclaveStoreString) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{65}
}
func (m *EnclaveStoreString) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnclaveStoreString) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnclaveStoreString.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnclaveStoreString) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnclaveStoreString.Merge(m, src)
}
func (m *EnclaveStoreString) XXX_Size() int {
	return m.Size()
}
func (m *EnclaveStoreString) XXX_DiscardUnknown() {
	xxx_messageInfo_EnclaveStoreString.DiscardUnknown(m)
}

var xxx_messageInfo_EnclaveStoreString proto.InternalMessageInfo

func (m *EnclaveStoreString) GetS() string {
	if m != nil {
		return m.S
	}
	return ""
}

type EnclaveEnclaveIdentityArray struct {
	Identity []*EnclaveIdentity `protobuf:"bytes,1,rep,name=identity,proto3" json:"identity,omitempty"`
}

func (m *EnclaveEnclaveIdentityArray) Reset()         { *m = EnclaveEnclaveIdentityArray{} }
func (m *EnclaveEnclaveIdentityArray) String() string { return proto.CompactTextString(m) }
func (*EnclaveEnclaveIdentityArray) ProtoMessage()    {}
func (*EnclaveEnclaveIdentityArray) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e54b2b36e7bc973, []int{66}
}
func (m *EnclaveEnclaveIdentityArray) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnclaveEnclaveIdentityArray) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnclaveEnclaveIdentityArray.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnclaveEnclaveIdentityArray) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnclaveEnclaveIdentityArray.Merge(m, src)
}
func (m *EnclaveEnclaveIdentityArray) XXX_Size() int {
	return m.Size()
}
func (m *EnclaveEnclaveIdentityArray) XXX_DiscardUnknown() {
	xxx_messageInfo_EnclaveEnclaveIdentityArray.DiscardUnknown(m)
}

var xxx_messageInfo_EnclaveEnclaveIdentityArray proto.InternalMessageInfo

func (m *EnclaveEnclaveIdentityArray) GetIdentity() []*EnclaveIdentity {
	if m != nil {
		return m.Identity
	}
	return nil
}

func init() {
	proto.RegisterType((*HelloRequest)(nil), "qadena.qadena.HelloRequest")
	proto.RegisterType((*HelloReply)(nil), "qadena.qadena.HelloReply")
	proto.RegisterType((*MsgEndBlock)(nil), "qadena.qadena.MsgEndBlock")
	proto.RegisterType((*EndBlockReply)(nil), "qadena.qadena.EndBlockReply")
	proto.RegisterType((*QueryGetSubWalletIDByOriginalWalletIDResponse)(nil), "qadena.qadena.QueryGetSubWalletIDByOriginalWalletIDResponse")
	proto.RegisterType((*StoreHash)(nil), "qadena.qadena.StoreHash")
	proto.RegisterType((*MsgGetStoreHash)(nil), "qadena.qadena.MsgGetStoreHash")
	proto.RegisterType((*GetStoreHashReply)(nil), "qadena.qadena.GetStoreHashReply")
	proto.RegisterType((*MsgAddAsValidator)(nil), "qadena.qadena.MsgAddAsValidator")
	proto.RegisterType((*MsgSyncEnclave)(nil), "qadena.qadena.MsgSyncEnclave")
	proto.RegisterType((*MsgUpgradeEnclave)(nil), "qadena.qadena.MsgUpgradeEnclave")
	proto.RegisterType((*UpgradeEnclaveReply)(nil), "qadena.qadena.UpgradeEnclaveReply")
	proto.RegisterType((*MsgExportPrivateKey)(nil), "qadena.qadena.MsgExportPrivateKey")
	proto.RegisterType((*MsgRemovePrivateKey)(nil), "qadena.qadena.MsgRemovePrivateKey")
	proto.RegisterType((*MsgExportPrivateState)(nil), "qadena.qadena.MsgExportPrivateState")
	proto.RegisterType((*MsgUpdateSSIntervalKey)(nil), "qadena.qadena.MsgUpdateSSIntervalKey")
	proto.RegisterType((*UpdateSSIntervalKeyReply)(nil), "qadena.qadena.UpdateSSIntervalKeyReply")
	proto.RegisterType((*RemovePrivateKeyReply)(nil), "qadena.qadena.RemovePrivateKeyReply")
	proto.RegisterType((*ExportPrivateKeyReply)(nil), "qadena.qadena.ExportPrivateKeyReply")
	proto.RegisterType((*ExportPrivateStateReply)(nil), "qadena.qadena.ExportPrivateStateReply")
	proto.RegisterType((*ValidateAuthenticateServiceProviderRequest)(nil), "qadena.qadena.ValidateAuthenticateServiceProviderRequest")
	proto.RegisterType((*ValidateAuthenticateServiceProviderReply)(nil), "qadena.qadena.ValidateAuthenticateServiceProviderReply")
	proto.RegisterType((*MsgInitEnclave)(nil), "qadena.qadena.MsgInitEnclave")
	proto.RegisterType((*VShareSignatory)(nil), "qadena.qadena.VShareSignatory")
	proto.RegisterType((*ValidateAuthorizedSignerRequest)(nil), "qadena.qadena.ValidateAuthorizedSignerRequest")
	proto.RegisterType((*ValidateAuthorizedSignerReply)(nil), "qadena.qadena.ValidateAuthorizedSignerReply")
	proto.RegisterType((*ValidateAuthorizedSignatoryRequest)(nil), "qadena.qadena.ValidateAuthorizedSignatoryRequest")
	proto.RegisterType((*ValidateAuthorizedSignatoryReply)(nil), "qadena.qadena.ValidateAuthorizedSignatoryReply")
	proto.RegisterType((*MsgUpdateHeight)(nil), "qadena.qadena.MsgUpdateHeight")
	proto.RegisterType((*MsgScanTransactions)(nil), "qadena.qadena.MsgScanTransactions")
	proto.RegisterType((*MsgSyncWallets)(nil), "qadena.qadena.MsgSyncWallets")
	proto.RegisterType((*SyncWalletsReply)(nil), "qadena.qadena.SyncWalletsReply")
	proto.RegisterType((*MsgSyncCredentials)(nil), "qadena.qadena.MsgSyncCredentials")
	proto.RegisterType((*SyncCredentialsReply)(nil), "qadena.qadena.SyncCredentialsReply")
	proto.RegisterType((*MsgSyncRecoverKeys)(nil), "qadena.qadena.MsgSyncRecoverKeys")
	proto.RegisterType((*SyncRecoverKeysReply)(nil), "qadena.qadena.SyncRecoverKeysReply")
	proto.RegisterType((*SetSecretSharePrivateKeyReply)(nil), "qadena.qadena.SetSecretSharePrivateKeyReply")
	proto.RegisterType((*MsgSyncSuspiciousTransactions)(nil), "qadena.qadena.MsgSyncSuspiciousTransactions")
	proto.RegisterType((*SyncSuspiciousTransactionsReply)(nil), "qadena.qadena.SyncSuspiciousTransactionsReply")
	proto.RegisterType((*InitEnclaveReply)(nil), "qadena.qadena.InitEnclaveReply")
	proto.RegisterType((*UpdateHeightReply)(nil), "qadena.qadena.UpdateHeightReply")
	proto.RegisterType((*MsgTransactionComplete)(nil), "qadena.qadena.MsgTransactionComplete")
	proto.RegisterType((*TransactionCompleteReply)(nil), "qadena.qadena.TransactionCompleteReply")
	proto.RegisterType((*SyncEnclaveReply)(nil), "qadena.qadena.SyncEnclaveReply")
	proto.RegisterType((*AddAsValidatorReply)(nil), "qadena.qadena.AddAsValidatorReply")
	proto.RegisterType((*SetWalletReply)(nil), "qadena.qadena.SetWalletReply")
	proto.RegisterType((*SetEnclaveIdentityReply)(nil), "qadena.qadena.SetEnclaveIdentityReply")
	proto.RegisterType((*PioneerUpdateEnclaveIdentity)(nil), "qadena.qadena.PioneerUpdateEnclaveIdentity")
	proto.RegisterType((*UpdateEnclaveIdentityReply)(nil), "qadena.qadena.UpdateEnclaveIdentityReply")
	proto.RegisterType((*SetProtectKeyReply)(nil), "qadena.qadena.SetProtectKeyReply")
	proto.RegisterType((*SetRecoverKeyReply)(nil), "qadena.qadena.SetRecoverKeyReply")
	proto.RegisterType((*SetCredentialReply)(nil), "qadena.qadena.SetCredentialReply")
	proto.RegisterType((*RemoveCredentialReply)(nil), "qadena.qadena.RemoveCredentialReply")
	proto.RegisterType((*RecoverKeyReply)(nil), "qadena.qadena.RecoverKeyReply")
	proto.RegisterType((*SignRecoverKeyReply)(nil), "qadena.qadena.SignRecoverKeyReply")
	proto.RegisterType((*SetPublicKeyReply)(nil), "qadena.qadena.SetPublicKeyReply")
	proto.RegisterType((*SetJarRegulatorReply)(nil), "qadena.qadena.SetJarRegulatorReply")
	proto.RegisterType((*SetPioneerJarReply)(nil), "qadena.qadena.SetPioneerJarReply")
	proto.RegisterType((*SetIntervalPublicKeyIdReply)(nil), "qadena.qadena.SetIntervalPublicKeyIdReply")
	proto.RegisterType((*ValidateDestinationWalletReply)(nil), "qadena.qadena.ValidateDestinationWalletReply")
	proto.RegisterType((*ValidateCredentialReply)(nil), "qadena.qadena.ValidateCredentialReply")
	proto.RegisterType((*ValidateTransferPrimeReply)(nil), "qadena.qadena.ValidateTransferPrimeReply")
	proto.RegisterType((*ValidateTransferDoublePrimeReply)(nil), "qadena.qadena.ValidateTransferDoublePrimeReply")
	proto.RegisterType((*ScanTransactionReply)(nil), "qadena.qadena.ScanTransactionReply")
	proto.RegisterType((*EnclaveStoreStringArray)(nil), "qadena.qadena.EnclaveStoreStringArray")
	proto.RegisterType((*EnclaveStoreString)(nil), "qadena.qadena.EnclaveStoreString")
	proto.RegisterType((*EnclaveEnclaveIdentityArray)(nil), "qadena.qadena.EnclaveEnclaveIdentityArray")
}

func init() { proto.RegisterFile("qadena/qadena/enclave.proto", fileDescriptor_3e54b2b36e7bc973) }

var fileDescriptor_3e54b2b36e7bc973 = []byte{
	// 2593 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x5a, 0x4f, 0x73, 0xd4, 0xc8,
	0x15, 0xd7, 0xe0, 0x05, 0xec, 0x67, 0x83, 0x71, 0x1b, 0xdb, 0x83, 0xbc, 0x8c, 0x4d, 0xb3, 0x2c,
	0xc6, 0xe0, 0xf1, 0x62, 0x92, 0xec, 0x86, 0x6c, 0x0e, 0x36, 0xe6, 0x8f, 0xd7, 0xb0, 0x98, 0x19,
	0x96, 0x64, 0x13, 0x6a, 0x27, 0xb2, 0xa6, 0x77, 0x2c, 0x98, 0x91, 0xc6, 0x2d, 0xcd, 0x84, 0xd9,
	0x4a, 0x55, 0x52, 0x49, 0x55, 0x72, 0xc9, 0x61, 0xef, 0xa9, 0xca, 0x17, 0x48, 0x55, 0x3e, 0x07,
	0xc7, 0x3d, 0xa6, 0x72, 0x48, 0x52, 0xf0, 0x11, 0xf2, 0x05, 0x52, 0xea, 0x6e, 0x49, 0x2d, 0x75,
	0x4b, 0x23, 0xf6, 0x96, 0xd3, 0xa8, 0xbb, 0x7f, 0xef, 0x5f, 0xab, 0xdf, 0xeb, 0xf7, 0x9e, 0x06,
	0x96, 0x8f, 0xad, 0x36, 0x71, 0xad, 0x4d, 0xf1, 0x43, 0x5c, 0xbb, 0x6b, 0x0d, 0x49, 0xbd, 0x4f,
	0xbd, 0xc0, 0x43, 0x67, 0xf8, 0x6c, 0x9d, 0xff, 0x98, 0x66, 0x1a, 0xfb, 0x6b, 0xab, 0xdb, 0x25,
	0x01, 0x87, 0x9a, 0x8b, 0xe9, 0xb5, 0xe0, 0x95, 0x98, 0xaf, 0xa5, 0xe7, 0x6d, 0x4a, 0xda, 0xc4,
	0x0d, 0x1c, 0xab, 0x2b, 0xd6, 0xd7, 0xd3, 0xeb, 0xfe, 0xc0, 0xef, 0x3b, 0xb6, 0xe3, 0x0d, 0xfc,
	0x56, 0x40, 0x2d, 0xd7, 0xb7, 0xec, 0xc0, 0xf1, 0x5c, 0x3d, 0xaf, 0xfe, 0xe0, 0xb0, 0xeb, 0xd8,
	0xad, 0x97, 0x64, 0x24, 0xd6, 0x2f, 0xa5, 0xd7, 0x5f, 0x58, 0xb4, 0x45, 0x49, 0x67, 0xd0, 0xb5,
	0x02, 0x8f, 0x0a, 0xc8, 0xf5, 0x34, 0xc4, 0x71, 0x03, 0x42, 0x87, 0x56, 0xb7, 0x95, 0xf0, 0x6a,
	0x39, 0xad, 0xb6, 0x00, 0x5f, 0xcd, 0xe8, 0x46, 0x6c, 0x4a, 0x82, 0x96, 0x7f, 0x64, 0x51, 0xd2,
	0xea, 0x53, 0x67, 0xd8, 0x7a, 0x29, 0x80, 0x17, 0xd2, 0xc0, 0xe3, 0x01, 0xa1, 0x91, 0x4e, 0x2b,
	0x19, 0x9d, 0xa9, 0x17, 0x10, 0x3b, 0x90, 0x94, 0xce, 0x00, 0x28, 0xb1, 0xbd, 0x21, 0xa1, 0x12,
	0xe0, 0x4a, 0x1a, 0x30, 0x14, 0x0a, 0x1c, 0x3a, 0x6e, 0xbb, 0xd5, 0xb6, 0x02, 0x2b, 0x47, 0x90,
	0xe3, 0xb9, 0x84, 0xd0, 0xd6, 0x0b, 0x2b, 0x32, 0xfd, 0x03, 0xed, 0x9b, 0x6e, 0x39, 0xec, 0x7d,
	0x04, 0xb1, 0x3a, 0x1d, 0xcf, 0xeb, 0x74, 0x09, 0x53, 0xd4, 0x3b, 0x1c, 0x7c, 0xbd, 0x19, 0x38,
	0x3d, 0xe2, 0x07, 0x56, 0xaf, 0x2f, 0x00, 0xe7, 0x3b, 0x5e, 0xc7, 0x63, 0x8f, 0x9b, 0xe1, 0x13,
	0x9f, 0xc5, 0x18, 0x66, 0x1e, 0x90, 0x6e, 0xd7, 0x6b, 0x90, 0xe3, 0x01, 0xf1, 0x03, 0x84, 0xe0,
	0x3d, 0xd7, 0xea, 0x91, 0x6a, 0x65, 0xb5, 0xb2, 0x36, 0xd5, 0x60, 0xcf, 0xf8, 0x43, 0x00, 0x81,
	0xe9, 0x77, 0x47, 0xa8, 0x0a, 0xa7, 0x7b, 0xc4, 0xf7, 0xad, 0x4e, 0x04, 0x8a, 0x86, 0xf8, 0x0c,
	0x4c, 0x3f, 0xf2, 0x3b, 0x77, 0xdd, 0xf6, 0x4e, 0xd7, 0xb3, 0x5f, 0xe2, 0x59, 0x38, 0x13, 0x3d,
	0x33, 0x4a, 0xfc, 0x04, 0x36, 0x9e, 0x84, 0x3b, 0x7c, 0x9f, 0x04, 0xcd, 0xc1, 0xe1, 0xcf, 0xd8,
	0x29, 0xdc, 0xdb, 0xdd, 0x19, 0x3d, 0xa6, 0x4e, 0xc7, 0x71, 0xad, 0x6e, 0x34, 0xd3, 0x20, 0x7e,
	0xdf, 0x73, 0x7d, 0x82, 0x56, 0x61, 0xda, 0x4f, 0x80, 0x42, 0x9c, 0x3c, 0x85, 0x6f, 0xc2, 0x54,
	0x33, 0xf0, 0x28, 0x79, 0x60, 0xf9, 0x47, 0xe8, 0x1c, 0x4c, 0xbc, 0x24, 0x23, 0x01, 0x0b, 0x1f,
	0x43, 0x6b, 0x8e, 0x2c, 0xff, 0xa8, 0x7a, 0x82, 0x5b, 0x13, 0x3e, 0xe3, 0x39, 0x98, 0x7d, 0xe4,
	0x77, 0x42, 0x1d, 0x22, 0x42, 0x7c, 0x17, 0xe6, 0xe4, 0x31, 0xb7, 0xf3, 0x23, 0x38, 0x15, 0xe2,
	0x89, 0x5f, 0xad, 0xac, 0x4e, 0xac, 0x4d, 0x6f, 0x55, 0xeb, 0x29, 0xa7, 0xaa, 0x27, 0x70, 0x81,
	0xc3, 0xf3, 0x30, 0xf7, 0xc8, 0xef, 0x6c, 0xb7, 0xdb, 0xdb, 0xfe, 0x33, 0xab, 0xeb, 0xb4, 0xc3,
	0xe3, 0x8b, 0xff, 0x59, 0x81, 0xb3, 0x8f, 0xfc, 0x4e, 0x73, 0xe4, 0xda, 0x77, 0xf9, 0x9b, 0x43,
	0xef, 0xc3, 0x94, 0x78, 0xcb, 0xb1, 0x51, 0xc9, 0x04, 0x5a, 0x83, 0x59, 0xf2, 0x2a, 0x20, 0xd4,
	0xb5, 0xba, 0xdb, 0xed, 0x36, 0x25, 0xbe, 0x2f, 0xd4, 0xcf, 0x4e, 0xa3, 0x1b, 0x30, 0x27, 0xc8,
	0xb6, 0x69, 0xcf, 0xa3, 0x07, 0xd4, 0x19, 0xee, 0x57, 0x27, 0x18, 0x56, 0x5d, 0x40, 0x3f, 0x82,
	0xc5, 0xd4, 0xa4, 0xe5, 0xfb, 0x07, 0x47, 0xd4, 0xf2, 0x49, 0xf5, 0x3d, 0x46, 0x92, 0xb3, 0x8a,
	0x4c, 0x98, 0xf4, 0x09, 0x69, 0x7f, 0xee, 0xb5, 0x49, 0xf5, 0x24, 0x43, 0xc6, 0x63, 0xfc, 0x25,
	0xb3, 0xf8, 0x8b, 0x7e, 0x87, 0x5a, 0x6d, 0x12, 0x99, 0x87, 0x61, 0x86, 0x92, 0x9e, 0x17, 0x90,
	0x06, 0xe9, 0x7b, 0x34, 0x60, 0x16, 0xce, 0x34, 0x52, 0x73, 0xe1, 0x9b, 0x15, 0xe7, 0xf8, 0x60,
	0x70, 0xb8, 0x2f, 0x0c, 0x94, 0xa7, 0xf0, 0x9f, 0x2a, 0x30, 0x9f, 0x66, 0xcc, 0x5f, 0x4b, 0x19,
	0xee, 0x0f, 0xe1, 0x12, 0x89, 0xb7, 0x3b, 0xb4, 0xde, 0x0a, 0x48, 0x33, 0xb0, 0x82, 0x88, 0x53,
	0x2c, 0x73, 0xa6, 0x31, 0x1e, 0x88, 0x37, 0x60, 0x3e, 0x3c, 0xd6, 0xaf, 0x42, 0xd6, 0x02, 0xb3,
	0x4f, 0x46, 0x68, 0x11, 0x4e, 0xf5, 0x07, 0x87, 0xfb, 0xf1, 0x2b, 0x14, 0x23, 0x01, 0x6f, 0x90,
	0x9e, 0x17, 0xb3, 0x2c, 0x82, 0x2f, 0xc1, 0x42, 0x96, 0x3b, 0xd3, 0x00, 0x57, 0x61, 0x91, 0xed,
	0x6d, 0x3b, 0x9c, 0x69, 0xee, 0x89, 0x80, 0xb7, 0x4f, 0x46, 0xd8, 0x84, 0xaa, 0x66, 0x9a, 0xfb,
	0xd8, 0x12, 0x2c, 0x64, 0x45, 0xf3, 0x85, 0x0d, 0x58, 0xc8, 0x9a, 0xc0, 0x37, 0xf4, 0x3c, 0x9c,
	0xec, 0xb3, 0x93, 0xc3, 0xf5, 0xe2, 0x03, 0xbc, 0x09, 0x4b, 0xaa, 0x4e, 0x31, 0x81, 0x1f, 0x8e,
	0x22, 0x02, 0x36, 0xc0, 0x43, 0x58, 0x17, 0x87, 0x9e, 0x6c, 0x0f, 0x82, 0xa3, 0x30, 0x36, 0xd9,
	0x21, 0x1d, 0xa1, 0x43, 0xc7, 0x26, 0x07, 0xd4, 0x1b, 0x3a, 0x6d, 0x42, 0xa3, 0x30, 0x93, 0xb3,
	0x1b, 0xe8, 0x23, 0x98, 0xf7, 0xd3, 0x14, 0x4f, 0x47, 0x7d, 0x22, 0xce, 0x87, 0x6e, 0x09, 0xef,
	0xc0, 0x5a, 0x29, 0xb9, 0xa1, 0xe6, 0x8b, 0x70, 0x2a, 0x54, 0x76, 0xe0, 0x33, 0xa9, 0x93, 0x0d,
	0x31, 0xc2, 0x7f, 0x3f, 0xc1, 0x7c, 0x74, 0xcf, 0x75, 0x82, 0xff, 0x4f, 0x1f, 0x3d, 0x0f, 0x27,
	0x5f, 0x58, 0xa1, 0xa6, 0xdc, 0x41, 0xf9, 0x20, 0x74, 0xb2, 0xf8, 0x1a, 0xdd, 0xdb, 0xad, 0x9e,
	0xe2, 0x4e, 0x26, 0x4d, 0x31, 0xdf, 0x76, 0x3a, 0x2e, 0x33, 0xf2, 0xb4, 0xf0, 0x6d, 0x31, 0x0e,
	0xd7, 0x06, 0xae, 0x73, 0x3c, 0x20, 0x7b, 0xbb, 0xd5, 0x49, 0xbe, 0x16, 0x8d, 0xf1, 0xef, 0x2a,
	0x30, 0xfb, 0xac, 0x19, 0x5e, 0x67, 0x4d, 0xa7, 0xe3, 0x86, 0xcc, 0x46, 0xa8, 0x0e, 0x88, 0xb8,
	0x76, 0x3c, 0xe6, 0xcb, 0xc2, 0x3d, 0x35, 0x2b, 0xe8, 0xa7, 0x00, 0x43, 0xf6, 0xb4, 0xe3, 0xb8,
	0x6d, 0xb6, 0x7d, 0xd3, 0x5b, 0x17, 0x33, 0x31, 0xf6, 0x59, 0x0c, 0xd8, 0xb5, 0x02, 0xab, 0x21,
	0x11, 0xe0, 0xbf, 0x9d, 0x80, 0x15, 0xf9, 0xc5, 0x7b, 0xd4, 0xf9, 0x86, 0xb4, 0x9b, 0x4c, 0xfb,
	0xe8, 0x94, 0x55, 0xe1, 0xb4, 0x4d, 0x49, 0x28, 0x34, 0xba, 0xaa, 0xc4, 0x10, 0x1d, 0xc0, 0x3c,
	0xe5, 0x20, 0xc7, 0xed, 0xc4, 0x9a, 0x09, 0x2d, 0x6a, 0x5a, 0x2d, 0x62, 0x54, 0x43, 0x47, 0x8a,
	0x1e, 0xc2, 0x5c, 0x38, 0xed, 0x50, 0xae, 0x04, 0xe7, 0x37, 0xc1, 0x6e, 0x8e, 0x71, 0xfc, 0x54,
	0x42, 0xf4, 0x39, 0x20, 0xdb, 0xeb, 0xf5, 0xbb, 0x24, 0x90, 0xd9, 0xbd, 0x57, 0x8a, 0x9d, 0x86,
	0x12, 0x7f, 0x0c, 0x17, 0xf3, 0x37, 0xab, 0xc8, 0x35, 0x5e, 0x57, 0x00, 0xeb, 0x29, 0xb9, 0xb0,
	0xb1, 0x3b, 0xfd, 0x29, 0x4c, 0xf9, 0xef, 0xb8, 0xbf, 0x09, 0x01, 0xfa, 0x0c, 0xce, 0xd9, 0x03,
	0x4a, 0x89, 0x1b, 0xbc, 0xeb, 0xa6, 0x2a, 0x74, 0xf8, 0x36, 0xac, 0x16, 0x5a, 0x52, 0xb4, 0x0d,
	0x7b, 0x2c, 0x69, 0xe0, 0x51, 0xf7, 0x01, 0x71, 0x3a, 0x47, 0x2c, 0x84, 0x1d, 0xb1, 0x27, 0x06,
	0x9d, 0x68, 0x88, 0x11, 0xaa, 0x01, 0x38, 0xfe, 0x01, 0xf5, 0xfa, 0x9e, 0x4f, 0x28, 0xb3, 0x78,
	0xb2, 0x21, 0xcd, 0x84, 0x3b, 0x1a, 0x5e, 0x10, 0x4d, 0xdb, 0x72, 0x9f, 0x26, 0x99, 0xb2, 0x8f,
	0x76, 0x60, 0x2a, 0x4e, 0xd9, 0x18, 0xcb, 0xe9, 0x2d, 0xb3, 0xce, 0x93, 0xba, 0x7a, 0x94, 0xd4,
	0xd5, 0x9f, 0x46, 0x88, 0x9d, 0xc9, 0xd7, 0xff, 0x5a, 0x31, 0xbe, 0xfd, 0xf7, 0x4a, 0xa5, 0x91,
	0x90, 0x49, 0x3a, 0x9d, 0x48, 0xe9, 0x74, 0x13, 0x26, 0x7a, 0x7e, 0x87, 0xc5, 0x9d, 0xe9, 0xad,
	0x95, 0xcc, 0xce, 0x3d, 0xf2, 0x3b, 0x4c, 0x91, 0xaf, 0x09, 0xbd, 0x37, 0x70, 0xdb, 0x7e, 0x23,
	0xc4, 0x86, 0xf7, 0x2c, 0x79, 0x65, 0x1f, 0x59, 0x6e, 0x87, 0xd0, 0x30, 0xd8, 0xf3, 0x00, 0x94,
	0x9a, 0xc3, 0x1f, 0xc6, 0xa9, 0x0d, 0x4f, 0xc8, 0xfc, 0x30, 0x10, 0xd9, 0x5d, 0x62, 0x51, 0xb1,
	0x7d, 0x7c, 0x80, 0xef, 0xc0, 0x39, 0x09, 0xc4, 0x77, 0x7a, 0x13, 0x4e, 0xf3, 0x3a, 0x24, 0xca,
	0xaf, 0x16, 0x32, 0x6a, 0x71, 0x74, 0x23, 0x42, 0xe1, 0x75, 0x40, 0x42, 0xd8, 0x9d, 0xb8, 0x16,
	0xc9, 0x13, 0xd8, 0x84, 0xf3, 0x19, 0x20, 0x17, 0xfa, 0x13, 0x98, 0x4e, 0x0a, 0x99, 0x48, 0xf0,
	0x85, 0x8c, 0xe0, 0x84, 0xaa, 0x21, 0xa3, 0x25, 0x05, 0x1a, 0x3c, 0xd7, 0xdf, 0x27, 0xa3, 0x31,
	0x0a, 0x48, 0xc0, 0x58, 0x01, 0x9a, 0xcc, 0xe5, 0x28, 0x90, 0x50, 0x35, 0x64, 0x74, 0xe8, 0xc4,
	0x4d, 0x12, 0x34, 0x59, 0x35, 0xc3, 0x4e, 0x7b, 0xf6, 0x2a, 0xcf, 0x3b, 0xbd, 0x3f, 0x84, 0x8b,
	0x42, 0xf3, 0x66, 0x5c, 0xa6, 0xa5, 0xce, 0x9e, 0xde, 0x88, 0xdf, 0xc2, 0x4a, 0x3e, 0x0d, 0x97,
	0xf8, 0x1c, 0x16, 0x7d, 0xed, 0xb2, 0x30, 0xed, 0x83, 0x6c, 0xd2, 0xac, 0x03, 0x37, 0x72, 0x78,
	0xe0, 0x75, 0x38, 0x27, 0xdd, 0xc9, 0xc5, 0x36, 0x5e, 0x87, 0x39, 0xd9, 0x3d, 0x8b, 0xc1, 0x5b,
	0x2c, 0xb7, 0x92, 0x64, 0xdd, 0x11, 0x21, 0x33, 0x0c, 0x64, 0xfe, 0xc0, 0xb6, 0xc3, 0x1b, 0x9d,
	0x93, 0x44, 0x43, 0xbc, 0x05, 0x55, 0x0d, 0x41, 0xb1, 0x9c, 0x75, 0x7e, 0xf0, 0x4b, 0x19, 0xb0,
	0x01, 0xf3, 0xe9, 0xd2, 0xa1, 0x18, 0xbe, 0x06, 0x67, 0x9b, 0x24, 0x10, 0x4e, 0x52, 0x88, 0xbc,
	0x09, 0x4b, 0x4d, 0x12, 0x6d, 0xe2, 0x9e, 0xa8, 0x1a, 0x8b, 0x49, 0xfe, 0x5c, 0x81, 0xf7, 0x0f,
	0x78, 0xaa, 0xc1, 0x37, 0x35, 0x43, 0x8d, 0x1e, 0xc0, 0x2c, 0x49, 0x4f, 0x89, 0x90, 0x95, 0x0d,
	0xcb, 0x59, 0xb1, 0x59, 0x32, 0x25, 0x9f, 0x3f, 0xa1, 0xe6, 0xf3, 0xf8, 0x07, 0x60, 0x6a, 0xd5,
	0x28, 0x36, 0xe2, 0x06, 0xa0, 0x26, 0x09, 0x0e, 0x78, 0xe1, 0x3e, 0xd6, 0x47, 0x38, 0x5a, 0x72,
	0xbd, 0x12, 0x68, 0x29, 0x52, 0x14, 0xa2, 0x37, 0xa3, 0xa4, 0xbc, 0x2c, 0xc1, 0x35, 0x98, 0x2d,
	0xab, 0xc9, 0x06, 0xcc, 0x87, 0x77, 0x58, 0x59, 0xf8, 0x75, 0x98, 0x0b, 0x37, 0x85, 0x75, 0x4d,
	0xc6, 0x82, 0xeb, 0x70, 0xbe, 0x49, 0x82, 0xcf, 0x2c, 0xda, 0x88, 0x72, 0xc6, 0x52, 0x3b, 0xce,
	0x0f, 0x0e, 0x23, 0x2b, 0x8e, 0x4a, 0xcb, 0x4d, 0x12, 0x44, 0x15, 0x4c, 0xac, 0xd2, 0x5e, 0xbb,
	0x98, 0xec, 0x13, 0xa8, 0x45, 0xd7, 0xf8, 0x2e, 0x4b, 0xc2, 0xac, 0xd0, 0x1f, 0xf3, 0x1d, 0xe1,
	0xa4, 0xec, 0x08, 0x11, 0x65, 0xd9, 0x17, 0xf1, 0x10, 0xcc, 0x88, 0x24, 0xba, 0x23, 0x0f, 0xa8,
	0xd3, 0x13, 0xae, 0x5c, 0x07, 0x34, 0xe0, 0x85, 0x98, 0x37, 0xa0, 0x36, 0xe1, 0x3a, 0x08, 0x0e,
	0x9a, 0x15, 0xfc, 0x3c, 0xc9, 0x40, 0x22, 0x6e, 0xbb, 0xde, 0xe0, 0xb0, 0x4b, 0x24, 0x9e, 0x9f,
	0xc0, 0x12, 0xa7, 0x54, 0x8c, 0x13, 0x8c, 0xf3, 0x96, 0xd9, 0xdb, 0x4a, 0x27, 0x15, 0xc5, 0xb6,
	0x5d, 0x85, 0x25, 0xe1, 0x4f, 0xac, 0x95, 0xd1, 0x0c, 0xa8, 0xe3, 0x76, 0xb6, 0x29, 0xb5, 0x46,
	0x68, 0x06, 0x2a, 0x16, 0x8b, 0xe0, 0x53, 0x8d, 0x8a, 0x85, 0x31, 0x20, 0x15, 0x18, 0x62, 0x7c,
	0x91, 0xec, 0x55, 0x7c, 0xfc, 0x25, 0x2c, 0x0b, 0x4c, 0xc6, 0x47, 0x39, 0xc3, 0xdb, 0x30, 0xe9,
	0x24, 0x81, 0x62, 0xa2, 0x44, 0xa0, 0x88, 0xf1, 0x5b, 0x8f, 0xe1, 0xf4, 0x7d, 0x4a, 0x48, 0x40,
	0x28, 0xda, 0x85, 0xc9, 0xa6, 0x35, 0x62, 0xcd, 0x28, 0xb4, 0x9c, 0x61, 0x20, 0xb7, 0xb1, 0xcc,
	0x0b, 0xfa, 0xc5, 0xb0, 0x10, 0x36, 0xb6, 0xfe, 0x7b, 0x19, 0xce, 0x3c, 0x61, 0xf3, 0x51, 0xb5,
	0xf7, 0x18, 0xa6, 0xe5, 0xe2, 0xef, 0xa2, 0x9a, 0x21, 0x49, 0xcb, 0x66, 0x36, 0x81, 0xca, 0xde,
	0x51, 0xd8, 0x08, 0x19, 0xca, 0x1d, 0x1f, 0x0d, 0x43, 0x69, 0x59, 0x61, 0x98, 0xbd, 0x33, 0xb0,
	0x81, 0x7e, 0x0e, 0x67, 0x33, 0x6d, 0x96, 0x55, 0x95, 0x67, 0x1a, 0x61, 0xe2, 0x0c, 0x42, 0xd3,
	0x4e, 0xc1, 0x06, 0xfa, 0x0a, 0xce, 0x29, 0xbd, 0x0d, 0xac, 0xf2, 0xce, 0x62, 0xcc, 0xec, 0xd5,
	0xae, 0xed, 0x2e, 0x60, 0x03, 0xb5, 0x01, 0xa9, 0x9d, 0x04, 0xf4, 0xc1, 0x18, 0x09, 0x0c, 0x65,
	0x7e, 0x58, 0x24, 0x23, 0x69, 0x49, 0x70, 0x2b, 0x94, 0x96, 0x8b, 0xc6, 0x8a, 0x2c, 0x46, 0xb1,
	0x42, 0xdf, 0x3c, 0x31, 0x50, 0x07, 0xe6, 0x35, 0x3d, 0x17, 0x74, 0x45, 0xf7, 0x12, 0x14, 0x98,
	0x79, 0x55, 0x79, 0x13, 0x39, 0xed, 0x1b, 0x03, 0x7d, 0x03, 0x4b, 0xac, 0x49, 0x1a, 0x79, 0x9c,
	0x74, 0x8a, 0x36, 0x32, 0x5c, 0x72, 0x70, 0x91, 0x0f, 0xd4, 0xcb, 0xc2, 0x79, 0xb7, 0x55, 0x23,
	0x3b, 0xc9, 0x34, 0x8b, 0x65, 0x27, 0xb8, 0x52, 0xb2, 0x65, 0x78, 0x2c, 0xfb, 0x8f, 0x15, 0x58,
	0x96, 0x51, 0xc9, 0x85, 0xc6, 0x15, 0xb8, 0x59, 0xc0, 0x31, 0x83, 0x8d, 0x94, 0xd8, 0x7a, 0x17,
	0x92, 0x58, 0x91, 0xbf, 0x56, 0xe0, 0xb2, 0x8c, 0x8c, 0x22, 0x76, 0x36, 0x05, 0xfa, 0x71, 0x01,
	0xf7, 0x1c, 0x9a, 0x48, 0xb1, 0xdb, 0xdf, 0x87, 0x34, 0x56, 0xf0, 0x2b, 0x76, 0xcb, 0x66, 0xd5,
	0x19, 0x13, 0x4f, 0x15, 0x57, 0xca, 0x49, 0x09, 0xb1, 0x81, 0x8e, 0x61, 0x41, 0x9f, 0xf4, 0x5d,
	0xcf, 0xb0, 0x28, 0xca, 0x10, 0xcd, 0x6b, 0xda, 0x23, 0x9f, 0x23, 0xf2, 0x0e, 0x4c, 0xc5, 0xc9,
	0x2c, 0xd2, 0x17, 0x82, 0xe6, 0x45, 0xd5, 0x00, 0xe9, 0xd2, 0x67, 0x31, 0xf7, 0x4c, 0x2a, 0xdf,
	0x43, 0xd9, 0x4b, 0x20, 0x59, 0x32, 0x2f, 0xa9, 0xcc, 0x32, 0x89, 0x62, 0xcc, 0x30, 0x39, 0x29,
	0x28, 0xbf, 0x50, 0xd3, 0x31, 0xcc, 0xa4, 0x64, 0x31, 0xc3, 0x24, 0xf7, 0x40, 0xf9, 0xa5, 0xa7,
	0x8e, 0x61, 0x26, 0x69, 0xc1, 0x06, 0xfa, 0x22, 0x8a, 0x7a, 0xe5, 0x78, 0xea, 0x83, 0x9d, 0x8e,
	0xed, 0x62, 0xa2, 0xfc, 0xce, 0xa8, 0x1c, 0xf3, 0x5a, 0x7e, 0x15, 0x2b, 0xd8, 0x5a, 0x30, 0x7b,
	0xa7, 0x6b, 0x39, 0x3d, 0x89, 0xdf, 0x25, 0x35, 0x7e, 0x66, 0x20, 0xca, 0x41, 0x52, 0x21, 0x92,
	0x6f, 0xb4, 0xe0, 0x6c, 0x3a, 0x1b, 0x46, 0x57, 0x35, 0x57, 0x6f, 0x82, 0x90, 0x6e, 0x82, 0xec,
	0x6d, 0xa1, 0xc9, 0xaa, 0xb1, 0x81, 0x5e, 0x02, 0x8a, 0xbe, 0x61, 0x49, 0x42, 0xd6, 0x74, 0x0e,
	0x7d, 0x3f, 0x7d, 0x04, 0xb8, 0xeb, 0x5f, 0x2b, 0x81, 0x8c, 0xad, 0x71, 0x61, 0x9e, 0xad, 0xdf,
	0x73, 0xdc, 0xb6, 0xb4, 0x69, 0x5a, 0x1e, 0x69, 0x4c, 0x24, 0x6e, 0xbd, 0x0c, 0x34, 0x96, 0xf7,
	0xfb, 0x0a, 0x5c, 0x29, 0xf5, 0x85, 0xae, 0xe8, 0x1c, 0x7c, 0x9a, 0x63, 0x61, 0xa9, 0x4f, 0x7e,
	0xd8, 0x40, 0x7f, 0xa9, 0xc0, 0xe5, 0x12, 0x1d, 0x7d, 0x25, 0xfe, 0x96, 0xff, 0xfa, 0x60, 0x7e,
	0xfc, 0x7d, 0x48, 0xf9, 0xfb, 0xff, 0x43, 0x05, 0x96, 0x0b, 0xba, 0x88, 0xca, 0x35, 0x35, 0xbe,
	0x77, 0x6a, 0x6e, 0xbe, 0x0b, 0x49, 0x94, 0x24, 0x54, 0xf3, 0xda, 0xb9, 0xa8, 0x5e, 0x8a, 0x5d,
	0xb2, 0x19, 0x37, 0x4a, 0xe3, 0xb9, 0xec, 0x87, 0x30, 0x23, 0x57, 0x90, 0x28, 0xfb, 0x5d, 0x34,
	0x5e, 0x31, 0x57, 0x35, 0x41, 0x36, 0x55, 0x78, 0xb2, 0x50, 0x33, 0x9b, 0x29, 0x31, 0x95, 0xc4,
	0x5e, 0x5e, 0x34, 0x2f, 0xab, 0x3c, 0x95, 0xfa, 0x14, 0x1b, 0xe8, 0x05, 0x2c, 0x6a, 0x6b, 0xcb,
	0x5d, 0x25, 0x29, 0xd4, 0x60, 0x14, 0xaf, 0x29, 0x28, 0x53, 0x93, 0x7b, 0x27, 0xae, 0x7a, 0xd5,
	0x7b, 0x27, 0x5e, 0xd2, 0xde, 0x3b, 0xe9, 0x72, 0x99, 0xc5, 0x98, 0x6a, 0x5e, 0x9f, 0x0f, 0x29,
	0xa5, 0x42, 0x1a, 0xb5, 0xaf, 0xbc, 0xce, 0xc2, 0x8e, 0x21, 0x36, 0x50, 0x17, 0x2e, 0xe4, 0x96,
	0xd3, 0x4a, 0x52, 0x11, 0xc6, 0x5e, 0x4a, 0xac, 0x40, 0x14, 0xb4, 0xe6, 0x46, 0xce, 0xd9, 0xd1,
	0x17, 0xe6, 0xd8, 0x40, 0xbf, 0x02, 0xa4, 0x96, 0xe0, 0xba, 0x52, 0x66, 0x27, 0x15, 0xa3, 0x94,
	0xec, 0x25, 0xa7, 0x8e, 0xc7, 0x06, 0x22, 0xb0, 0xa0, 0xad, 0xd8, 0xd1, 0xb8, 0xb6, 0xb7, 0x12,
	0x9a, 0xf3, 0x0b, 0x7f, 0x6c, 0xa0, 0x7e, 0x12, 0x06, 0x34, 0xa5, 0xbc, 0x6e, 0xe3, 0x1a, 0xc4,
	0x26, 0xce, 0x90, 0x70, 0x59, 0x9b, 0x63, 0x64, 0x65, 0xdb, 0x02, 0x49, 0x49, 0x19, 0x75, 0xda,
	0x73, 0x4a, 0x4a, 0xb1, 0xac, 0x2d, 0x29, 0xe5, 0xfe, 0x3b, 0x36, 0xd0, 0x2f, 0x61, 0x36, 0xdb,
	0x4d, 0xbf, 0xa4, 0x67, 0x2a, 0x41, 0x54, 0x07, 0xd4, 0xf4, 0xd9, 0x13, 0xe6, 0x72, 0xa7, 0x3c,
	0x87, 0xb9, 0x04, 0xd1, 0x32, 0xcf, 0xf6, 0xd0, 0xb1, 0x81, 0x7e, 0x03, 0x66, 0x41, 0x33, 0xfb,
	0x86, 0x5e, 0x8e, 0x1e, 0xad, 0x54, 0x2a, 0x63, 0x3a, 0xde, 0xd8, 0x40, 0xcf, 0x61, 0x36, 0xd3,
	0x67, 0xd1, 0x55, 0x9a, 0xd9, 0xef, 0x3b, 0xaa, 0x6d, 0x9a, 0x5e, 0x0d, 0x36, 0x50, 0x03, 0x66,
	0x52, 0x9f, 0x99, 0x6a, 0x79, 0x15, 0x26, 0x5f, 0x57, 0x82, 0xac, 0xd2, 0x04, 0xe7, 0xc5, 0xab,
	0xae, 0xd7, 0x7d, 0x25, 0xc7, 0x23, 0xd2, 0x30, 0xa5, 0x78, 0xcd, 0xeb, 0x82, 0x63, 0x03, 0xdd,
	0x83, 0xc9, 0xe8, 0x2f, 0x3f, 0xc8, 0xd4, 0x54, 0xf8, 0x62, 0xcd, 0x7c, 0x5f, 0x29, 0x56, 0xe4,
	0xff, 0x09, 0xb1, 0x4d, 0x90, 0xff, 0x90, 0xa3, 0xdb, 0x04, 0x79, 0x5d, 0xd9, 0x04, 0xe5, 0xdf,
	0x3c, 0xd8, 0xd8, 0xb9, 0xfb, 0xfa, 0x4d, 0xad, 0xf2, 0xdd, 0x9b, 0x5a, 0xe5, 0x3f, 0x6f, 0x6a,
	0x95, 0x6f, 0xdf, 0xd6, 0x8c, 0xef, 0xde, 0xd6, 0x8c, 0x7f, 0xbc, 0xad, 0x19, 0xbf, 0xb8, 0xde,
	0x71, 0x82, 0xa3, 0xc1, 0x61, 0xdd, 0xf6, 0x7a, 0x9b, 0xf6, 0xad, 0xe3, 0x80, 0xd8, 0x47, 0xe2,
	0xcf, 0x56, 0xad, 0xe1, 0xad, 0xcd, 0x57, 0xf1, 0x5f, 0xe3, 0x46, 0x7d, 0xe2, 0x1f, 0x9e, 0x62,
	0xdf, 0xe2, 0x6e, 0xfd, 0x2f, 0x00, 0x00, 0xff, 0xff, 0x31, 0x2d, 0x76, 0xd1, 0x80, 0x27, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// GreeterClient is the client API for Greeter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GreeterClient interface {
	// Sends a greeting
	SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloReply, error)
}

type greeterClient struct {
	cc grpc1.ClientConn
}

func NewGreeterClient(cc grpc1.ClientConn) GreeterClient {
	return &greeterClient{cc}
}

func (c *greeterClient) SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloReply, error) {
	out := new(HelloReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.Greeter/SayHello", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GreeterServer is the server API for Greeter service.
type GreeterServer interface {
	// Sends a greeting
	SayHello(context.Context, *HelloRequest) (*HelloReply, error)
}

// UnimplementedGreeterServer can be embedded to have forward compatible implementations.
type UnimplementedGreeterServer struct {
}

func (*UnimplementedGreeterServer) SayHello(ctx context.Context, req *HelloRequest) (*HelloReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SayHello not implemented")
}

func RegisterGreeterServer(s grpc1.Server, srv GreeterServer) {
	s.RegisterService(&_Greeter_serviceDesc, srv)
}

func _Greeter_SayHello_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HelloRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GreeterServer).SayHello(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.Greeter/SayHello",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GreeterServer).SayHello(ctx, req.(*HelloRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Greeter_serviceDesc = grpc.ServiceDesc{
	ServiceName: "qadena.qadena.Greeter",
	HandlerType: (*GreeterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SayHello",
			Handler:    _Greeter_SayHello_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "qadena/qadena/enclave.proto",
}

// QadenaEnclaveClient is the client API for QadenaEnclave service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QadenaEnclaveClient interface {
	// these are called from init_enclave
	InitEnclave(ctx context.Context, in *MsgInitEnclave, opts ...grpc.CallOption) (*InitEnclaveReply, error)
	SyncEnclave(ctx context.Context, in *MsgSyncEnclave, opts ...grpc.CallOption) (*SyncEnclaveReply, error)
	// rpc AddAsValidator (MsgAddAsValidator) returns (AddAsValidatorReply) {}
	UpgradeEnclave(ctx context.Context, in *MsgUpgradeEnclave, opts ...grpc.CallOption) (*UpgradeEnclaveReply, error)
	// for debug only, called from init_enclave
	ExportPrivateKey(ctx context.Context, in *MsgExportPrivateKey, opts ...grpc.CallOption) (*ExportPrivateKeyReply, error)
	ExportPrivateState(ctx context.Context, in *MsgExportPrivateState, opts ...grpc.CallOption) (*ExportPrivateStateReply, error)
	RemovePrivateKey(ctx context.Context, in *MsgRemovePrivateKey, opts ...grpc.CallOption) (*RemovePrivateKeyReply, error)
	UpdateSSIntervalKey(ctx context.Context, in *MsgUpdateSSIntervalKey, opts ...grpc.CallOption) (*UpdateSSIntervalKeyReply, error)
	// these are called from the chain by an enclave
	QueryEnclaveSyncEnclave(ctx context.Context, in *QueryEnclaveSyncEnclaveRequest, opts ...grpc.CallOption) (*QueryEnclaveSyncEnclaveResponse, error)
	QueryEnclaveSecretShare(ctx context.Context, in *QueryEnclaveSecretShareRequest, opts ...grpc.CallOption) (*QueryEnclaveSecretShareResponse, error)
	QueryEnclaveRecoverKeyShare(ctx context.Context, in *QueryEnclaveRecoverKeyShareRequest, opts ...grpc.CallOption) (*QueryEnclaveRecoverKeyShareResponse, error)
	QueryEnclaveValidateEnclaveIdentity(ctx context.Context, in *QueryEnclaveValidateEnclaveIdentityRequest, opts ...grpc.CallOption) (*QueryEnclaveValidateEnclaveIdentityResponse, error)
	SetEnclaveIdentity(ctx context.Context, in *EnclaveIdentity, opts ...grpc.CallOption) (*SetEnclaveIdentityReply, error)
	UpdateEnclaveIdentity(ctx context.Context, in *PioneerUpdateEnclaveIdentity, opts ...grpc.CallOption) (*UpdateEnclaveIdentityReply, error)
	SetWallet(ctx context.Context, in *Wallet, opts ...grpc.CallOption) (*SetWalletReply, error)
	SetProtectKey(ctx context.Context, in *ProtectKey, opts ...grpc.CallOption) (*SetProtectKeyReply, error)
	SetRecoverKey(ctx context.Context, in *RecoverKey, opts ...grpc.CallOption) (*SetRecoverKeyReply, error)
	SetCredential(ctx context.Context, in *Credential, opts ...grpc.CallOption) (*SetCredentialReply, error)
	RemoveCredential(ctx context.Context, in *Credential, opts ...grpc.CallOption) (*RemoveCredentialReply, error)
	RecoverKeyByCredential(ctx context.Context, in *Credential, opts ...grpc.CallOption) (*RecoverKeyReply, error)
	ClaimCredential(ctx context.Context, in *MsgClaimCredential, opts ...grpc.CallOption) (*MsgClaimCredentialResponse, error)
	SignRecoverKey(ctx context.Context, in *MsgSignRecoverPrivateKey, opts ...grpc.CallOption) (*SignRecoverKeyReply, error)
	QueryGetRecoverKey(ctx context.Context, in *QueryGetRecoverKeyRequest, opts ...grpc.CallOption) (*QueryGetRecoverKeyResponse, error)
	QueryFindCredential(ctx context.Context, in *QueryFindCredentialRequest, opts ...grpc.CallOption) (*QueryFindCredentialResponse, error)
	QueryGetSubWalletIDByOriginalWalletID(ctx context.Context, in *Credential, opts ...grpc.CallOption) (*QueryGetSubWalletIDByOriginalWalletIDResponse, error)
	ValidateAuthenticateServiceProvider(ctx context.Context, in *ValidateAuthenticateServiceProviderRequest, opts ...grpc.CallOption) (*ValidateAuthenticateServiceProviderReply, error)
	// used to validate the "authorized signatory" (this allows a user to specify which eph wallet ID is allowed to sign documents)
	ValidateAuthorizedSignatory(ctx context.Context, in *ValidateAuthorizedSignatoryRequest, opts ...grpc.CallOption) (*ValidateAuthorizedSignatoryReply, error)
	// used to validate whether this signer can sign a document (is the signer's credentials enough to sign the document?)
	ValidateAuthorizedSigner(ctx context.Context, in *ValidateAuthorizedSignerRequest, opts ...grpc.CallOption) (*ValidateAuthorizedSignerReply, error)
	SetPublicKey(ctx context.Context, in *PublicKey, opts ...grpc.CallOption) (*SetPublicKeyReply, error)
	SetJarRegulator(ctx context.Context, in *JarRegulator, opts ...grpc.CallOption) (*SetJarRegulatorReply, error)
	SetIntervalPublicKeyID(ctx context.Context, in *IntervalPublicKeyID, opts ...grpc.CallOption) (*SetIntervalPublicKeyIdReply, error)
	SetPioneerJar(ctx context.Context, in *PioneerJar, opts ...grpc.CallOption) (*SetPioneerJarReply, error)
	SetSecretSharePrivateKey(ctx context.Context, in *SecretSharePrivK, opts ...grpc.CallOption) (*SetSecretSharePrivateKeyReply, error)
	ValidateDestinationWallet(ctx context.Context, in *MsgCreateWallet, opts ...grpc.CallOption) (*ValidateDestinationWalletReply, error)
	ValidateCredential(ctx context.Context, in *MsgBindCredential, opts ...grpc.CallOption) (*ValidateCredentialReply, error)
	ValidateTransferPrime(ctx context.Context, in *MsgTransferFunds, opts ...grpc.CallOption) (*ValidateTransferPrimeReply, error)
	ValidateTransferDoublePrime(ctx context.Context, in *MsgReceiveFunds, opts ...grpc.CallOption) (*ValidateTransferDoublePrimeReply, error)
	SyncWallets(ctx context.Context, in *MsgSyncWallets, opts ...grpc.CallOption) (*SyncWalletsReply, error)
	SyncCredentials(ctx context.Context, in *MsgSyncCredentials, opts ...grpc.CallOption) (*SyncCredentialsReply, error)
	SyncRecoverKeys(ctx context.Context, in *MsgSyncRecoverKeys, opts ...grpc.CallOption) (*SyncRecoverKeysReply, error)
	SyncSuspiciousTransactions(ctx context.Context, in *MsgSyncSuspiciousTransactions, opts ...grpc.CallOption) (*SyncSuspiciousTransactionsReply, error)
	ScanTransaction(ctx context.Context, in *MsgScanTransactions, opts ...grpc.CallOption) (*ScanTransactionReply, error)
	// called at BeginBlock at a certain interval (i.e. not at every BeginBlock)
	UpdateHeight(ctx context.Context, in *MsgUpdateHeight, opts ...grpc.CallOption) (*UpdateHeightReply, error)
	// called after each transaction
	TransactionComplete(ctx context.Context, in *MsgTransactionComplete, opts ...grpc.CallOption) (*TransactionCompleteReply, error)
	// called at each EndBlock
	EndBlock(ctx context.Context, in *MsgEndBlock, opts ...grpc.CallOption) (*EndBlockReply, error)
	// called on init
	GetStoreHash(ctx context.Context, in *MsgGetStoreHash, opts ...grpc.CallOption) (*GetStoreHashReply, error)
}

type qadenaEnclaveClient struct {
	cc grpc1.ClientConn
}

func NewQadenaEnclaveClient(cc grpc1.ClientConn) QadenaEnclaveClient {
	return &qadenaEnclaveClient{cc}
}

func (c *qadenaEnclaveClient) InitEnclave(ctx context.Context, in *MsgInitEnclave, opts ...grpc.CallOption) (*InitEnclaveReply, error) {
	out := new(InitEnclaveReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/InitEnclave", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) SyncEnclave(ctx context.Context, in *MsgSyncEnclave, opts ...grpc.CallOption) (*SyncEnclaveReply, error) {
	out := new(SyncEnclaveReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/SyncEnclave", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) UpgradeEnclave(ctx context.Context, in *MsgUpgradeEnclave, opts ...grpc.CallOption) (*UpgradeEnclaveReply, error) {
	out := new(UpgradeEnclaveReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/UpgradeEnclave", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) ExportPrivateKey(ctx context.Context, in *MsgExportPrivateKey, opts ...grpc.CallOption) (*ExportPrivateKeyReply, error) {
	out := new(ExportPrivateKeyReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/ExportPrivateKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) ExportPrivateState(ctx context.Context, in *MsgExportPrivateState, opts ...grpc.CallOption) (*ExportPrivateStateReply, error) {
	out := new(ExportPrivateStateReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/ExportPrivateState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) RemovePrivateKey(ctx context.Context, in *MsgRemovePrivateKey, opts ...grpc.CallOption) (*RemovePrivateKeyReply, error) {
	out := new(RemovePrivateKeyReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/RemovePrivateKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) UpdateSSIntervalKey(ctx context.Context, in *MsgUpdateSSIntervalKey, opts ...grpc.CallOption) (*UpdateSSIntervalKeyReply, error) {
	out := new(UpdateSSIntervalKeyReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/UpdateSSIntervalKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) QueryEnclaveSyncEnclave(ctx context.Context, in *QueryEnclaveSyncEnclaveRequest, opts ...grpc.CallOption) (*QueryEnclaveSyncEnclaveResponse, error) {
	out := new(QueryEnclaveSyncEnclaveResponse)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/QueryEnclaveSyncEnclave", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) QueryEnclaveSecretShare(ctx context.Context, in *QueryEnclaveSecretShareRequest, opts ...grpc.CallOption) (*QueryEnclaveSecretShareResponse, error) {
	out := new(QueryEnclaveSecretShareResponse)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/QueryEnclaveSecretShare", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) QueryEnclaveRecoverKeyShare(ctx context.Context, in *QueryEnclaveRecoverKeyShareRequest, opts ...grpc.CallOption) (*QueryEnclaveRecoverKeyShareResponse, error) {
	out := new(QueryEnclaveRecoverKeyShareResponse)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/QueryEnclaveRecoverKeyShare", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) QueryEnclaveValidateEnclaveIdentity(ctx context.Context, in *QueryEnclaveValidateEnclaveIdentityRequest, opts ...grpc.CallOption) (*QueryEnclaveValidateEnclaveIdentityResponse, error) {
	out := new(QueryEnclaveValidateEnclaveIdentityResponse)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/QueryEnclaveValidateEnclaveIdentity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) SetEnclaveIdentity(ctx context.Context, in *EnclaveIdentity, opts ...grpc.CallOption) (*SetEnclaveIdentityReply, error) {
	out := new(SetEnclaveIdentityReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/SetEnclaveIdentity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) UpdateEnclaveIdentity(ctx context.Context, in *PioneerUpdateEnclaveIdentity, opts ...grpc.CallOption) (*UpdateEnclaveIdentityReply, error) {
	out := new(UpdateEnclaveIdentityReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/UpdateEnclaveIdentity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) SetWallet(ctx context.Context, in *Wallet, opts ...grpc.CallOption) (*SetWalletReply, error) {
	out := new(SetWalletReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/SetWallet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) SetProtectKey(ctx context.Context, in *ProtectKey, opts ...grpc.CallOption) (*SetProtectKeyReply, error) {
	out := new(SetProtectKeyReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/SetProtectKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) SetRecoverKey(ctx context.Context, in *RecoverKey, opts ...grpc.CallOption) (*SetRecoverKeyReply, error) {
	out := new(SetRecoverKeyReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/SetRecoverKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) SetCredential(ctx context.Context, in *Credential, opts ...grpc.CallOption) (*SetCredentialReply, error) {
	out := new(SetCredentialReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/SetCredential", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) RemoveCredential(ctx context.Context, in *Credential, opts ...grpc.CallOption) (*RemoveCredentialReply, error) {
	out := new(RemoveCredentialReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/RemoveCredential", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) RecoverKeyByCredential(ctx context.Context, in *Credential, opts ...grpc.CallOption) (*RecoverKeyReply, error) {
	out := new(RecoverKeyReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/RecoverKeyByCredential", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) ClaimCredential(ctx context.Context, in *MsgClaimCredential, opts ...grpc.CallOption) (*MsgClaimCredentialResponse, error) {
	out := new(MsgClaimCredentialResponse)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/ClaimCredential", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) SignRecoverKey(ctx context.Context, in *MsgSignRecoverPrivateKey, opts ...grpc.CallOption) (*SignRecoverKeyReply, error) {
	out := new(SignRecoverKeyReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/SignRecoverKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) QueryGetRecoverKey(ctx context.Context, in *QueryGetRecoverKeyRequest, opts ...grpc.CallOption) (*QueryGetRecoverKeyResponse, error) {
	out := new(QueryGetRecoverKeyResponse)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/QueryGetRecoverKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) QueryFindCredential(ctx context.Context, in *QueryFindCredentialRequest, opts ...grpc.CallOption) (*QueryFindCredentialResponse, error) {
	out := new(QueryFindCredentialResponse)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/QueryFindCredential", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) QueryGetSubWalletIDByOriginalWalletID(ctx context.Context, in *Credential, opts ...grpc.CallOption) (*QueryGetSubWalletIDByOriginalWalletIDResponse, error) {
	out := new(QueryGetSubWalletIDByOriginalWalletIDResponse)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/QueryGetSubWalletIDByOriginalWalletID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) ValidateAuthenticateServiceProvider(ctx context.Context, in *ValidateAuthenticateServiceProviderRequest, opts ...grpc.CallOption) (*ValidateAuthenticateServiceProviderReply, error) {
	out := new(ValidateAuthenticateServiceProviderReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/ValidateAuthenticateServiceProvider", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) ValidateAuthorizedSignatory(ctx context.Context, in *ValidateAuthorizedSignatoryRequest, opts ...grpc.CallOption) (*ValidateAuthorizedSignatoryReply, error) {
	out := new(ValidateAuthorizedSignatoryReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/ValidateAuthorizedSignatory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) ValidateAuthorizedSigner(ctx context.Context, in *ValidateAuthorizedSignerRequest, opts ...grpc.CallOption) (*ValidateAuthorizedSignerReply, error) {
	out := new(ValidateAuthorizedSignerReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/ValidateAuthorizedSigner", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) SetPublicKey(ctx context.Context, in *PublicKey, opts ...grpc.CallOption) (*SetPublicKeyReply, error) {
	out := new(SetPublicKeyReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/SetPublicKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) SetJarRegulator(ctx context.Context, in *JarRegulator, opts ...grpc.CallOption) (*SetJarRegulatorReply, error) {
	out := new(SetJarRegulatorReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/SetJarRegulator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) SetIntervalPublicKeyID(ctx context.Context, in *IntervalPublicKeyID, opts ...grpc.CallOption) (*SetIntervalPublicKeyIdReply, error) {
	out := new(SetIntervalPublicKeyIdReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/SetIntervalPublicKeyID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) SetPioneerJar(ctx context.Context, in *PioneerJar, opts ...grpc.CallOption) (*SetPioneerJarReply, error) {
	out := new(SetPioneerJarReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/SetPioneerJar", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) SetSecretSharePrivateKey(ctx context.Context, in *SecretSharePrivK, opts ...grpc.CallOption) (*SetSecretSharePrivateKeyReply, error) {
	out := new(SetSecretSharePrivateKeyReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/SetSecretSharePrivateKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) ValidateDestinationWallet(ctx context.Context, in *MsgCreateWallet, opts ...grpc.CallOption) (*ValidateDestinationWalletReply, error) {
	out := new(ValidateDestinationWalletReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/ValidateDestinationWallet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) ValidateCredential(ctx context.Context, in *MsgBindCredential, opts ...grpc.CallOption) (*ValidateCredentialReply, error) {
	out := new(ValidateCredentialReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/ValidateCredential", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) ValidateTransferPrime(ctx context.Context, in *MsgTransferFunds, opts ...grpc.CallOption) (*ValidateTransferPrimeReply, error) {
	out := new(ValidateTransferPrimeReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/ValidateTransferPrime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) ValidateTransferDoublePrime(ctx context.Context, in *MsgReceiveFunds, opts ...grpc.CallOption) (*ValidateTransferDoublePrimeReply, error) {
	out := new(ValidateTransferDoublePrimeReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/ValidateTransferDoublePrime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) SyncWallets(ctx context.Context, in *MsgSyncWallets, opts ...grpc.CallOption) (*SyncWalletsReply, error) {
	out := new(SyncWalletsReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/SyncWallets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) SyncCredentials(ctx context.Context, in *MsgSyncCredentials, opts ...grpc.CallOption) (*SyncCredentialsReply, error) {
	out := new(SyncCredentialsReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/SyncCredentials", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) SyncRecoverKeys(ctx context.Context, in *MsgSyncRecoverKeys, opts ...grpc.CallOption) (*SyncRecoverKeysReply, error) {
	out := new(SyncRecoverKeysReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/SyncRecoverKeys", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) SyncSuspiciousTransactions(ctx context.Context, in *MsgSyncSuspiciousTransactions, opts ...grpc.CallOption) (*SyncSuspiciousTransactionsReply, error) {
	out := new(SyncSuspiciousTransactionsReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/SyncSuspiciousTransactions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) ScanTransaction(ctx context.Context, in *MsgScanTransactions, opts ...grpc.CallOption) (*ScanTransactionReply, error) {
	out := new(ScanTransactionReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/ScanTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) UpdateHeight(ctx context.Context, in *MsgUpdateHeight, opts ...grpc.CallOption) (*UpdateHeightReply, error) {
	out := new(UpdateHeightReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/UpdateHeight", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) TransactionComplete(ctx context.Context, in *MsgTransactionComplete, opts ...grpc.CallOption) (*TransactionCompleteReply, error) {
	out := new(TransactionCompleteReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/TransactionComplete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) EndBlock(ctx context.Context, in *MsgEndBlock, opts ...grpc.CallOption) (*EndBlockReply, error) {
	out := new(EndBlockReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/EndBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qadenaEnclaveClient) GetStoreHash(ctx context.Context, in *MsgGetStoreHash, opts ...grpc.CallOption) (*GetStoreHashReply, error) {
	out := new(GetStoreHashReply)
	err := c.cc.Invoke(ctx, "/qadena.qadena.QadenaEnclave/GetStoreHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QadenaEnclaveServer is the server API for QadenaEnclave service.
type QadenaEnclaveServer interface {
	// these are called from init_enclave
	InitEnclave(context.Context, *MsgInitEnclave) (*InitEnclaveReply, error)
	SyncEnclave(context.Context, *MsgSyncEnclave) (*SyncEnclaveReply, error)
	// rpc AddAsValidator (MsgAddAsValidator) returns (AddAsValidatorReply) {}
	UpgradeEnclave(context.Context, *MsgUpgradeEnclave) (*UpgradeEnclaveReply, error)
	// for debug only, called from init_enclave
	ExportPrivateKey(context.Context, *MsgExportPrivateKey) (*ExportPrivateKeyReply, error)
	ExportPrivateState(context.Context, *MsgExportPrivateState) (*ExportPrivateStateReply, error)
	RemovePrivateKey(context.Context, *MsgRemovePrivateKey) (*RemovePrivateKeyReply, error)
	UpdateSSIntervalKey(context.Context, *MsgUpdateSSIntervalKey) (*UpdateSSIntervalKeyReply, error)
	// these are called from the chain by an enclave
	QueryEnclaveSyncEnclave(context.Context, *QueryEnclaveSyncEnclaveRequest) (*QueryEnclaveSyncEnclaveResponse, error)
	QueryEnclaveSecretShare(context.Context, *QueryEnclaveSecretShareRequest) (*QueryEnclaveSecretShareResponse, error)
	QueryEnclaveRecoverKeyShare(context.Context, *QueryEnclaveRecoverKeyShareRequest) (*QueryEnclaveRecoverKeyShareResponse, error)
	QueryEnclaveValidateEnclaveIdentity(context.Context, *QueryEnclaveValidateEnclaveIdentityRequest) (*QueryEnclaveValidateEnclaveIdentityResponse, error)
	SetEnclaveIdentity(context.Context, *EnclaveIdentity) (*SetEnclaveIdentityReply, error)
	UpdateEnclaveIdentity(context.Context, *PioneerUpdateEnclaveIdentity) (*UpdateEnclaveIdentityReply, error)
	SetWallet(context.Context, *Wallet) (*SetWalletReply, error)
	SetProtectKey(context.Context, *ProtectKey) (*SetProtectKeyReply, error)
	SetRecoverKey(context.Context, *RecoverKey) (*SetRecoverKeyReply, error)
	SetCredential(context.Context, *Credential) (*SetCredentialReply, error)
	RemoveCredential(context.Context, *Credential) (*RemoveCredentialReply, error)
	RecoverKeyByCredential(context.Context, *Credential) (*RecoverKeyReply, error)
	ClaimCredential(context.Context, *MsgClaimCredential) (*MsgClaimCredentialResponse, error)
	SignRecoverKey(context.Context, *MsgSignRecoverPrivateKey) (*SignRecoverKeyReply, error)
	QueryGetRecoverKey(context.Context, *QueryGetRecoverKeyRequest) (*QueryGetRecoverKeyResponse, error)
	QueryFindCredential(context.Context, *QueryFindCredentialRequest) (*QueryFindCredentialResponse, error)
	QueryGetSubWalletIDByOriginalWalletID(context.Context, *Credential) (*QueryGetSubWalletIDByOriginalWalletIDResponse, error)
	ValidateAuthenticateServiceProvider(context.Context, *ValidateAuthenticateServiceProviderRequest) (*ValidateAuthenticateServiceProviderReply, error)
	// used to validate the "authorized signatory" (this allows a user to specify which eph wallet ID is allowed to sign documents)
	ValidateAuthorizedSignatory(context.Context, *ValidateAuthorizedSignatoryRequest) (*ValidateAuthorizedSignatoryReply, error)
	// used to validate whether this signer can sign a document (is the signer's credentials enough to sign the document?)
	ValidateAuthorizedSigner(context.Context, *ValidateAuthorizedSignerRequest) (*ValidateAuthorizedSignerReply, error)
	SetPublicKey(context.Context, *PublicKey) (*SetPublicKeyReply, error)
	SetJarRegulator(context.Context, *JarRegulator) (*SetJarRegulatorReply, error)
	SetIntervalPublicKeyID(context.Context, *IntervalPublicKeyID) (*SetIntervalPublicKeyIdReply, error)
	SetPioneerJar(context.Context, *PioneerJar) (*SetPioneerJarReply, error)
	SetSecretSharePrivateKey(context.Context, *SecretSharePrivK) (*SetSecretSharePrivateKeyReply, error)
	ValidateDestinationWallet(context.Context, *MsgCreateWallet) (*ValidateDestinationWalletReply, error)
	ValidateCredential(context.Context, *MsgBindCredential) (*ValidateCredentialReply, error)
	ValidateTransferPrime(context.Context, *MsgTransferFunds) (*ValidateTransferPrimeReply, error)
	ValidateTransferDoublePrime(context.Context, *MsgReceiveFunds) (*ValidateTransferDoublePrimeReply, error)
	SyncWallets(context.Context, *MsgSyncWallets) (*SyncWalletsReply, error)
	SyncCredentials(context.Context, *MsgSyncCredentials) (*SyncCredentialsReply, error)
	SyncRecoverKeys(context.Context, *MsgSyncRecoverKeys) (*SyncRecoverKeysReply, error)
	SyncSuspiciousTransactions(context.Context, *MsgSyncSuspiciousTransactions) (*SyncSuspiciousTransactionsReply, error)
	ScanTransaction(context.Context, *MsgScanTransactions) (*ScanTransactionReply, error)
	// called at BeginBlock at a certain interval (i.e. not at every BeginBlock)
	UpdateHeight(context.Context, *MsgUpdateHeight) (*UpdateHeightReply, error)
	// called after each transaction
	TransactionComplete(context.Context, *MsgTransactionComplete) (*TransactionCompleteReply, error)
	// called at each EndBlock
	EndBlock(context.Context, *MsgEndBlock) (*EndBlockReply, error)
	// called on init
	GetStoreHash(context.Context, *MsgGetStoreHash) (*GetStoreHashReply, error)
}

// UnimplementedQadenaEnclaveServer can be embedded to have forward compatible implementations.
type UnimplementedQadenaEnclaveServer struct {
}

func (*UnimplementedQadenaEnclaveServer) InitEnclave(ctx context.Context, req *MsgInitEnclave) (*InitEnclaveReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitEnclave not implemented")
}
func (*UnimplementedQadenaEnclaveServer) SyncEnclave(ctx context.Context, req *MsgSyncEnclave) (*SyncEnclaveReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncEnclave not implemented")
}
func (*UnimplementedQadenaEnclaveServer) UpgradeEnclave(ctx context.Context, req *MsgUpgradeEnclave) (*UpgradeEnclaveReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpgradeEnclave not implemented")
}
func (*UnimplementedQadenaEnclaveServer) ExportPrivateKey(ctx context.Context, req *MsgExportPrivateKey) (*ExportPrivateKeyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportPrivateKey not implemented")
}
func (*UnimplementedQadenaEnclaveServer) ExportPrivateState(ctx context.Context, req *MsgExportPrivateState) (*ExportPrivateStateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportPrivateState not implemented")
}
func (*UnimplementedQadenaEnclaveServer) RemovePrivateKey(ctx context.Context, req *MsgRemovePrivateKey) (*RemovePrivateKeyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemovePrivateKey not implemented")
}
func (*UnimplementedQadenaEnclaveServer) UpdateSSIntervalKey(ctx context.Context, req *MsgUpdateSSIntervalKey) (*UpdateSSIntervalKeyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSSIntervalKey not implemented")
}
func (*UnimplementedQadenaEnclaveServer) QueryEnclaveSyncEnclave(ctx context.Context, req *QueryEnclaveSyncEnclaveRequest) (*QueryEnclaveSyncEnclaveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryEnclaveSyncEnclave not implemented")
}
func (*UnimplementedQadenaEnclaveServer) QueryEnclaveSecretShare(ctx context.Context, req *QueryEnclaveSecretShareRequest) (*QueryEnclaveSecretShareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryEnclaveSecretShare not implemented")
}
func (*UnimplementedQadenaEnclaveServer) QueryEnclaveRecoverKeyShare(ctx context.Context, req *QueryEnclaveRecoverKeyShareRequest) (*QueryEnclaveRecoverKeyShareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryEnclaveRecoverKeyShare not implemented")
}
func (*UnimplementedQadenaEnclaveServer) QueryEnclaveValidateEnclaveIdentity(ctx context.Context, req *QueryEnclaveValidateEnclaveIdentityRequest) (*QueryEnclaveValidateEnclaveIdentityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryEnclaveValidateEnclaveIdentity not implemented")
}
func (*UnimplementedQadenaEnclaveServer) SetEnclaveIdentity(ctx context.Context, req *EnclaveIdentity) (*SetEnclaveIdentityReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetEnclaveIdentity not implemented")
}
func (*UnimplementedQadenaEnclaveServer) UpdateEnclaveIdentity(ctx context.Context, req *PioneerUpdateEnclaveIdentity) (*UpdateEnclaveIdentityReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateEnclaveIdentity not implemented")
}
func (*UnimplementedQadenaEnclaveServer) SetWallet(ctx context.Context, req *Wallet) (*SetWalletReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetWallet not implemented")
}
func (*UnimplementedQadenaEnclaveServer) SetProtectKey(ctx context.Context, req *ProtectKey) (*SetProtectKeyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetProtectKey not implemented")
}
func (*UnimplementedQadenaEnclaveServer) SetRecoverKey(ctx context.Context, req *RecoverKey) (*SetRecoverKeyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetRecoverKey not implemented")
}
func (*UnimplementedQadenaEnclaveServer) SetCredential(ctx context.Context, req *Credential) (*SetCredentialReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCredential not implemented")
}
func (*UnimplementedQadenaEnclaveServer) RemoveCredential(ctx context.Context, req *Credential) (*RemoveCredentialReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveCredential not implemented")
}
func (*UnimplementedQadenaEnclaveServer) RecoverKeyByCredential(ctx context.Context, req *Credential) (*RecoverKeyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecoverKeyByCredential not implemented")
}
func (*UnimplementedQadenaEnclaveServer) ClaimCredential(ctx context.Context, req *MsgClaimCredential) (*MsgClaimCredentialResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimCredential not implemented")
}
func (*UnimplementedQadenaEnclaveServer) SignRecoverKey(ctx context.Context, req *MsgSignRecoverPrivateKey) (*SignRecoverKeyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignRecoverKey not implemented")
}
func (*UnimplementedQadenaEnclaveServer) QueryGetRecoverKey(ctx context.Context, req *QueryGetRecoverKeyRequest) (*QueryGetRecoverKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryGetRecoverKey not implemented")
}
func (*UnimplementedQadenaEnclaveServer) QueryFindCredential(ctx context.Context, req *QueryFindCredentialRequest) (*QueryFindCredentialResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryFindCredential not implemented")
}
func (*UnimplementedQadenaEnclaveServer) QueryGetSubWalletIDByOriginalWalletID(ctx context.Context, req *Credential) (*QueryGetSubWalletIDByOriginalWalletIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryGetSubWalletIDByOriginalWalletID not implemented")
}
func (*UnimplementedQadenaEnclaveServer) ValidateAuthenticateServiceProvider(ctx context.Context, req *ValidateAuthenticateServiceProviderRequest) (*ValidateAuthenticateServiceProviderReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateAuthenticateServiceProvider not implemented")
}
func (*UnimplementedQadenaEnclaveServer) ValidateAuthorizedSignatory(ctx context.Context, req *ValidateAuthorizedSignatoryRequest) (*ValidateAuthorizedSignatoryReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateAuthorizedSignatory not implemented")
}
func (*UnimplementedQadenaEnclaveServer) ValidateAuthorizedSigner(ctx context.Context, req *ValidateAuthorizedSignerRequest) (*ValidateAuthorizedSignerReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateAuthorizedSigner not implemented")
}
func (*UnimplementedQadenaEnclaveServer) SetPublicKey(ctx context.Context, req *PublicKey) (*SetPublicKeyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPublicKey not implemented")
}
func (*UnimplementedQadenaEnclaveServer) SetJarRegulator(ctx context.Context, req *JarRegulator) (*SetJarRegulatorReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetJarRegulator not implemented")
}
func (*UnimplementedQadenaEnclaveServer) SetIntervalPublicKeyID(ctx context.Context, req *IntervalPublicKeyID) (*SetIntervalPublicKeyIdReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIntervalPublicKeyID not implemented")
}
func (*UnimplementedQadenaEnclaveServer) SetPioneerJar(ctx context.Context, req *PioneerJar) (*SetPioneerJarReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPioneerJar not implemented")
}
func (*UnimplementedQadenaEnclaveServer) SetSecretSharePrivateKey(ctx context.Context, req *SecretSharePrivK) (*SetSecretSharePrivateKeyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSecretSharePrivateKey not implemented")
}
func (*UnimplementedQadenaEnclaveServer) ValidateDestinationWallet(ctx context.Context, req *MsgCreateWallet) (*ValidateDestinationWalletReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateDestinationWallet not implemented")
}
func (*UnimplementedQadenaEnclaveServer) ValidateCredential(ctx context.Context, req *MsgBindCredential) (*ValidateCredentialReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateCredential not implemented")
}
func (*UnimplementedQadenaEnclaveServer) ValidateTransferPrime(ctx context.Context, req *MsgTransferFunds) (*ValidateTransferPrimeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateTransferPrime not implemented")
}
func (*UnimplementedQadenaEnclaveServer) ValidateTransferDoublePrime(ctx context.Context, req *MsgReceiveFunds) (*ValidateTransferDoublePrimeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateTransferDoublePrime not implemented")
}
func (*UnimplementedQadenaEnclaveServer) SyncWallets(ctx context.Context, req *MsgSyncWallets) (*SyncWalletsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncWallets not implemented")
}
func (*UnimplementedQadenaEnclaveServer) SyncCredentials(ctx context.Context, req *MsgSyncCredentials) (*SyncCredentialsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncCredentials not implemented")
}
func (*UnimplementedQadenaEnclaveServer) SyncRecoverKeys(ctx context.Context, req *MsgSyncRecoverKeys) (*SyncRecoverKeysReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncRecoverKeys not implemented")
}
func (*UnimplementedQadenaEnclaveServer) SyncSuspiciousTransactions(ctx context.Context, req *MsgSyncSuspiciousTransactions) (*SyncSuspiciousTransactionsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncSuspiciousTransactions not implemented")
}
func (*UnimplementedQadenaEnclaveServer) ScanTransaction(ctx context.Context, req *MsgScanTransactions) (*ScanTransactionReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ScanTransaction not implemented")
}
func (*UnimplementedQadenaEnclaveServer) UpdateHeight(ctx context.Context, req *MsgUpdateHeight) (*UpdateHeightReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateHeight not implemented")
}
func (*UnimplementedQadenaEnclaveServer) TransactionComplete(ctx context.Context, req *MsgTransactionComplete) (*TransactionCompleteReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransactionComplete not implemented")
}
func (*UnimplementedQadenaEnclaveServer) EndBlock(ctx context.Context, req *MsgEndBlock) (*EndBlockReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EndBlock not implemented")
}
func (*UnimplementedQadenaEnclaveServer) GetStoreHash(ctx context.Context, req *MsgGetStoreHash) (*GetStoreHashReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStoreHash not implemented")
}

func RegisterQadenaEnclaveServer(s grpc1.Server, srv QadenaEnclaveServer) {
	s.RegisterService(&_QadenaEnclave_serviceDesc, srv)
}

func _QadenaEnclave_InitEnclave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgInitEnclave)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).InitEnclave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/InitEnclave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).InitEnclave(ctx, req.(*MsgInitEnclave))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_SyncEnclave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSyncEnclave)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).SyncEnclave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/SyncEnclave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).SyncEnclave(ctx, req.(*MsgSyncEnclave))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_UpgradeEnclave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpgradeEnclave)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).UpgradeEnclave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/UpgradeEnclave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).UpgradeEnclave(ctx, req.(*MsgUpgradeEnclave))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_ExportPrivateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgExportPrivateKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).ExportPrivateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/ExportPrivateKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).ExportPrivateKey(ctx, req.(*MsgExportPrivateKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_ExportPrivateState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgExportPrivateState)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).ExportPrivateState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/ExportPrivateState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).ExportPrivateState(ctx, req.(*MsgExportPrivateState))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_RemovePrivateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRemovePrivateKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).RemovePrivateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/RemovePrivateKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).RemovePrivateKey(ctx, req.(*MsgRemovePrivateKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_UpdateSSIntervalKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateSSIntervalKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).UpdateSSIntervalKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/UpdateSSIntervalKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).UpdateSSIntervalKey(ctx, req.(*MsgUpdateSSIntervalKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_QueryEnclaveSyncEnclave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryEnclaveSyncEnclaveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).QueryEnclaveSyncEnclave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/QueryEnclaveSyncEnclave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).QueryEnclaveSyncEnclave(ctx, req.(*QueryEnclaveSyncEnclaveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_QueryEnclaveSecretShare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryEnclaveSecretShareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).QueryEnclaveSecretShare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/QueryEnclaveSecretShare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).QueryEnclaveSecretShare(ctx, req.(*QueryEnclaveSecretShareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_QueryEnclaveRecoverKeyShare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryEnclaveRecoverKeyShareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).QueryEnclaveRecoverKeyShare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/QueryEnclaveRecoverKeyShare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).QueryEnclaveRecoverKeyShare(ctx, req.(*QueryEnclaveRecoverKeyShareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_QueryEnclaveValidateEnclaveIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryEnclaveValidateEnclaveIdentityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).QueryEnclaveValidateEnclaveIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/QueryEnclaveValidateEnclaveIdentity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).QueryEnclaveValidateEnclaveIdentity(ctx, req.(*QueryEnclaveValidateEnclaveIdentityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_SetEnclaveIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnclaveIdentity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).SetEnclaveIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/SetEnclaveIdentity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).SetEnclaveIdentity(ctx, req.(*EnclaveIdentity))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_UpdateEnclaveIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PioneerUpdateEnclaveIdentity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).UpdateEnclaveIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/UpdateEnclaveIdentity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).UpdateEnclaveIdentity(ctx, req.(*PioneerUpdateEnclaveIdentity))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_SetWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Wallet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).SetWallet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/SetWallet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).SetWallet(ctx, req.(*Wallet))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_SetProtectKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProtectKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).SetProtectKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/SetProtectKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).SetProtectKey(ctx, req.(*ProtectKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_SetRecoverKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecoverKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).SetRecoverKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/SetRecoverKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).SetRecoverKey(ctx, req.(*RecoverKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_SetCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Credential)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).SetCredential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/SetCredential",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).SetCredential(ctx, req.(*Credential))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_RemoveCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Credential)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).RemoveCredential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/RemoveCredential",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).RemoveCredential(ctx, req.(*Credential))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_RecoverKeyByCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Credential)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).RecoverKeyByCredential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/RecoverKeyByCredential",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).RecoverKeyByCredential(ctx, req.(*Credential))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_ClaimCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgClaimCredential)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).ClaimCredential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/ClaimCredential",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).ClaimCredential(ctx, req.(*MsgClaimCredential))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_SignRecoverKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSignRecoverPrivateKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).SignRecoverKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/SignRecoverKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).SignRecoverKey(ctx, req.(*MsgSignRecoverPrivateKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_QueryGetRecoverKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryGetRecoverKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).QueryGetRecoverKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/QueryGetRecoverKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).QueryGetRecoverKey(ctx, req.(*QueryGetRecoverKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_QueryFindCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryFindCredentialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).QueryFindCredential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/QueryFindCredential",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).QueryFindCredential(ctx, req.(*QueryFindCredentialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_QueryGetSubWalletIDByOriginalWalletID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Credential)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).QueryGetSubWalletIDByOriginalWalletID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/QueryGetSubWalletIDByOriginalWalletID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).QueryGetSubWalletIDByOriginalWalletID(ctx, req.(*Credential))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_ValidateAuthenticateServiceProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateAuthenticateServiceProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).ValidateAuthenticateServiceProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/ValidateAuthenticateServiceProvider",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).ValidateAuthenticateServiceProvider(ctx, req.(*ValidateAuthenticateServiceProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_ValidateAuthorizedSignatory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateAuthorizedSignatoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).ValidateAuthorizedSignatory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/ValidateAuthorizedSignatory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).ValidateAuthorizedSignatory(ctx, req.(*ValidateAuthorizedSignatoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_ValidateAuthorizedSigner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateAuthorizedSignerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).ValidateAuthorizedSigner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/ValidateAuthorizedSigner",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).ValidateAuthorizedSigner(ctx, req.(*ValidateAuthorizedSignerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_SetPublicKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublicKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).SetPublicKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/SetPublicKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).SetPublicKey(ctx, req.(*PublicKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_SetJarRegulator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JarRegulator)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).SetJarRegulator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/SetJarRegulator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).SetJarRegulator(ctx, req.(*JarRegulator))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_SetIntervalPublicKeyID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntervalPublicKeyID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).SetIntervalPublicKeyID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/SetIntervalPublicKeyID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).SetIntervalPublicKeyID(ctx, req.(*IntervalPublicKeyID))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_SetPioneerJar_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PioneerJar)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).SetPioneerJar(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/SetPioneerJar",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).SetPioneerJar(ctx, req.(*PioneerJar))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_SetSecretSharePrivateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecretSharePrivK)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).SetSecretSharePrivateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/SetSecretSharePrivateKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).SetSecretSharePrivateKey(ctx, req.(*SecretSharePrivK))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_ValidateDestinationWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateWallet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).ValidateDestinationWallet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/ValidateDestinationWallet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).ValidateDestinationWallet(ctx, req.(*MsgCreateWallet))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_ValidateCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBindCredential)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).ValidateCredential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/ValidateCredential",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).ValidateCredential(ctx, req.(*MsgBindCredential))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_ValidateTransferPrime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgTransferFunds)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).ValidateTransferPrime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/ValidateTransferPrime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).ValidateTransferPrime(ctx, req.(*MsgTransferFunds))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_ValidateTransferDoublePrime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgReceiveFunds)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).ValidateTransferDoublePrime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/ValidateTransferDoublePrime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).ValidateTransferDoublePrime(ctx, req.(*MsgReceiveFunds))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_SyncWallets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSyncWallets)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).SyncWallets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/SyncWallets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).SyncWallets(ctx, req.(*MsgSyncWallets))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_SyncCredentials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSyncCredentials)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).SyncCredentials(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/SyncCredentials",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).SyncCredentials(ctx, req.(*MsgSyncCredentials))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_SyncRecoverKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSyncRecoverKeys)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).SyncRecoverKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/SyncRecoverKeys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).SyncRecoverKeys(ctx, req.(*MsgSyncRecoverKeys))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_SyncSuspiciousTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSyncSuspiciousTransactions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).SyncSuspiciousTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/SyncSuspiciousTransactions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).SyncSuspiciousTransactions(ctx, req.(*MsgSyncSuspiciousTransactions))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_ScanTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgScanTransactions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).ScanTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/ScanTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).ScanTransaction(ctx, req.(*MsgScanTransactions))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_UpdateHeight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateHeight)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).UpdateHeight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/UpdateHeight",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).UpdateHeight(ctx, req.(*MsgUpdateHeight))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_TransactionComplete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgTransactionComplete)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).TransactionComplete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/TransactionComplete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).TransactionComplete(ctx, req.(*MsgTransactionComplete))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_EndBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgEndBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).EndBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/EndBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).EndBlock(ctx, req.(*MsgEndBlock))
	}
	return interceptor(ctx, in, info, handler)
}

func _QadenaEnclave_GetStoreHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgGetStoreHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QadenaEnclaveServer).GetStoreHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/qadena.qadena.QadenaEnclave/GetStoreHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QadenaEnclaveServer).GetStoreHash(ctx, req.(*MsgGetStoreHash))
	}
	return interceptor(ctx, in, info, handler)
}

var _QadenaEnclave_serviceDesc = grpc.ServiceDesc{
	ServiceName: "qadena.qadena.QadenaEnclave",
	HandlerType: (*QadenaEnclaveServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InitEnclave",
			Handler:    _QadenaEnclave_InitEnclave_Handler,
		},
		{
			MethodName: "SyncEnclave",
			Handler:    _QadenaEnclave_SyncEnclave_Handler,
		},
		{
			MethodName: "UpgradeEnclave",
			Handler:    _QadenaEnclave_UpgradeEnclave_Handler,
		},
		{
			MethodName: "ExportPrivateKey",
			Handler:    _QadenaEnclave_ExportPrivateKey_Handler,
		},
		{
			MethodName: "ExportPrivateState",
			Handler:    _QadenaEnclave_ExportPrivateState_Handler,
		},
		{
			MethodName: "RemovePrivateKey",
			Handler:    _QadenaEnclave_RemovePrivateKey_Handler,
		},
		{
			MethodName: "UpdateSSIntervalKey",
			Handler:    _QadenaEnclave_UpdateSSIntervalKey_Handler,
		},
		{
			MethodName: "QueryEnclaveSyncEnclave",
			Handler:    _QadenaEnclave_QueryEnclaveSyncEnclave_Handler,
		},
		{
			MethodName: "QueryEnclaveSecretShare",
			Handler:    _QadenaEnclave_QueryEnclaveSecretShare_Handler,
		},
		{
			MethodName: "QueryEnclaveRecoverKeyShare",
			Handler:    _QadenaEnclave_QueryEnclaveRecoverKeyShare_Handler,
		},
		{
			MethodName: "QueryEnclaveValidateEnclaveIdentity",
			Handler:    _QadenaEnclave_QueryEnclaveValidateEnclaveIdentity_Handler,
		},
		{
			MethodName: "SetEnclaveIdentity",
			Handler:    _QadenaEnclave_SetEnclaveIdentity_Handler,
		},
		{
			MethodName: "UpdateEnclaveIdentity",
			Handler:    _QadenaEnclave_UpdateEnclaveIdentity_Handler,
		},
		{
			MethodName: "SetWallet",
			Handler:    _QadenaEnclave_SetWallet_Handler,
		},
		{
			MethodName: "SetProtectKey",
			Handler:    _QadenaEnclave_SetProtectKey_Handler,
		},
		{
			MethodName: "SetRecoverKey",
			Handler:    _QadenaEnclave_SetRecoverKey_Handler,
		},
		{
			MethodName: "SetCredential",
			Handler:    _QadenaEnclave_SetCredential_Handler,
		},
		{
			MethodName: "RemoveCredential",
			Handler:    _QadenaEnclave_RemoveCredential_Handler,
		},
		{
			MethodName: "RecoverKeyByCredential",
			Handler:    _QadenaEnclave_RecoverKeyByCredential_Handler,
		},
		{
			MethodName: "ClaimCredential",
			Handler:    _QadenaEnclave_ClaimCredential_Handler,
		},
		{
			MethodName: "SignRecoverKey",
			Handler:    _QadenaEnclave_SignRecoverKey_Handler,
		},
		{
			MethodName: "QueryGetRecoverKey",
			Handler:    _QadenaEnclave_QueryGetRecoverKey_Handler,
		},
		{
			MethodName: "QueryFindCredential",
			Handler:    _QadenaEnclave_QueryFindCredential_Handler,
		},
		{
			MethodName: "QueryGetSubWalletIDByOriginalWalletID",
			Handler:    _QadenaEnclave_QueryGetSubWalletIDByOriginalWalletID_Handler,
		},
		{
			MethodName: "ValidateAuthenticateServiceProvider",
			Handler:    _QadenaEnclave_ValidateAuthenticateServiceProvider_Handler,
		},
		{
			MethodName: "ValidateAuthorizedSignatory",
			Handler:    _QadenaEnclave_ValidateAuthorizedSignatory_Handler,
		},
		{
			MethodName: "ValidateAuthorizedSigner",
			Handler:    _QadenaEnclave_ValidateAuthorizedSigner_Handler,
		},
		{
			MethodName: "SetPublicKey",
			Handler:    _QadenaEnclave_SetPublicKey_Handler,
		},
		{
			MethodName: "SetJarRegulator",
			Handler:    _QadenaEnclave_SetJarRegulator_Handler,
		},
		{
			MethodName: "SetIntervalPublicKeyID",
			Handler:    _QadenaEnclave_SetIntervalPublicKeyID_Handler,
		},
		{
			MethodName: "SetPioneerJar",
			Handler:    _QadenaEnclave_SetPioneerJar_Handler,
		},
		{
			MethodName: "SetSecretSharePrivateKey",
			Handler:    _QadenaEnclave_SetSecretSharePrivateKey_Handler,
		},
		{
			MethodName: "ValidateDestinationWallet",
			Handler:    _QadenaEnclave_ValidateDestinationWallet_Handler,
		},
		{
			MethodName: "ValidateCredential",
			Handler:    _QadenaEnclave_ValidateCredential_Handler,
		},
		{
			MethodName: "ValidateTransferPrime",
			Handler:    _QadenaEnclave_ValidateTransferPrime_Handler,
		},
		{
			MethodName: "ValidateTransferDoublePrime",
			Handler:    _QadenaEnclave_ValidateTransferDoublePrime_Handler,
		},
		{
			MethodName: "SyncWallets",
			Handler:    _QadenaEnclave_SyncWallets_Handler,
		},
		{
			MethodName: "SyncCredentials",
			Handler:    _QadenaEnclave_SyncCredentials_Handler,
		},
		{
			MethodName: "SyncRecoverKeys",
			Handler:    _QadenaEnclave_SyncRecoverKeys_Handler,
		},
		{
			MethodName: "SyncSuspiciousTransactions",
			Handler:    _QadenaEnclave_SyncSuspiciousTransactions_Handler,
		},
		{
			MethodName: "ScanTransaction",
			Handler:    _QadenaEnclave_ScanTransaction_Handler,
		},
		{
			MethodName: "UpdateHeight",
			Handler:    _QadenaEnclave_UpdateHeight_Handler,
		},
		{
			MethodName: "TransactionComplete",
			Handler:    _QadenaEnclave_TransactionComplete_Handler,
		},
		{
			MethodName: "EndBlock",
			Handler:    _QadenaEnclave_EndBlock_Handler,
		},
		{
			MethodName: "GetStoreHash",
			Handler:    _QadenaEnclave_GetStoreHash_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "qadena/qadena/enclave.proto",
}

func (m *HelloRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HelloRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HelloRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HelloReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HelloReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HelloReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgEndBlock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgEndBlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgEndBlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *EndBlockReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndBlockReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EndBlockReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryGetSubWalletIDByOriginalWalletIDResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryGetSubWalletIDByOriginalWalletIDResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryGetSubWalletIDByOriginalWalletIDResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubWalletID) > 0 {
		i -= len(m.SubWalletID)
		copy(dAtA[i:], m.SubWalletID)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.SubWalletID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StoreHash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreHash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreHash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgGetStoreHash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgGetStoreHash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgGetStoreHash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetStoreHashReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStoreHashReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetStoreHashReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hashes) > 0 {
		for iNdEx := len(m.Hashes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Hashes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEnclave(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgAddAsValidator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddAsValidator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddAsValidator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSyncEnclave) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSyncEnclave) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSyncEnclave) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SeedNode) > 0 {
		i -= len(m.SeedNode)
		copy(dAtA[i:], m.SeedNode)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.SeedNode)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PioneerArmorPassPhrase) > 0 {
		i -= len(m.PioneerArmorPassPhrase)
		copy(dAtA[i:], m.PioneerArmorPassPhrase)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.PioneerArmorPassPhrase)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PioneerArmorPrivK) > 0 {
		i -= len(m.PioneerArmorPrivK)
		copy(dAtA[i:], m.PioneerArmorPrivK)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.PioneerArmorPrivK)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ExternalAddress) > 0 {
		i -= len(m.ExternalAddress)
		copy(dAtA[i:], m.ExternalAddress)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.ExternalAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PioneerID) > 0 {
		i -= len(m.PioneerID)
		copy(dAtA[i:], m.PioneerID)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.PioneerID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpgradeEnclave) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpgradeEnclave) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpgradeEnclave) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EnclavePubK) > 0 {
		i -= len(m.EnclavePubK)
		copy(dAtA[i:], m.EnclavePubK)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.EnclavePubK)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RemoteReport) > 0 {
		i -= len(m.RemoteReport)
		copy(dAtA[i:], m.RemoteReport)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.RemoteReport)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpgradeEnclaveReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpgradeEnclaveReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpgradeEnclaveReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EncEnclavePrivateStateEnclavePubK) > 0 {
		i -= len(m.EncEnclavePrivateStateEnclavePubK)
		copy(dAtA[i:], m.EncEnclavePrivateStateEnclavePubK)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.EncEnclavePrivateStateEnclavePubK)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RemoteReport) > 0 {
		i -= len(m.RemoteReport)
		copy(dAtA[i:], m.RemoteReport)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.RemoteReport)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgExportPrivateKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgExportPrivateKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgExportPrivateKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PubKID) > 0 {
		i -= len(m.PubKID)
		copy(dAtA[i:], m.PubKID)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.PubKID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRemovePrivateKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRemovePrivateKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRemovePrivateKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PubKID) > 0 {
		i -= len(m.PubKID)
		copy(dAtA[i:], m.PubKID)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.PubKID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgExportPrivateState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgExportPrivateState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgExportPrivateState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateSSIntervalKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateSSIntervalKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateSSIntervalKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *UpdateSSIntervalKeyReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateSSIntervalKeyReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateSSIntervalKeyReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *RemovePrivateKeyReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemovePrivateKeyReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemovePrivateKeyReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ExportPrivateKeyReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportPrivateKeyReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExportPrivateKeyReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PrivK) > 0 {
		i -= len(m.PrivK)
		copy(dAtA[i:], m.PrivK)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.PrivK)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExportPrivateStateReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportPrivateStateReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExportPrivateStateReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidateAuthenticateServiceProviderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateAuthenticateServiceProviderRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidateAuthenticateServiceProviderRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ServiceProviderType) > 0 {
		i -= len(m.ServiceProviderType)
		copy(dAtA[i:], m.ServiceProviderType)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.ServiceProviderType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PubKID) > 0 {
		i -= len(m.PubKID)
		copy(dAtA[i:], m.PubKID)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.PubKID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidateAuthenticateServiceProviderReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateAuthenticateServiceProviderReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidateAuthenticateServiceProviderReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgInitEnclave) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgInitEnclave) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgInitEnclave) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UniqueID) > 0 {
		i -= len(m.UniqueID)
		copy(dAtA[i:], m.UniqueID)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.UniqueID)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SignerID) > 0 {
		i -= len(m.SignerID)
		copy(dAtA[i:], m.SignerID)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.SignerID)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.RegulatorID) > 0 {
		i -= len(m.RegulatorID)
		copy(dAtA[i:], m.RegulatorID)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.RegulatorID)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.JarID) > 0 {
		i -= len(m.JarID)
		copy(dAtA[i:], m.JarID)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.JarID)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PioneerArmorPassPhrase) > 0 {
		i -= len(m.PioneerArmorPassPhrase)
		copy(dAtA[i:], m.PioneerArmorPassPhrase)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.PioneerArmorPassPhrase)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PioneerArmorPrivK) > 0 {
		i -= len(m.PioneerArmorPrivK)
		copy(dAtA[i:], m.PioneerArmorPrivK)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.PioneerArmorPrivK)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ExternalAddress) > 0 {
		i -= len(m.ExternalAddress)
		copy(dAtA[i:], m.ExternalAddress)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.ExternalAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PioneerID) > 0 {
		i -= len(m.PioneerID)
		copy(dAtA[i:], m.PioneerID)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.PioneerID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VShareSignatory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VShareSignatory) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VShareSignatory) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VShareBind != nil {
		{
			size, err := m.VShareBind.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEnclave(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.EncSignatoryVShare) > 0 {
		i -= len(m.EncSignatoryVShare)
		copy(dAtA[i:], m.EncSignatoryVShare)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.EncSignatoryVShare)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidateAuthorizedSignerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateAuthorizedSignerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidateAuthorizedSignerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CompletedSignatory) > 0 {
		for iNdEx := len(m.CompletedSignatory) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CompletedSignatory[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEnclave(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.RequiredSignatory) > 0 {
		for iNdEx := len(m.RequiredSignatory) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RequiredSignatory[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEnclave(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.RequestingSignatory != nil {
		{
			size, err := m.RequestingSignatory.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEnclave(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidateAuthorizedSignerReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateAuthorizedSignerReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidateAuthorizedSignerReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ValidateAuthorizedSignatoryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateAuthorizedSignatoryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidateAuthorizedSignatoryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CurrentSignatory) > 0 {
		for iNdEx := len(m.CurrentSignatory) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CurrentSignatory[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEnclave(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Signatory != nil {
		{
			size, err := m.Signatory.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEnclave(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidateAuthorizedSignatoryReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateAuthorizedSignatoryReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidateAuthorizedSignatoryReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateHeight) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateHeight) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateHeight) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsProposer {
		i--
		if m.IsProposer {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Height != 0 {
		i = encodeVarintEnclave(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgScanTransactions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgScanTransactions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgScanTransactions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Exchangerate) > 0 {
		i -= len(m.Exchangerate)
		copy(dAtA[i:], m.Exchangerate)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.Exchangerate)))
		i--
		dAtA[i] = 0x22
	}
	if m.Msg != nil {
		{
			size, err := m.Msg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEnclave(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Height != 0 {
		i = encodeVarintEnclave(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	n5, err5 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintEnclave(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgSyncWallets) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSyncWallets) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSyncWallets) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Clear {
		i--
		if m.Clear {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SyncWalletsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncWalletsReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncWalletsReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Wallets) > 0 {
		for iNdEx := len(m.Wallets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Wallets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEnclave(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgSyncCredentials) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSyncCredentials) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSyncCredentials) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Clear {
		i--
		if m.Clear {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SyncCredentialsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncCredentialsReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncCredentialsReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Credentials) > 0 {
		for iNdEx := len(m.Credentials) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Credentials[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEnclave(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgSyncRecoverKeys) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSyncRecoverKeys) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSyncRecoverKeys) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Clear {
		i--
		if m.Clear {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SyncRecoverKeysReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncRecoverKeysReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncRecoverKeysReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RecoverKeys) > 0 {
		for iNdEx := len(m.RecoverKeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RecoverKeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEnclave(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SetSecretSharePrivateKeyReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetSecretSharePrivateKeyReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetSecretSharePrivateKeyReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgSyncSuspiciousTransactions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSyncSuspiciousTransactions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSyncSuspiciousTransactions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Clear {
		i--
		if m.Clear {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SyncSuspiciousTransactionsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncSuspiciousTransactionsReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncSuspiciousTransactionsReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SuspiciousTransactions) > 0 {
		for iNdEx := len(m.SuspiciousTransactions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SuspiciousTransactions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEnclave(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *InitEnclaveReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitEnclaveReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InitEnclaveReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateHeightReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateHeightReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateHeightReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgTransactionComplete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTransactionComplete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTransactionComplete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TransactionCompleteReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionCompleteReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionCompleteReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SyncEnclaveReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncEnclaveReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncEnclaveReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddAsValidatorReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddAsValidatorReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddAsValidatorReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetWalletReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetWalletReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetWalletReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetEnclaveIdentityReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetEnclaveIdentityReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetEnclaveIdentityReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PioneerUpdateEnclaveIdentity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PioneerUpdateEnclaveIdentity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PioneerUpdateEnclaveIdentity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RemoteReport) > 0 {
		i -= len(m.RemoteReport)
		copy(dAtA[i:], m.RemoteReport)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.RemoteReport)))
		i--
		dAtA[i] = 0x12
	}
	if m.EnclaveIdentity != nil {
		{
			size, err := m.EnclaveIdentity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEnclave(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateEnclaveIdentityReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateEnclaveIdentityReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateEnclaveIdentityReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetProtectKeyReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetProtectKeyReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetProtectKeyReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetRecoverKeyReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetRecoverKeyReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetRecoverKeyReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetCredentialReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetCredentialReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetCredentialReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemoveCredentialReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveCredentialReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveCredentialReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RecoverKeyReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoverKeyReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoverKeyReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SignRecoverKeyReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignRecoverKeyReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignRecoverKeyReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetPublicKeyReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetPublicKeyReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetPublicKeyReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetJarRegulatorReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetJarRegulatorReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetJarRegulatorReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetPioneerJarReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetPioneerJarReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetPioneerJarReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetIntervalPublicKeyIdReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetIntervalPublicKeyIdReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetIntervalPublicKeyIdReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ValidateDestinationWalletReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateDestinationWalletReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidateDestinationWalletReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintEnclave(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ValidateCredentialReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateCredentialReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidateCredentialReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ValidateTransferPrimeReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateTransferPrimeReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidateTransferPrimeReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateSourceWallet {
		i--
		if m.UpdateSourceWallet {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ValidateTransferDoublePrimeReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateTransferDoublePrimeReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidateTransferDoublePrimeReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateDestinationWallet {
		i--
		if m.UpdateDestinationWallet {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ScanTransactionReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanTransactionReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScanTransactionReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EnclaveStoreStringArray) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnclaveStoreStringArray) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnclaveStoreStringArray) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.A) > 0 {
		for iNdEx := len(m.A) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.A[iNdEx])
			copy(dAtA[i:], m.A[iNdEx])
			i = encodeVarintEnclave(dAtA, i, uint64(len(m.A[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EnclaveStoreString) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnclaveStoreString) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnclaveStoreString) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.S) > 0 {
		i -= len(m.S)
		copy(dAtA[i:], m.S)
		i = encodeVarintEnclave(dAtA, i, uint64(len(m.S)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EnclaveEnclaveIdentityArray) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnclaveEnclaveIdentityArray) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnclaveEnclaveIdentityArray) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Identity) > 0 {
		for iNdEx := len(m.Identity) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Identity[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEnclave(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintEnclave(dAtA []byte, offset int, v uint64) int {
	offset -= sovEnclave(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *HelloRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	return n
}

func (m *HelloReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	return n
}

func (m *MsgEndBlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *EndBlockReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryGetSubWalletIDByOriginalWalletIDResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SubWalletID)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	return n
}

func (m *StoreHash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	return n
}

func (m *MsgGetStoreHash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetStoreHashReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Hashes) > 0 {
		for _, e := range m.Hashes {
			l = e.Size()
			n += 1 + l + sovEnclave(uint64(l))
		}
	}
	return n
}

func (m *MsgAddAsValidator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSyncEnclave) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PioneerID)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	l = len(m.ExternalAddress)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	l = len(m.PioneerArmorPrivK)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	l = len(m.PioneerArmorPassPhrase)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	l = len(m.SeedNode)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	return n
}

func (m *MsgUpgradeEnclave) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RemoteReport)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	l = len(m.EnclavePubK)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	return n
}

func (m *UpgradeEnclaveReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RemoteReport)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	l = len(m.EncEnclavePrivateStateEnclavePubK)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	return n
}

func (m *MsgExportPrivateKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PubKID)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	return n
}

func (m *MsgRemovePrivateKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PubKID)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	return n
}

func (m *MsgExportPrivateState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateSSIntervalKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *UpdateSSIntervalKeyReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *RemovePrivateKeyReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ExportPrivateKeyReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PrivK)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	return n
}

func (m *ExportPrivateStateReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	return n
}

func (m *ValidateAuthenticateServiceProviderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PubKID)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	l = len(m.ServiceProviderType)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	return n
}

func (m *ValidateAuthenticateServiceProviderReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	return n
}

func (m *MsgInitEnclave) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PioneerID)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	l = len(m.ExternalAddress)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	l = len(m.PioneerArmorPrivK)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	l = len(m.PioneerArmorPassPhrase)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	l = len(m.JarID)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	l = len(m.RegulatorID)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	l = len(m.SignerID)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	l = len(m.UniqueID)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	return n
}

func (m *VShareSignatory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EncSignatoryVShare)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	if m.VShareBind != nil {
		l = m.VShareBind.Size()
		n += 1 + l + sovEnclave(uint64(l))
	}
	return n
}

func (m *ValidateAuthorizedSignerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	if m.RequestingSignatory != nil {
		l = m.RequestingSignatory.Size()
		n += 1 + l + sovEnclave(uint64(l))
	}
	if len(m.RequiredSignatory) > 0 {
		for _, e := range m.RequiredSignatory {
			l = e.Size()
			n += 1 + l + sovEnclave(uint64(l))
		}
	}
	if len(m.CompletedSignatory) > 0 {
		for _, e := range m.CompletedSignatory {
			l = e.Size()
			n += 1 + l + sovEnclave(uint64(l))
		}
	}
	return n
}

func (m *ValidateAuthorizedSignerReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	return n
}

func (m *ValidateAuthorizedSignatoryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	if m.Signatory != nil {
		l = m.Signatory.Size()
		n += 1 + l + sovEnclave(uint64(l))
	}
	if len(m.CurrentSignatory) > 0 {
		for _, e := range m.CurrentSignatory {
			l = e.Size()
			n += 1 + l + sovEnclave(uint64(l))
		}
	}
	return n
}

func (m *ValidateAuthorizedSignatoryReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	return n
}

func (m *MsgUpdateHeight) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovEnclave(uint64(m.Height))
	}
	if m.IsProposer {
		n += 2
	}
	return n
}

func (m *MsgScanTransactions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovEnclave(uint64(l))
	if m.Height != 0 {
		n += 1 + sovEnclave(uint64(m.Height))
	}
	if m.Msg != nil {
		l = m.Msg.Size()
		n += 1 + l + sovEnclave(uint64(l))
	}
	l = len(m.Exchangerate)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	return n
}

func (m *MsgSyncWallets) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Clear {
		n += 2
	}
	return n
}

func (m *SyncWalletsReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Wallets) > 0 {
		for _, e := range m.Wallets {
			l = e.Size()
			n += 1 + l + sovEnclave(uint64(l))
		}
	}
	return n
}

func (m *MsgSyncCredentials) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Clear {
		n += 2
	}
	return n
}

func (m *SyncCredentialsReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Credentials) > 0 {
		for _, e := range m.Credentials {
			l = e.Size()
			n += 1 + l + sovEnclave(uint64(l))
		}
	}
	return n
}

func (m *MsgSyncRecoverKeys) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Clear {
		n += 2
	}
	return n
}

func (m *SyncRecoverKeysReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RecoverKeys) > 0 {
		for _, e := range m.RecoverKeys {
			l = e.Size()
			n += 1 + l + sovEnclave(uint64(l))
		}
	}
	return n
}

func (m *SetSecretSharePrivateKeyReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	return n
}

func (m *MsgSyncSuspiciousTransactions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Clear {
		n += 2
	}
	return n
}

func (m *SyncSuspiciousTransactionsReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SuspiciousTransactions) > 0 {
		for _, e := range m.SuspiciousTransactions {
			l = e.Size()
			n += 1 + l + sovEnclave(uint64(l))
		}
	}
	return n
}

func (m *InitEnclaveReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	return n
}

func (m *UpdateHeightReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	return n
}

func (m *MsgTransactionComplete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func (m *TransactionCompleteReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	return n
}

func (m *SyncEnclaveReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	return n
}

func (m *AddAsValidatorReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	return n
}

func (m *SetWalletReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	return n
}

func (m *SetEnclaveIdentityReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	return n
}

func (m *PioneerUpdateEnclaveIdentity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnclaveIdentity != nil {
		l = m.EnclaveIdentity.Size()
		n += 1 + l + sovEnclave(uint64(l))
	}
	l = len(m.RemoteReport)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	return n
}

func (m *UpdateEnclaveIdentityReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	return n
}

func (m *SetProtectKeyReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	return n
}

func (m *SetRecoverKeyReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	return n
}

func (m *SetCredentialReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	return n
}

func (m *RemoveCredentialReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	return n
}

func (m *RecoverKeyReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	return n
}

func (m *SignRecoverKeyReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	return n
}

func (m *SetPublicKeyReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	return n
}

func (m *SetJarRegulatorReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	return n
}

func (m *SetPioneerJarReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	return n
}

func (m *SetIntervalPublicKeyIdReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	return n
}

func (m *ValidateDestinationWalletReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovEnclave(uint64(m.Status))
	}
	return n
}

func (m *ValidateCredentialReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	return n
}

func (m *ValidateTransferPrimeReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateSourceWallet {
		n += 2
	}
	return n
}

func (m *ValidateTransferDoublePrimeReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateDestinationWallet {
		n += 2
	}
	return n
}

func (m *ScanTransactionReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	return n
}

func (m *EnclaveStoreStringArray) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.A) > 0 {
		for _, s := range m.A {
			l = len(s)
			n += 1 + l + sovEnclave(uint64(l))
		}
	}
	return n
}

func (m *EnclaveStoreString) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.S)
	if l > 0 {
		n += 1 + l + sovEnclave(uint64(l))
	}
	return n
}

func (m *EnclaveEnclaveIdentityArray) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Identity) > 0 {
		for _, e := range m.Identity {
			l = e.Size()
			n += 1 + l + sovEnclave(uint64(l))
		}
	}
	return n
}

func sovEnclave(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEnclave(x uint64) (n int) {
	return sovEnclave(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HelloRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HelloRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HelloRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HelloReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HelloReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HelloReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgEndBlock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgEndBlock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgEndBlock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndBlockReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndBlockReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndBlockReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryGetSubWalletIDByOriginalWalletIDResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryGetSubWalletIDByOriginalWalletIDResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryGetSubWalletIDByOriginalWalletIDResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubWalletID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubWalletID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreHash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreHash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreHash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgGetStoreHash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgGetStoreHash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgGetStoreHash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStoreHashReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStoreHashReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStoreHashReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hashes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hashes = append(m.Hashes, &StoreHash{})
			if err := m.Hashes[len(m.Hashes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddAsValidator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddAsValidator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddAsValidator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSyncEnclave) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSyncEnclave: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSyncEnclave: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PioneerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PioneerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PioneerArmorPrivK", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PioneerArmorPrivK = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PioneerArmorPassPhrase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PioneerArmorPassPhrase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeedNode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeedNode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpgradeEnclave) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpgradeEnclave: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpgradeEnclave: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteReport", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteReport = append(m.RemoteReport[:0], dAtA[iNdEx:postIndex]...)
			if m.RemoteReport == nil {
				m.RemoteReport = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnclavePubK", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnclavePubK = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpgradeEnclaveReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpgradeEnclaveReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpgradeEnclaveReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteReport", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteReport = append(m.RemoteReport[:0], dAtA[iNdEx:postIndex]...)
			if m.RemoteReport == nil {
				m.RemoteReport = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncEnclavePrivateStateEnclavePubK", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncEnclavePrivateStateEnclavePubK = append(m.EncEnclavePrivateStateEnclavePubK[:0], dAtA[iNdEx:postIndex]...)
			if m.EncEnclavePrivateStateEnclavePubK == nil {
				m.EncEnclavePrivateStateEnclavePubK = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgExportPrivateKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgExportPrivateKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgExportPrivateKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRemovePrivateKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRemovePrivateKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRemovePrivateKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgExportPrivateState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgExportPrivateState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgExportPrivateState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateSSIntervalKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateSSIntervalKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateSSIntervalKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateSSIntervalKeyReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateSSIntervalKeyReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateSSIntervalKeyReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemovePrivateKeyReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemovePrivateKeyReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemovePrivateKeyReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportPrivateKeyReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportPrivateKeyReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportPrivateKeyReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivK", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivK = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportPrivateStateReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportPrivateStateReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportPrivateStateReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateAuthenticateServiceProviderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateAuthenticateServiceProviderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateAuthenticateServiceProviderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceProviderType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceProviderType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateAuthenticateServiceProviderReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateAuthenticateServiceProviderReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateAuthenticateServiceProviderReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgInitEnclave) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgInitEnclave: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgInitEnclave: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PioneerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PioneerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PioneerArmorPrivK", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PioneerArmorPrivK = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PioneerArmorPassPhrase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PioneerArmorPassPhrase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JarID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JarID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegulatorID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegulatorID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VShareSignatory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VShareSignatory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VShareSignatory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncSignatoryVShare", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncSignatoryVShare = append(m.EncSignatoryVShare[:0], dAtA[iNdEx:postIndex]...)
			if m.EncSignatoryVShare == nil {
				m.EncSignatoryVShare = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VShareBind", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VShareBind == nil {
				m.VShareBind = &VShareBindData{}
			}
			if err := m.VShareBind.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateAuthorizedSignerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateAuthorizedSignerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateAuthorizedSignerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestingSignatory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestingSignatory == nil {
				m.RequestingSignatory = &VShareSignatory{}
			}
			if err := m.RequestingSignatory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredSignatory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequiredSignatory = append(m.RequiredSignatory, &VShareSignatory{})
			if err := m.RequiredSignatory[len(m.RequiredSignatory)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedSignatory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompletedSignatory = append(m.CompletedSignatory, &VShareSignatory{})
			if err := m.CompletedSignatory[len(m.CompletedSignatory)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateAuthorizedSignerReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateAuthorizedSignerReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateAuthorizedSignerReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateAuthorizedSignatoryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateAuthorizedSignatoryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateAuthorizedSignatoryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signatory == nil {
				m.Signatory = &VShareSignatory{}
			}
			if err := m.Signatory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentSignatory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentSignatory = append(m.CurrentSignatory, &VShareSignatory{})
			if err := m.CurrentSignatory[len(m.CurrentSignatory)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateAuthorizedSignatoryReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateAuthorizedSignatoryReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateAuthorizedSignatoryReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateHeight) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateHeight: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateHeight: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsProposer", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsProposer = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgScanTransactions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgScanTransactions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgScanTransactions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Msg == nil {
				m.Msg = &MsgTransferFunds{}
			}
			if err := m.Msg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchangerate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exchangerate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSyncWallets) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSyncWallets: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSyncWallets: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clear", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Clear = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncWalletsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncWalletsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncWalletsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wallets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Wallets = append(m.Wallets, &Wallet{})
			if err := m.Wallets[len(m.Wallets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSyncCredentials) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSyncCredentials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSyncCredentials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clear", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Clear = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncCredentialsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncCredentialsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncCredentialsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Credentials = append(m.Credentials, &Credential{})
			if err := m.Credentials[len(m.Credentials)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSyncRecoverKeys) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSyncRecoverKeys: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSyncRecoverKeys: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clear", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Clear = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncRecoverKeysReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncRecoverKeysReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncRecoverKeysReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoverKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecoverKeys = append(m.RecoverKeys, &RecoverKey{})
			if err := m.RecoverKeys[len(m.RecoverKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetSecretSharePrivateKeyReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetSecretSharePrivateKeyReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetSecretSharePrivateKeyReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSyncSuspiciousTransactions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSyncSuspiciousTransactions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSyncSuspiciousTransactions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clear", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Clear = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncSuspiciousTransactionsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncSuspiciousTransactionsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncSuspiciousTransactionsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuspiciousTransactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SuspiciousTransactions = append(m.SuspiciousTransactions, &SuspiciousTransaction{})
			if err := m.SuspiciousTransactions[len(m.SuspiciousTransactions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitEnclaveReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitEnclaveReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitEnclaveReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateHeightReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateHeightReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateHeightReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTransactionComplete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTransactionComplete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTransactionComplete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionCompleteReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionCompleteReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionCompleteReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncEnclaveReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncEnclaveReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncEnclaveReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddAsValidatorReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddAsValidatorReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddAsValidatorReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetWalletReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetWalletReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetWalletReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetEnclaveIdentityReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetEnclaveIdentityReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetEnclaveIdentityReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PioneerUpdateEnclaveIdentity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PioneerUpdateEnclaveIdentity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PioneerUpdateEnclaveIdentity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnclaveIdentity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnclaveIdentity == nil {
				m.EnclaveIdentity = &EnclaveIdentity{}
			}
			if err := m.EnclaveIdentity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteReport", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteReport = append(m.RemoteReport[:0], dAtA[iNdEx:postIndex]...)
			if m.RemoteReport == nil {
				m.RemoteReport = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateEnclaveIdentityReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateEnclaveIdentityReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateEnclaveIdentityReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetProtectKeyReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetProtectKeyReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetProtectKeyReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetRecoverKeyReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetRecoverKeyReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetRecoverKeyReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetCredentialReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetCredentialReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetCredentialReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveCredentialReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveCredentialReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveCredentialReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoverKeyReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecoverKeyReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecoverKeyReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignRecoverKeyReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignRecoverKeyReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignRecoverKeyReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetPublicKeyReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetPublicKeyReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetPublicKeyReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetJarRegulatorReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetJarRegulatorReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetJarRegulatorReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetPioneerJarReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetPioneerJarReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetPioneerJarReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetIntervalPublicKeyIdReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetIntervalPublicKeyIdReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetIntervalPublicKeyIdReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateDestinationWalletReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateDestinationWalletReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateDestinationWalletReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateCredentialReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateCredentialReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateCredentialReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateTransferPrimeReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateTransferPrimeReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateTransferPrimeReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateSourceWallet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateSourceWallet = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateTransferDoublePrimeReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateTransferDoublePrimeReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateTransferDoublePrimeReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateDestinationWallet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateDestinationWallet = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanTransactionReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanTransactionReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanTransactionReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnclaveStoreStringArray) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnclaveStoreStringArray: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnclaveStoreStringArray: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.A = append(m.A, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnclaveStoreString) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnclaveStoreString: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnclaveStoreString: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.S = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnclaveEnclaveIdentityArray) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnclaveEnclaveIdentityArray: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnclaveEnclaveIdentityArray: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnclave
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnclave
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = append(m.Identity, &EnclaveIdentity{})
			if err := m.Identity[len(m.Identity)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnclave(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEnclave
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEnclave(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEnclave
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEnclave
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEnclave
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEnclave
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEnclave
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEnclave        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEnclave          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEnclave = fmt.Errorf("proto: unexpected end of group")
)
