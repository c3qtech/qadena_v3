// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: qadena/qadena/encryptable.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type EncryptableString struct {
	Value string `protobuf:"bytes,1,opt,name=Value,proto3" json:"Value,omitempty"`
}

func (m *EncryptableString) Reset()         { *m = EncryptableString{} }
func (m *EncryptableString) String() string { return proto.CompactTextString(m) }
func (*EncryptableString) ProtoMessage()    {}
func (*EncryptableString) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef4cf267f6afd07c, []int{0}
}
func (m *EncryptableString) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptableString) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptableString.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptableString) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptableString.Merge(m, src)
}
func (m *EncryptableString) XXX_Size() int {
	return m.Size()
}
func (m *EncryptableString) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptableString.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptableString proto.InternalMessageInfo

func (m *EncryptableString) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type EncryptableClaimCredentialExtraParms struct {
	EncCredentialInfoVShare  []byte                     `protobuf:"bytes,1,opt,name=EncCredentialInfoVShare,proto3" json:"EncCredentialInfoVShare,omitempty"`
	CredentialInfoVShareBind *VShareBindData            `protobuf:"bytes,2,opt,name=CredentialInfoVShareBind,proto3" json:"CredentialInfoVShareBind,omitempty"`
	WalletID                 string                     `protobuf:"bytes,3,opt,name=WalletID,proto3" json:"WalletID,omitempty"`
	FindCredentialPC         *BPedersenCommit           `protobuf:"bytes,4,opt,name=FindCredentialPC,proto3" json:"FindCredentialPC,omitempty"`
	NewCredentialPC          *BPedersenCommit           `protobuf:"bytes,5,opt,name=NewCredentialPC,proto3" json:"NewCredentialPC,omitempty"`
	EncWalletIDVShare        []byte                     `protobuf:"bytes,6,opt,name=EncWalletIDVShare,proto3" json:"EncWalletIDVShare,omitempty"`
	WalletIDVShareBind       *VShareBindData            `protobuf:"bytes,7,opt,name=WalletIDVShareBind,proto3" json:"WalletIDVShareBind,omitempty"`
	EncCredentialHashVShare  []byte                     `protobuf:"bytes,8,opt,name=EncCredentialHashVShare,proto3" json:"EncCredentialHashVShare,omitempty"`
	CredentialHashVShareBind *VShareBindData            `protobuf:"bytes,9,opt,name=CredentialHashVShareBind,proto3" json:"CredentialHashVShareBind,omitempty"`
	ZeroPC                   *EncryptablePedersenCommit `protobuf:"bytes,10,opt,name=ZeroPC,proto3" json:"ZeroPC,omitempty"`
	ClaimPC                  *BPedersenCommit           `protobuf:"bytes,11,opt,name=ClaimPC,proto3" json:"ClaimPC,omitempty"`
}

func (m *EncryptableClaimCredentialExtraParms) Reset()         { *m = EncryptableClaimCredentialExtraParms{} }
func (m *EncryptableClaimCredentialExtraParms) String() string { return proto.CompactTextString(m) }
func (*EncryptableClaimCredentialExtraParms) ProtoMessage()    {}
func (*EncryptableClaimCredentialExtraParms) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef4cf267f6afd07c, []int{1}
}
func (m *EncryptableClaimCredentialExtraParms) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptableClaimCredentialExtraParms) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptableClaimCredentialExtraParms.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptableClaimCredentialExtraParms) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptableClaimCredentialExtraParms.Merge(m, src)
}
func (m *EncryptableClaimCredentialExtraParms) XXX_Size() int {
	return m.Size()
}
func (m *EncryptableClaimCredentialExtraParms) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptableClaimCredentialExtraParms.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptableClaimCredentialExtraParms proto.InternalMessageInfo

func (m *EncryptableClaimCredentialExtraParms) GetEncCredentialInfoVShare() []byte {
	if m != nil {
		return m.EncCredentialInfoVShare
	}
	return nil
}

func (m *EncryptableClaimCredentialExtraParms) GetCredentialInfoVShareBind() *VShareBindData {
	if m != nil {
		return m.CredentialInfoVShareBind
	}
	return nil
}

func (m *EncryptableClaimCredentialExtraParms) GetWalletID() string {
	if m != nil {
		return m.WalletID
	}
	return ""
}

func (m *EncryptableClaimCredentialExtraParms) GetFindCredentialPC() *BPedersenCommit {
	if m != nil {
		return m.FindCredentialPC
	}
	return nil
}

func (m *EncryptableClaimCredentialExtraParms) GetNewCredentialPC() *BPedersenCommit {
	if m != nil {
		return m.NewCredentialPC
	}
	return nil
}

func (m *EncryptableClaimCredentialExtraParms) GetEncWalletIDVShare() []byte {
	if m != nil {
		return m.EncWalletIDVShare
	}
	return nil
}

func (m *EncryptableClaimCredentialExtraParms) GetWalletIDVShareBind() *VShareBindData {
	if m != nil {
		return m.WalletIDVShareBind
	}
	return nil
}

func (m *EncryptableClaimCredentialExtraParms) GetEncCredentialHashVShare() []byte {
	if m != nil {
		return m.EncCredentialHashVShare
	}
	return nil
}

func (m *EncryptableClaimCredentialExtraParms) GetCredentialHashVShareBind() *VShareBindData {
	if m != nil {
		return m.CredentialHashVShareBind
	}
	return nil
}

func (m *EncryptableClaimCredentialExtraParms) GetZeroPC() *EncryptablePedersenCommit {
	if m != nil {
		return m.ZeroPC
	}
	return nil
}

func (m *EncryptableClaimCredentialExtraParms) GetClaimPC() *BPedersenCommit {
	if m != nil {
		return m.ClaimPC
	}
	return nil
}

type EncryptableAuthorizedSignatory struct {
	Nonce    string `protobuf:"bytes,1,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	WalletID string `protobuf:"bytes,2,opt,name=WalletID,proto3" json:"WalletID,omitempty"`
}

func (m *EncryptableAuthorizedSignatory) Reset()         { *m = EncryptableAuthorizedSignatory{} }
func (m *EncryptableAuthorizedSignatory) String() string { return proto.CompactTextString(m) }
func (*EncryptableAuthorizedSignatory) ProtoMessage()    {}
func (*EncryptableAuthorizedSignatory) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef4cf267f6afd07c, []int{2}
}
func (m *EncryptableAuthorizedSignatory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptableAuthorizedSignatory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptableAuthorizedSignatory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptableAuthorizedSignatory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptableAuthorizedSignatory.Merge(m, src)
}
func (m *EncryptableAuthorizedSignatory) XXX_Size() int {
	return m.Size()
}
func (m *EncryptableAuthorizedSignatory) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptableAuthorizedSignatory.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptableAuthorizedSignatory proto.InternalMessageInfo

func (m *EncryptableAuthorizedSignatory) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *EncryptableAuthorizedSignatory) GetWalletID() string {
	if m != nil {
		return m.WalletID
	}
	return ""
}

type EncryptableSignatory struct {
	Nonce       string `protobuf:"bytes,1,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	Email       string `protobuf:"bytes,2,opt,name=Email,proto3" json:"Email,omitempty"`
	PhoneNumber string `protobuf:"bytes,3,opt,name=PhoneNumber,proto3" json:"PhoneNumber,omitempty"`
}

func (m *EncryptableSignatory) Reset()         { *m = EncryptableSignatory{} }
func (m *EncryptableSignatory) String() string { return proto.CompactTextString(m) }
func (*EncryptableSignatory) ProtoMessage()    {}
func (*EncryptableSignatory) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef4cf267f6afd07c, []int{3}
}
func (m *EncryptableSignatory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptableSignatory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptableSignatory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptableSignatory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptableSignatory.Merge(m, src)
}
func (m *EncryptableSignatory) XXX_Size() int {
	return m.Size()
}
func (m *EncryptableSignatory) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptableSignatory.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptableSignatory proto.InternalMessageInfo

func (m *EncryptableSignatory) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *EncryptableSignatory) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *EncryptableSignatory) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

type EncryptableWalletAmount struct {
	Nonce                    string                     `protobuf:"bytes,1,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	TransactionID            string                     `protobuf:"bytes,2,opt,name=TransactionID,proto3" json:"TransactionID,omitempty"`
	PedersenCommit           *EncryptablePedersenCommit `protobuf:"bytes,3,opt,name=PedersenCommit,proto3" json:"PedersenCommit,omitempty"`
	Note                     string                     `protobuf:"bytes,4,opt,name=Note,proto3" json:"Note,omitempty"`
	RequiredSenderPIN        string                     `protobuf:"bytes,5,opt,name=RequiredSenderPIN,proto3" json:"RequiredSenderPIN,omitempty"`
	RequiredSenderFirstName  string                     `protobuf:"bytes,6,opt,name=RequiredSenderFirstName,proto3" json:"RequiredSenderFirstName,omitempty"`
	RequiredSenderMiddleName string                     `protobuf:"bytes,7,opt,name=RequiredSenderMiddleName,proto3" json:"RequiredSenderMiddleName,omitempty"`
	RequiredSenderLastName   string                     `protobuf:"bytes,8,opt,name=RequiredSenderLastName,proto3" json:"RequiredSenderLastName,omitempty"`
}

func (m *EncryptableWalletAmount) Reset()         { *m = EncryptableWalletAmount{} }
func (m *EncryptableWalletAmount) String() string { return proto.CompactTextString(m) }
func (*EncryptableWalletAmount) ProtoMessage()    {}
func (*EncryptableWalletAmount) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef4cf267f6afd07c, []int{4}
}
func (m *EncryptableWalletAmount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptableWalletAmount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptableWalletAmount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptableWalletAmount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptableWalletAmount.Merge(m, src)
}
func (m *EncryptableWalletAmount) XXX_Size() int {
	return m.Size()
}
func (m *EncryptableWalletAmount) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptableWalletAmount.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptableWalletAmount proto.InternalMessageInfo

func (m *EncryptableWalletAmount) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *EncryptableWalletAmount) GetTransactionID() string {
	if m != nil {
		return m.TransactionID
	}
	return ""
}

func (m *EncryptableWalletAmount) GetPedersenCommit() *EncryptablePedersenCommit {
	if m != nil {
		return m.PedersenCommit
	}
	return nil
}

func (m *EncryptableWalletAmount) GetNote() string {
	if m != nil {
		return m.Note
	}
	return ""
}

func (m *EncryptableWalletAmount) GetRequiredSenderPIN() string {
	if m != nil {
		return m.RequiredSenderPIN
	}
	return ""
}

func (m *EncryptableWalletAmount) GetRequiredSenderFirstName() string {
	if m != nil {
		return m.RequiredSenderFirstName
	}
	return ""
}

func (m *EncryptableWalletAmount) GetRequiredSenderMiddleName() string {
	if m != nil {
		return m.RequiredSenderMiddleName
	}
	return ""
}

func (m *EncryptableWalletAmount) GetRequiredSenderLastName() string {
	if m != nil {
		return m.RequiredSenderLastName
	}
	return ""
}

type EncryptablePersonalInfoDetails struct {
	FirstName   string `protobuf:"bytes,1,opt,name=FirstName,proto3" json:"FirstName,omitempty"`
	MiddleName  string `protobuf:"bytes,2,opt,name=MiddleName,proto3" json:"MiddleName,omitempty"`
	LastName    string `protobuf:"bytes,3,opt,name=LastName,proto3" json:"LastName,omitempty"`
	Birthdate   string `protobuf:"bytes,4,opt,name=Birthdate,proto3" json:"Birthdate,omitempty"`
	Citizenship string `protobuf:"bytes,5,opt,name=Citizenship,proto3" json:"Citizenship,omitempty"`
	Residency   string `protobuf:"bytes,6,opt,name=Residency,proto3" json:"Residency,omitempty"`
	Gender      string `protobuf:"bytes,7,opt,name=Gender,proto3" json:"Gender,omitempty"`
}

func (m *EncryptablePersonalInfoDetails) Reset()         { *m = EncryptablePersonalInfoDetails{} }
func (m *EncryptablePersonalInfoDetails) String() string { return proto.CompactTextString(m) }
func (*EncryptablePersonalInfoDetails) ProtoMessage()    {}
func (*EncryptablePersonalInfoDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef4cf267f6afd07c, []int{5}
}
func (m *EncryptablePersonalInfoDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptablePersonalInfoDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptablePersonalInfoDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptablePersonalInfoDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptablePersonalInfoDetails.Merge(m, src)
}
func (m *EncryptablePersonalInfoDetails) XXX_Size() int {
	return m.Size()
}
func (m *EncryptablePersonalInfoDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptablePersonalInfoDetails.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptablePersonalInfoDetails proto.InternalMessageInfo

func (m *EncryptablePersonalInfoDetails) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *EncryptablePersonalInfoDetails) GetMiddleName() string {
	if m != nil {
		return m.MiddleName
	}
	return ""
}

func (m *EncryptablePersonalInfoDetails) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *EncryptablePersonalInfoDetails) GetBirthdate() string {
	if m != nil {
		return m.Birthdate
	}
	return ""
}

func (m *EncryptablePersonalInfoDetails) GetCitizenship() string {
	if m != nil {
		return m.Citizenship
	}
	return ""
}

func (m *EncryptablePersonalInfoDetails) GetResidency() string {
	if m != nil {
		return m.Residency
	}
	return ""
}

func (m *EncryptablePersonalInfoDetails) GetGender() string {
	if m != nil {
		return m.Gender
	}
	return ""
}

type EncryptablePersonalInfo struct {
	Nonce   string                          `protobuf:"bytes,1,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	PIN     string                          `protobuf:"bytes,2,opt,name=PIN,proto3" json:"PIN,omitempty"`
	Details *EncryptablePersonalInfoDetails `protobuf:"bytes,3,opt,name=Details,proto3" json:"Details,omitempty"`
}

func (m *EncryptablePersonalInfo) Reset()         { *m = EncryptablePersonalInfo{} }
func (m *EncryptablePersonalInfo) String() string { return proto.CompactTextString(m) }
func (*EncryptablePersonalInfo) ProtoMessage()    {}
func (*EncryptablePersonalInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef4cf267f6afd07c, []int{6}
}
func (m *EncryptablePersonalInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptablePersonalInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptablePersonalInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptablePersonalInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptablePersonalInfo.Merge(m, src)
}
func (m *EncryptablePersonalInfo) XXX_Size() int {
	return m.Size()
}
func (m *EncryptablePersonalInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptablePersonalInfo.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptablePersonalInfo proto.InternalMessageInfo

func (m *EncryptablePersonalInfo) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *EncryptablePersonalInfo) GetPIN() string {
	if m != nil {
		return m.PIN
	}
	return ""
}

func (m *EncryptablePersonalInfo) GetDetails() *EncryptablePersonalInfoDetails {
	if m != nil {
		return m.Details
	}
	return nil
}

type EncryptableSingleContactInfoDetails struct {
	Contact string `protobuf:"bytes,1,opt,name=Contact,proto3" json:"Contact,omitempty"`
}

func (m *EncryptableSingleContactInfoDetails) Reset()         { *m = EncryptableSingleContactInfoDetails{} }
func (m *EncryptableSingleContactInfoDetails) String() string { return proto.CompactTextString(m) }
func (*EncryptableSingleContactInfoDetails) ProtoMessage()    {}
func (*EncryptableSingleContactInfoDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef4cf267f6afd07c, []int{7}
}
func (m *EncryptableSingleContactInfoDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptableSingleContactInfoDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptableSingleContactInfoDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptableSingleContactInfoDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptableSingleContactInfoDetails.Merge(m, src)
}
func (m *EncryptableSingleContactInfoDetails) XXX_Size() int {
	return m.Size()
}
func (m *EncryptableSingleContactInfoDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptableSingleContactInfoDetails.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptableSingleContactInfoDetails proto.InternalMessageInfo

func (m *EncryptableSingleContactInfoDetails) GetContact() string {
	if m != nil {
		return m.Contact
	}
	return ""
}

type EncryptableSingleContactInfo struct {
	Nonce   string                               `protobuf:"bytes,1,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	PIN     string                               `protobuf:"bytes,2,opt,name=PIN,proto3" json:"PIN,omitempty"`
	Details *EncryptableSingleContactInfoDetails `protobuf:"bytes,3,opt,name=Details,proto3" json:"Details,omitempty"`
}

func (m *EncryptableSingleContactInfo) Reset()         { *m = EncryptableSingleContactInfo{} }
func (m *EncryptableSingleContactInfo) String() string { return proto.CompactTextString(m) }
func (*EncryptableSingleContactInfo) ProtoMessage()    {}
func (*EncryptableSingleContactInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef4cf267f6afd07c, []int{8}
}
func (m *EncryptableSingleContactInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptableSingleContactInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptableSingleContactInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptableSingleContactInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptableSingleContactInfo.Merge(m, src)
}
func (m *EncryptableSingleContactInfo) XXX_Size() int {
	return m.Size()
}
func (m *EncryptableSingleContactInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptableSingleContactInfo.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptableSingleContactInfo proto.InternalMessageInfo

func (m *EncryptableSingleContactInfo) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *EncryptableSingleContactInfo) GetPIN() string {
	if m != nil {
		return m.PIN
	}
	return ""
}

func (m *EncryptableSingleContactInfo) GetDetails() *EncryptableSingleContactInfoDetails {
	if m != nil {
		return m.Details
	}
	return nil
}

type EncryptableValidatedCredential struct {
	CredentialType string           `protobuf:"bytes,1,opt,name=CredentialType,proto3" json:"CredentialType,omitempty"`
	PIN            string           `protobuf:"bytes,2,opt,name=PIN,proto3" json:"PIN,omitempty"`
	CredentialPC   *BPedersenCommit `protobuf:"bytes,3,opt,name=CredentialPC,proto3" json:"CredentialPC,omitempty"`
}

func (m *EncryptableValidatedCredential) Reset()         { *m = EncryptableValidatedCredential{} }
func (m *EncryptableValidatedCredential) String() string { return proto.CompactTextString(m) }
func (*EncryptableValidatedCredential) ProtoMessage()    {}
func (*EncryptableValidatedCredential) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef4cf267f6afd07c, []int{9}
}
func (m *EncryptableValidatedCredential) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptableValidatedCredential) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptableValidatedCredential.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptableValidatedCredential) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptableValidatedCredential.Merge(m, src)
}
func (m *EncryptableValidatedCredential) XXX_Size() int {
	return m.Size()
}
func (m *EncryptableValidatedCredential) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptableValidatedCredential.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptableValidatedCredential proto.InternalMessageInfo

func (m *EncryptableValidatedCredential) GetCredentialType() string {
	if m != nil {
		return m.CredentialType
	}
	return ""
}

func (m *EncryptableValidatedCredential) GetPIN() string {
	if m != nil {
		return m.PIN
	}
	return ""
}

func (m *EncryptableValidatedCredential) GetCredentialPC() *BPedersenCommit {
	if m != nil {
		return m.CredentialPC
	}
	return nil
}

type EncryptableValidatedCredentials struct {
	Credentials []*EncryptableValidatedCredential `protobuf:"bytes,1,rep,name=Credentials,proto3" json:"Credentials,omitempty"`
}

func (m *EncryptableValidatedCredentials) Reset()         { *m = EncryptableValidatedCredentials{} }
func (m *EncryptableValidatedCredentials) String() string { return proto.CompactTextString(m) }
func (*EncryptableValidatedCredentials) ProtoMessage()    {}
func (*EncryptableValidatedCredentials) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef4cf267f6afd07c, []int{10}
}
func (m *EncryptableValidatedCredentials) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptableValidatedCredentials) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptableValidatedCredentials.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptableValidatedCredentials) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptableValidatedCredentials.Merge(m, src)
}
func (m *EncryptableValidatedCredentials) XXX_Size() int {
	return m.Size()
}
func (m *EncryptableValidatedCredentials) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptableValidatedCredentials.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptableValidatedCredentials proto.InternalMessageInfo

func (m *EncryptableValidatedCredentials) GetCredentials() []*EncryptableValidatedCredential {
	if m != nil {
		return m.Credentials
	}
	return nil
}

type EncryptableCreateWalletEWalletIDExtraParms struct {
	ProofPC *BPedersenCommit `protobuf:"bytes,1,opt,name=ProofPC,proto3" json:"ProofPC,omitempty"`
}

func (m *EncryptableCreateWalletEWalletIDExtraParms) Reset() {
	*m = EncryptableCreateWalletEWalletIDExtraParms{}
}
func (m *EncryptableCreateWalletEWalletIDExtraParms) String() string {
	return proto.CompactTextString(m)
}
func (*EncryptableCreateWalletEWalletIDExtraParms) ProtoMessage() {}
func (*EncryptableCreateWalletEWalletIDExtraParms) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef4cf267f6afd07c, []int{11}
}
func (m *EncryptableCreateWalletEWalletIDExtraParms) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptableCreateWalletEWalletIDExtraParms) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptableCreateWalletEWalletIDExtraParms.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptableCreateWalletEWalletIDExtraParms) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptableCreateWalletEWalletIDExtraParms.Merge(m, src)
}
func (m *EncryptableCreateWalletEWalletIDExtraParms) XXX_Size() int {
	return m.Size()
}
func (m *EncryptableCreateWalletEWalletIDExtraParms) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptableCreateWalletEWalletIDExtraParms.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptableCreateWalletEWalletIDExtraParms proto.InternalMessageInfo

func (m *EncryptableCreateWalletEWalletIDExtraParms) GetProofPC() *BPedersenCommit {
	if m != nil {
		return m.ProofPC
	}
	return nil
}

type EncryptableCreateWalletEWalletID struct {
	Nonce      string                                      `protobuf:"bytes,1,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	WalletID   string                                      `protobuf:"bytes,2,opt,name=WalletID,proto3" json:"WalletID,omitempty"`
	ExtraParms *EncryptableCreateWalletEWalletIDExtraParms `protobuf:"bytes,3,opt,name=ExtraParms,proto3" json:"ExtraParms,omitempty"`
}

func (m *EncryptableCreateWalletEWalletID) Reset()         { *m = EncryptableCreateWalletEWalletID{} }
func (m *EncryptableCreateWalletEWalletID) String() string { return proto.CompactTextString(m) }
func (*EncryptableCreateWalletEWalletID) ProtoMessage()    {}
func (*EncryptableCreateWalletEWalletID) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef4cf267f6afd07c, []int{12}
}
func (m *EncryptableCreateWalletEWalletID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptableCreateWalletEWalletID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptableCreateWalletEWalletID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptableCreateWalletEWalletID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptableCreateWalletEWalletID.Merge(m, src)
}
func (m *EncryptableCreateWalletEWalletID) XXX_Size() int {
	return m.Size()
}
func (m *EncryptableCreateWalletEWalletID) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptableCreateWalletEWalletID.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptableCreateWalletEWalletID proto.InternalMessageInfo

func (m *EncryptableCreateWalletEWalletID) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *EncryptableCreateWalletEWalletID) GetWalletID() string {
	if m != nil {
		return m.WalletID
	}
	return ""
}

func (m *EncryptableCreateWalletEWalletID) GetExtraParms() *EncryptableCreateWalletEWalletIDExtraParms {
	if m != nil {
		return m.ExtraParms
	}
	return nil
}

type EncryptableCreateWallet struct {
	DstEWalletID *EncryptableCreateWalletEWalletID `protobuf:"bytes,1,opt,name=DstEWalletID,proto3" json:"DstEWalletID,omitempty"`
}

func (m *EncryptableCreateWallet) Reset()         { *m = EncryptableCreateWallet{} }
func (m *EncryptableCreateWallet) String() string { return proto.CompactTextString(m) }
func (*EncryptableCreateWallet) ProtoMessage()    {}
func (*EncryptableCreateWallet) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef4cf267f6afd07c, []int{13}
}
func (m *EncryptableCreateWallet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptableCreateWallet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptableCreateWallet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptableCreateWallet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptableCreateWallet.Merge(m, src)
}
func (m *EncryptableCreateWallet) XXX_Size() int {
	return m.Size()
}
func (m *EncryptableCreateWallet) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptableCreateWallet.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptableCreateWallet proto.InternalMessageInfo

func (m *EncryptableCreateWallet) GetDstEWalletID() *EncryptableCreateWalletEWalletID {
	if m != nil {
		return m.DstEWalletID
	}
	return nil
}

type EncryptableTransferFundsEWalletIDExtraParms struct {
	AcceptPasswordPC                *BPedersenCommit `protobuf:"bytes,1,opt,name=AcceptPasswordPC,proto3" json:"AcceptPasswordPC,omitempty"`
	MatchFirstNameHashHex           []byte           `protobuf:"bytes,2,opt,name=MatchFirstNameHashHex,proto3" json:"MatchFirstNameHashHex,omitempty"`
	MatchMiddleNameHashHex          []byte           `protobuf:"bytes,3,opt,name=MatchMiddleNameHashHex,proto3" json:"MatchMiddleNameHashHex,omitempty"`
	MatchLastNameHashHex            []byte           `protobuf:"bytes,4,opt,name=MatchLastNameHashHex,proto3" json:"MatchLastNameHashHex,omitempty"`
	RequiredSenderFirstNameCheckPC  *BPedersenCommit `protobuf:"bytes,5,opt,name=RequiredSenderFirstNameCheckPC,proto3" json:"RequiredSenderFirstNameCheckPC,omitempty"`
	RequiredSenderFirstNameProofPC  *BPedersenCommit `protobuf:"bytes,6,opt,name=RequiredSenderFirstNameProofPC,proto3" json:"RequiredSenderFirstNameProofPC,omitempty"`
	RequiredSenderMiddleNameCheckPC *BPedersenCommit `protobuf:"bytes,7,opt,name=RequiredSenderMiddleNameCheckPC,proto3" json:"RequiredSenderMiddleNameCheckPC,omitempty"`
	RequiredSenderMiddleNameProofPC *BPedersenCommit `protobuf:"bytes,8,opt,name=RequiredSenderMiddleNameProofPC,proto3" json:"RequiredSenderMiddleNameProofPC,omitempty"`
	RequiredSenderLastNameCheckPC   *BPedersenCommit `protobuf:"bytes,9,opt,name=RequiredSenderLastNameCheckPC,proto3" json:"RequiredSenderLastNameCheckPC,omitempty"`
	RequiredSenderLastNameProofPC   *BPedersenCommit `protobuf:"bytes,10,opt,name=RequiredSenderLastNameProofPC,proto3" json:"RequiredSenderLastNameProofPC,omitempty"`
}

func (m *EncryptableTransferFundsEWalletIDExtraParms) Reset() {
	*m = EncryptableTransferFundsEWalletIDExtraParms{}
}
func (m *EncryptableTransferFundsEWalletIDExtraParms) String() string {
	return proto.CompactTextString(m)
}
func (*EncryptableTransferFundsEWalletIDExtraParms) ProtoMessage() {}
func (*EncryptableTransferFundsEWalletIDExtraParms) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef4cf267f6afd07c, []int{14}
}
func (m *EncryptableTransferFundsEWalletIDExtraParms) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptableTransferFundsEWalletIDExtraParms) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptableTransferFundsEWalletIDExtraParms.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptableTransferFundsEWalletIDExtraParms) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptableTransferFundsEWalletIDExtraParms.Merge(m, src)
}
func (m *EncryptableTransferFundsEWalletIDExtraParms) XXX_Size() int {
	return m.Size()
}
func (m *EncryptableTransferFundsEWalletIDExtraParms) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptableTransferFundsEWalletIDExtraParms.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptableTransferFundsEWalletIDExtraParms proto.InternalMessageInfo

func (m *EncryptableTransferFundsEWalletIDExtraParms) GetAcceptPasswordPC() *BPedersenCommit {
	if m != nil {
		return m.AcceptPasswordPC
	}
	return nil
}

func (m *EncryptableTransferFundsEWalletIDExtraParms) GetMatchFirstNameHashHex() []byte {
	if m != nil {
		return m.MatchFirstNameHashHex
	}
	return nil
}

func (m *EncryptableTransferFundsEWalletIDExtraParms) GetMatchMiddleNameHashHex() []byte {
	if m != nil {
		return m.MatchMiddleNameHashHex
	}
	return nil
}

func (m *EncryptableTransferFundsEWalletIDExtraParms) GetMatchLastNameHashHex() []byte {
	if m != nil {
		return m.MatchLastNameHashHex
	}
	return nil
}

func (m *EncryptableTransferFundsEWalletIDExtraParms) GetRequiredSenderFirstNameCheckPC() *BPedersenCommit {
	if m != nil {
		return m.RequiredSenderFirstNameCheckPC
	}
	return nil
}

func (m *EncryptableTransferFundsEWalletIDExtraParms) GetRequiredSenderFirstNameProofPC() *BPedersenCommit {
	if m != nil {
		return m.RequiredSenderFirstNameProofPC
	}
	return nil
}

func (m *EncryptableTransferFundsEWalletIDExtraParms) GetRequiredSenderMiddleNameCheckPC() *BPedersenCommit {
	if m != nil {
		return m.RequiredSenderMiddleNameCheckPC
	}
	return nil
}

func (m *EncryptableTransferFundsEWalletIDExtraParms) GetRequiredSenderMiddleNameProofPC() *BPedersenCommit {
	if m != nil {
		return m.RequiredSenderMiddleNameProofPC
	}
	return nil
}

func (m *EncryptableTransferFundsEWalletIDExtraParms) GetRequiredSenderLastNameCheckPC() *BPedersenCommit {
	if m != nil {
		return m.RequiredSenderLastNameCheckPC
	}
	return nil
}

func (m *EncryptableTransferFundsEWalletIDExtraParms) GetRequiredSenderLastNameProofPC() *BPedersenCommit {
	if m != nil {
		return m.RequiredSenderLastNameProofPC
	}
	return nil
}

type EncryptableTransferFundsEWalletID struct {
	Nonce      string                                       `protobuf:"bytes,1,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	WalletID   string                                       `protobuf:"bytes,2,opt,name=WalletID,proto3" json:"WalletID,omitempty"`
	ExtraParms *EncryptableTransferFundsEWalletIDExtraParms `protobuf:"bytes,3,opt,name=ExtraParms,proto3" json:"ExtraParms,omitempty"`
}

func (m *EncryptableTransferFundsEWalletID) Reset()         { *m = EncryptableTransferFundsEWalletID{} }
func (m *EncryptableTransferFundsEWalletID) String() string { return proto.CompactTextString(m) }
func (*EncryptableTransferFundsEWalletID) ProtoMessage()    {}
func (*EncryptableTransferFundsEWalletID) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef4cf267f6afd07c, []int{15}
}
func (m *EncryptableTransferFundsEWalletID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptableTransferFundsEWalletID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptableTransferFundsEWalletID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptableTransferFundsEWalletID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptableTransferFundsEWalletID.Merge(m, src)
}
func (m *EncryptableTransferFundsEWalletID) XXX_Size() int {
	return m.Size()
}
func (m *EncryptableTransferFundsEWalletID) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptableTransferFundsEWalletID.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptableTransferFundsEWalletID proto.InternalMessageInfo

func (m *EncryptableTransferFundsEWalletID) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *EncryptableTransferFundsEWalletID) GetWalletID() string {
	if m != nil {
		return m.WalletID
	}
	return ""
}

func (m *EncryptableTransferFundsEWalletID) GetExtraParms() *EncryptableTransferFundsEWalletIDExtraParms {
	if m != nil {
		return m.ExtraParms
	}
	return nil
}

type EncryptableTransferFunds struct {
	HiddenTransferPC *EncryptablePedersenCommit         `protobuf:"bytes,1,opt,name=HiddenTransferPC,proto3" json:"HiddenTransferPC,omitempty"`
	DstEWalletID     *EncryptableTransferFundsEWalletID `protobuf:"bytes,2,opt,name=DstEWalletID,proto3" json:"DstEWalletID,omitempty"`
	OptInReason      string                             `protobuf:"bytes,3,opt,name=OptInReason,proto3" json:"OptInReason,omitempty"`
}

func (m *EncryptableTransferFunds) Reset()         { *m = EncryptableTransferFunds{} }
func (m *EncryptableTransferFunds) String() string { return proto.CompactTextString(m) }
func (*EncryptableTransferFunds) ProtoMessage()    {}
func (*EncryptableTransferFunds) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef4cf267f6afd07c, []int{16}
}
func (m *EncryptableTransferFunds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptableTransferFunds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptableTransferFunds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptableTransferFunds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptableTransferFunds.Merge(m, src)
}
func (m *EncryptableTransferFunds) XXX_Size() int {
	return m.Size()
}
func (m *EncryptableTransferFunds) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptableTransferFunds.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptableTransferFunds proto.InternalMessageInfo

func (m *EncryptableTransferFunds) GetHiddenTransferPC() *EncryptablePedersenCommit {
	if m != nil {
		return m.HiddenTransferPC
	}
	return nil
}

func (m *EncryptableTransferFunds) GetDstEWalletID() *EncryptableTransferFundsEWalletID {
	if m != nil {
		return m.DstEWalletID
	}
	return nil
}

func (m *EncryptableTransferFunds) GetOptInReason() string {
	if m != nil {
		return m.OptInReason
	}
	return ""
}

type EncryptableReceiveFundsEWalletIDExtraParms struct {
	Queue string `protobuf:"bytes,1,opt,name=Queue,proto3" json:"Queue,omitempty"`
}

func (m *EncryptableReceiveFundsEWalletIDExtraParms) Reset() {
	*m = EncryptableReceiveFundsEWalletIDExtraParms{}
}
func (m *EncryptableReceiveFundsEWalletIDExtraParms) String() string {
	return proto.CompactTextString(m)
}
func (*EncryptableReceiveFundsEWalletIDExtraParms) ProtoMessage() {}
func (*EncryptableReceiveFundsEWalletIDExtraParms) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef4cf267f6afd07c, []int{17}
}
func (m *EncryptableReceiveFundsEWalletIDExtraParms) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptableReceiveFundsEWalletIDExtraParms) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptableReceiveFundsEWalletIDExtraParms.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptableReceiveFundsEWalletIDExtraParms) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptableReceiveFundsEWalletIDExtraParms.Merge(m, src)
}
func (m *EncryptableReceiveFundsEWalletIDExtraParms) XXX_Size() int {
	return m.Size()
}
func (m *EncryptableReceiveFundsEWalletIDExtraParms) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptableReceiveFundsEWalletIDExtraParms.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptableReceiveFundsEWalletIDExtraParms proto.InternalMessageInfo

func (m *EncryptableReceiveFundsEWalletIDExtraParms) GetQueue() string {
	if m != nil {
		return m.Queue
	}
	return ""
}

type EncryptableReceiveFundsEWalletID struct {
	Nonce      string                                      `protobuf:"bytes,1,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	WalletID   string                                      `protobuf:"bytes,2,opt,name=WalletID,proto3" json:"WalletID,omitempty"`
	ExtraParms *EncryptableReceiveFundsEWalletIDExtraParms `protobuf:"bytes,3,opt,name=ExtraParms,proto3" json:"ExtraParms,omitempty"`
}

func (m *EncryptableReceiveFundsEWalletID) Reset()         { *m = EncryptableReceiveFundsEWalletID{} }
func (m *EncryptableReceiveFundsEWalletID) String() string { return proto.CompactTextString(m) }
func (*EncryptableReceiveFundsEWalletID) ProtoMessage()    {}
func (*EncryptableReceiveFundsEWalletID) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef4cf267f6afd07c, []int{18}
}
func (m *EncryptableReceiveFundsEWalletID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptableReceiveFundsEWalletID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptableReceiveFundsEWalletID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptableReceiveFundsEWalletID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptableReceiveFundsEWalletID.Merge(m, src)
}
func (m *EncryptableReceiveFundsEWalletID) XXX_Size() int {
	return m.Size()
}
func (m *EncryptableReceiveFundsEWalletID) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptableReceiveFundsEWalletID.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptableReceiveFundsEWalletID proto.InternalMessageInfo

func (m *EncryptableReceiveFundsEWalletID) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *EncryptableReceiveFundsEWalletID) GetWalletID() string {
	if m != nil {
		return m.WalletID
	}
	return ""
}

func (m *EncryptableReceiveFundsEWalletID) GetExtraParms() *EncryptableReceiveFundsEWalletIDExtraParms {
	if m != nil {
		return m.ExtraParms
	}
	return nil
}

type EncryptableSignRecoverKeyEWalletID struct {
	Nonce    string `protobuf:"bytes,1,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	WalletID string `protobuf:"bytes,2,opt,name=WalletID,proto3" json:"WalletID,omitempty"`
}

func (m *EncryptableSignRecoverKeyEWalletID) Reset()         { *m = EncryptableSignRecoverKeyEWalletID{} }
func (m *EncryptableSignRecoverKeyEWalletID) String() string { return proto.CompactTextString(m) }
func (*EncryptableSignRecoverKeyEWalletID) ProtoMessage()    {}
func (*EncryptableSignRecoverKeyEWalletID) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef4cf267f6afd07c, []int{19}
}
func (m *EncryptableSignRecoverKeyEWalletID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptableSignRecoverKeyEWalletID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptableSignRecoverKeyEWalletID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptableSignRecoverKeyEWalletID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptableSignRecoverKeyEWalletID.Merge(m, src)
}
func (m *EncryptableSignRecoverKeyEWalletID) XXX_Size() int {
	return m.Size()
}
func (m *EncryptableSignRecoverKeyEWalletID) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptableSignRecoverKeyEWalletID.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptableSignRecoverKeyEWalletID proto.InternalMessageInfo

func (m *EncryptableSignRecoverKeyEWalletID) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *EncryptableSignRecoverKeyEWalletID) GetWalletID() string {
	if m != nil {
		return m.WalletID
	}
	return ""
}

type EncryptableReceiveFunds struct {
	EphEWalletID *EncryptableReceiveFundsEWalletID `protobuf:"bytes,1,opt,name=EphEWalletID,proto3" json:"EphEWalletID,omitempty"`
}

func (m *EncryptableReceiveFunds) Reset()         { *m = EncryptableReceiveFunds{} }
func (m *EncryptableReceiveFunds) String() string { return proto.CompactTextString(m) }
func (*EncryptableReceiveFunds) ProtoMessage()    {}
func (*EncryptableReceiveFunds) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef4cf267f6afd07c, []int{20}
}
func (m *EncryptableReceiveFunds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptableReceiveFunds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptableReceiveFunds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptableReceiveFunds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptableReceiveFunds.Merge(m, src)
}
func (m *EncryptableReceiveFunds) XXX_Size() int {
	return m.Size()
}
func (m *EncryptableReceiveFunds) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptableReceiveFunds.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptableReceiveFunds proto.InternalMessageInfo

func (m *EncryptableReceiveFunds) GetEphEWalletID() *EncryptableReceiveFundsEWalletID {
	if m != nil {
		return m.EphEWalletID
	}
	return nil
}

type EncryptableAnonTransferFunds struct {
	TotalTransferPrimePC  *EncryptablePedersenCommit `protobuf:"bytes,1,opt,name=TotalTransferPrimePC,proto3" json:"TotalTransferPrimePC,omitempty"`
	TransparentTransferBF *BInt                      `protobuf:"bytes,2,opt,name=TransparentTransferBF,proto3" json:"TransparentTransferBF,omitempty"`
}

func (m *EncryptableAnonTransferFunds) Reset()         { *m = EncryptableAnonTransferFunds{} }
func (m *EncryptableAnonTransferFunds) String() string { return proto.CompactTextString(m) }
func (*EncryptableAnonTransferFunds) ProtoMessage()    {}
func (*EncryptableAnonTransferFunds) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef4cf267f6afd07c, []int{21}
}
func (m *EncryptableAnonTransferFunds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptableAnonTransferFunds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptableAnonTransferFunds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptableAnonTransferFunds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptableAnonTransferFunds.Merge(m, src)
}
func (m *EncryptableAnonTransferFunds) XXX_Size() int {
	return m.Size()
}
func (m *EncryptableAnonTransferFunds) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptableAnonTransferFunds.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptableAnonTransferFunds proto.InternalMessageInfo

func (m *EncryptableAnonTransferFunds) GetTotalTransferPrimePC() *EncryptablePedersenCommit {
	if m != nil {
		return m.TotalTransferPrimePC
	}
	return nil
}

func (m *EncryptableAnonTransferFunds) GetTransparentTransferBF() *BInt {
	if m != nil {
		return m.TransparentTransferBF
	}
	return nil
}

type EncryptableESuspiciousAmount struct {
	Nonce         string      `protobuf:"bytes,1,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	USDCoinAmount *types.Coin `protobuf:"bytes,2,opt,name=USDCoinAmount,proto3" json:"USDCoinAmount,omitempty"`
	CoinAmount    *types.Coin `protobuf:"bytes,3,opt,name=CoinAmount,proto3" json:"CoinAmount,omitempty"`
}

func (m *EncryptableESuspiciousAmount) Reset()         { *m = EncryptableESuspiciousAmount{} }
func (m *EncryptableESuspiciousAmount) String() string { return proto.CompactTextString(m) }
func (*EncryptableESuspiciousAmount) ProtoMessage()    {}
func (*EncryptableESuspiciousAmount) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef4cf267f6afd07c, []int{22}
}
func (m *EncryptableESuspiciousAmount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptableESuspiciousAmount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptableESuspiciousAmount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptableESuspiciousAmount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptableESuspiciousAmount.Merge(m, src)
}
func (m *EncryptableESuspiciousAmount) XXX_Size() int {
	return m.Size()
}
func (m *EncryptableESuspiciousAmount) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptableESuspiciousAmount.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptableESuspiciousAmount proto.InternalMessageInfo

func (m *EncryptableESuspiciousAmount) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *EncryptableESuspiciousAmount) GetUSDCoinAmount() *types.Coin {
	if m != nil {
		return m.USDCoinAmount
	}
	return nil
}

func (m *EncryptableESuspiciousAmount) GetCoinAmount() *types.Coin {
	if m != nil {
		return m.CoinAmount
	}
	return nil
}

type EncryptableSSIDAndPrivK struct {
	PubKID string `protobuf:"bytes,1,opt,name=PubKID,proto3" json:"PubKID,omitempty"`
	PubK   string `protobuf:"bytes,2,opt,name=PubK,proto3" json:"PubK,omitempty"`
	PrivK  string `protobuf:"bytes,3,opt,name=PrivK,proto3" json:"PrivK,omitempty"`
}

func (m *EncryptableSSIDAndPrivK) Reset()         { *m = EncryptableSSIDAndPrivK{} }
func (m *EncryptableSSIDAndPrivK) String() string { return proto.CompactTextString(m) }
func (*EncryptableSSIDAndPrivK) ProtoMessage()    {}
func (*EncryptableSSIDAndPrivK) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef4cf267f6afd07c, []int{23}
}
func (m *EncryptableSSIDAndPrivK) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptableSSIDAndPrivK) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptableSSIDAndPrivK.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptableSSIDAndPrivK) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptableSSIDAndPrivK.Merge(m, src)
}
func (m *EncryptableSSIDAndPrivK) XXX_Size() int {
	return m.Size()
}
func (m *EncryptableSSIDAndPrivK) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptableSSIDAndPrivK.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptableSSIDAndPrivK proto.InternalMessageInfo

func (m *EncryptableSSIDAndPrivK) GetPubKID() string {
	if m != nil {
		return m.PubKID
	}
	return ""
}

func (m *EncryptableSSIDAndPrivK) GetPubK() string {
	if m != nil {
		return m.PubK
	}
	return ""
}

func (m *EncryptableSSIDAndPrivK) GetPrivK() string {
	if m != nil {
		return m.PrivK
	}
	return ""
}

type EncryptablePioneerIDs struct {
	PioneerIDs []string `protobuf:"bytes,1,rep,name=PioneerIDs,proto3" json:"PioneerIDs,omitempty"`
}

func (m *EncryptablePioneerIDs) Reset()         { *m = EncryptablePioneerIDs{} }
func (m *EncryptablePioneerIDs) String() string { return proto.CompactTextString(m) }
func (*EncryptablePioneerIDs) ProtoMessage()    {}
func (*EncryptablePioneerIDs) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef4cf267f6afd07c, []int{24}
}
func (m *EncryptablePioneerIDs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptablePioneerIDs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptablePioneerIDs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptablePioneerIDs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptablePioneerIDs.Merge(m, src)
}
func (m *EncryptablePioneerIDs) XXX_Size() int {
	return m.Size()
}
func (m *EncryptablePioneerIDs) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptablePioneerIDs.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptablePioneerIDs proto.InternalMessageInfo

func (m *EncryptablePioneerIDs) GetPioneerIDs() []string {
	if m != nil {
		return m.PioneerIDs
	}
	return nil
}

type EncryptableEnclaveSSOwnerMap struct {
	Pioneers map[string]*EncryptablePioneerIDs `protobuf:"bytes,1,rep,name=Pioneers,proto3" json:"Pioneers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *EncryptableEnclaveSSOwnerMap) Reset()         { *m = EncryptableEnclaveSSOwnerMap{} }
func (m *EncryptableEnclaveSSOwnerMap) String() string { return proto.CompactTextString(m) }
func (*EncryptableEnclaveSSOwnerMap) ProtoMessage()    {}
func (*EncryptableEnclaveSSOwnerMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef4cf267f6afd07c, []int{25}
}
func (m *EncryptableEnclaveSSOwnerMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptableEnclaveSSOwnerMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptableEnclaveSSOwnerMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptableEnclaveSSOwnerMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptableEnclaveSSOwnerMap.Merge(m, src)
}
func (m *EncryptableEnclaveSSOwnerMap) XXX_Size() int {
	return m.Size()
}
func (m *EncryptableEnclaveSSOwnerMap) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptableEnclaveSSOwnerMap.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptableEnclaveSSOwnerMap proto.InternalMessageInfo

func (m *EncryptableEnclaveSSOwnerMap) GetPioneers() map[string]*EncryptablePioneerIDs {
	if m != nil {
		return m.Pioneers
	}
	return nil
}

type EncryptableEnclavePubKCacheMap struct {
	PubKs map[string]string `protobuf:"bytes,1,rep,name=PubKs,proto3" json:"PubKs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *EncryptableEnclavePubKCacheMap) Reset()         { *m = EncryptableEnclavePubKCacheMap{} }
func (m *EncryptableEnclavePubKCacheMap) String() string { return proto.CompactTextString(m) }
func (*EncryptableEnclavePubKCacheMap) ProtoMessage()    {}
func (*EncryptableEnclavePubKCacheMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef4cf267f6afd07c, []int{26}
}
func (m *EncryptableEnclavePubKCacheMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptableEnclavePubKCacheMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptableEnclavePubKCacheMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptableEnclavePubKCacheMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptableEnclavePubKCacheMap.Merge(m, src)
}
func (m *EncryptableEnclavePubKCacheMap) XXX_Size() int {
	return m.Size()
}
func (m *EncryptableEnclavePubKCacheMap) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptableEnclavePubKCacheMap.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptableEnclavePubKCacheMap proto.InternalMessageInfo

func (m *EncryptableEnclavePubKCacheMap) GetPubKs() map[string]string {
	if m != nil {
		return m.PubKs
	}
	return nil
}

type EncryptableSharedEnclaveParams struct {
	JarID               string `protobuf:"bytes,1,opt,name=JarID,proto3" json:"JarID,omitempty"`
	JarArmorPrivK       string `protobuf:"bytes,2,opt,name=JarArmorPrivK,proto3" json:"JarArmorPrivK,omitempty"`
	JarPrivK            string `protobuf:"bytes,3,opt,name=JarPrivK,proto3" json:"JarPrivK,omitempty"`
	JarPubK             string `protobuf:"bytes,4,opt,name=JarPubK,proto3" json:"JarPubK,omitempty"`
	RegulatorID         string `protobuf:"bytes,5,opt,name=RegulatorID,proto3" json:"RegulatorID,omitempty"`
	RegulatorArmorPrivK string `protobuf:"bytes,6,opt,name=RegulatorArmorPrivK,proto3" json:"RegulatorArmorPrivK,omitempty"`
	RegulatorPrivK      string `protobuf:"bytes,7,opt,name=RegulatorPrivK,proto3" json:"RegulatorPrivK,omitempty"`
	RegulatorPubK       string `protobuf:"bytes,8,opt,name=RegulatorPubK,proto3" json:"RegulatorPubK,omitempty"`
	// these only used temporarily to sync data from enclave to enclave
	SSIntervalOwners    *EncryptableEnclaveSSOwnerMap   `protobuf:"bytes,9,opt,name=SSIntervalOwners,proto3" json:"SSIntervalOwners,omitempty"`
	SSIntervalPubKCache *EncryptableEnclavePubKCacheMap `protobuf:"bytes,10,opt,name=SSIntervalPubKCache,proto3" json:"SSIntervalPubKCache,omitempty"`
}

func (m *EncryptableSharedEnclaveParams) Reset()         { *m = EncryptableSharedEnclaveParams{} }
func (m *EncryptableSharedEnclaveParams) String() string { return proto.CompactTextString(m) }
func (*EncryptableSharedEnclaveParams) ProtoMessage()    {}
func (*EncryptableSharedEnclaveParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef4cf267f6afd07c, []int{27}
}
func (m *EncryptableSharedEnclaveParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptableSharedEnclaveParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptableSharedEnclaveParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptableSharedEnclaveParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptableSharedEnclaveParams.Merge(m, src)
}
func (m *EncryptableSharedEnclaveParams) XXX_Size() int {
	return m.Size()
}
func (m *EncryptableSharedEnclaveParams) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptableSharedEnclaveParams.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptableSharedEnclaveParams proto.InternalMessageInfo

func (m *EncryptableSharedEnclaveParams) GetJarID() string {
	if m != nil {
		return m.JarID
	}
	return ""
}

func (m *EncryptableSharedEnclaveParams) GetJarArmorPrivK() string {
	if m != nil {
		return m.JarArmorPrivK
	}
	return ""
}

func (m *EncryptableSharedEnclaveParams) GetJarPrivK() string {
	if m != nil {
		return m.JarPrivK
	}
	return ""
}

func (m *EncryptableSharedEnclaveParams) GetJarPubK() string {
	if m != nil {
		return m.JarPubK
	}
	return ""
}

func (m *EncryptableSharedEnclaveParams) GetRegulatorID() string {
	if m != nil {
		return m.RegulatorID
	}
	return ""
}

func (m *EncryptableSharedEnclaveParams) GetRegulatorArmorPrivK() string {
	if m != nil {
		return m.RegulatorArmorPrivK
	}
	return ""
}

func (m *EncryptableSharedEnclaveParams) GetRegulatorPrivK() string {
	if m != nil {
		return m.RegulatorPrivK
	}
	return ""
}

func (m *EncryptableSharedEnclaveParams) GetRegulatorPubK() string {
	if m != nil {
		return m.RegulatorPubK
	}
	return ""
}

func (m *EncryptableSharedEnclaveParams) GetSSIntervalOwners() *EncryptableEnclaveSSOwnerMap {
	if m != nil {
		return m.SSIntervalOwners
	}
	return nil
}

func (m *EncryptableSharedEnclaveParams) GetSSIntervalPubKCache() *EncryptableEnclavePubKCacheMap {
	if m != nil {
		return m.SSIntervalPubKCache
	}
	return nil
}

func init() {
	proto.RegisterType((*EncryptableString)(nil), "qadena.qadena.EncryptableString")
	proto.RegisterType((*EncryptableClaimCredentialExtraParms)(nil), "qadena.qadena.EncryptableClaimCredentialExtraParms")
	proto.RegisterType((*EncryptableAuthorizedSignatory)(nil), "qadena.qadena.EncryptableAuthorizedSignatory")
	proto.RegisterType((*EncryptableSignatory)(nil), "qadena.qadena.EncryptableSignatory")
	proto.RegisterType((*EncryptableWalletAmount)(nil), "qadena.qadena.EncryptableWalletAmount")
	proto.RegisterType((*EncryptablePersonalInfoDetails)(nil), "qadena.qadena.EncryptablePersonalInfoDetails")
	proto.RegisterType((*EncryptablePersonalInfo)(nil), "qadena.qadena.EncryptablePersonalInfo")
	proto.RegisterType((*EncryptableSingleContactInfoDetails)(nil), "qadena.qadena.EncryptableSingleContactInfoDetails")
	proto.RegisterType((*EncryptableSingleContactInfo)(nil), "qadena.qadena.EncryptableSingleContactInfo")
	proto.RegisterType((*EncryptableValidatedCredential)(nil), "qadena.qadena.EncryptableValidatedCredential")
	proto.RegisterType((*EncryptableValidatedCredentials)(nil), "qadena.qadena.EncryptableValidatedCredentials")
	proto.RegisterType((*EncryptableCreateWalletEWalletIDExtraParms)(nil), "qadena.qadena.EncryptableCreateWalletEWalletIDExtraParms")
	proto.RegisterType((*EncryptableCreateWalletEWalletID)(nil), "qadena.qadena.EncryptableCreateWalletEWalletID")
	proto.RegisterType((*EncryptableCreateWallet)(nil), "qadena.qadena.EncryptableCreateWallet")
	proto.RegisterType((*EncryptableTransferFundsEWalletIDExtraParms)(nil), "qadena.qadena.EncryptableTransferFundsEWalletIDExtraParms")
	proto.RegisterType((*EncryptableTransferFundsEWalletID)(nil), "qadena.qadena.EncryptableTransferFundsEWalletID")
	proto.RegisterType((*EncryptableTransferFunds)(nil), "qadena.qadena.EncryptableTransferFunds")
	proto.RegisterType((*EncryptableReceiveFundsEWalletIDExtraParms)(nil), "qadena.qadena.EncryptableReceiveFundsEWalletIDExtraParms")
	proto.RegisterType((*EncryptableReceiveFundsEWalletID)(nil), "qadena.qadena.EncryptableReceiveFundsEWalletID")
	proto.RegisterType((*EncryptableSignRecoverKeyEWalletID)(nil), "qadena.qadena.EncryptableSignRecoverKeyEWalletID")
	proto.RegisterType((*EncryptableReceiveFunds)(nil), "qadena.qadena.EncryptableReceiveFunds")
	proto.RegisterType((*EncryptableAnonTransferFunds)(nil), "qadena.qadena.EncryptableAnonTransferFunds")
	proto.RegisterType((*EncryptableESuspiciousAmount)(nil), "qadena.qadena.EncryptableESuspiciousAmount")
	proto.RegisterType((*EncryptableSSIDAndPrivK)(nil), "qadena.qadena.EncryptableSSIDAndPrivK")
	proto.RegisterType((*EncryptablePioneerIDs)(nil), "qadena.qadena.EncryptablePioneerIDs")
	proto.RegisterType((*EncryptableEnclaveSSOwnerMap)(nil), "qadena.qadena.EncryptableEnclaveSSOwnerMap")
	proto.RegisterMapType((map[string]*EncryptablePioneerIDs)(nil), "qadena.qadena.EncryptableEnclaveSSOwnerMap.PioneersEntry")
	proto.RegisterType((*EncryptableEnclavePubKCacheMap)(nil), "qadena.qadena.EncryptableEnclavePubKCacheMap")
	proto.RegisterMapType((map[string]string)(nil), "qadena.qadena.EncryptableEnclavePubKCacheMap.PubKsEntry")
	proto.RegisterType((*EncryptableSharedEnclaveParams)(nil), "qadena.qadena.EncryptableSharedEnclaveParams")
}

func init() { proto.RegisterFile("qadena/qadena/encryptable.proto", fileDescriptor_ef4cf267f6afd07c) }

var fileDescriptor_ef4cf267f6afd07c = []byte{
	// 1834 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x18, 0x4b, 0x73, 0x1b, 0xb7,
	0xd9, 0xb4, 0xac, 0x07, 0x3f, 0x5b, 0xa9, 0x02, 0xcb, 0x09, 0xad, 0x89, 0x69, 0x65, 0xe3, 0xb6,
	0x6e, 0xd2, 0x88, 0xb1, 0xdb, 0x69, 0x15, 0x5f, 0x52, 0x89, 0x92, 0x63, 0xca, 0xb1, 0xcc, 0x2e,
	0x15, 0x67, 0xe2, 0x76, 0x86, 0x03, 0xee, 0x42, 0x24, 0xc6, 0x4b, 0x80, 0xc1, 0x82, 0xb4, 0x95,
	0x9f, 0xd0, 0x5e, 0x7a, 0xe8, 0x4c, 0x6f, 0xfd, 0x01, 0xbd, 0xb4, 0xfd, 0x15, 0xed, 0x31, 0xc7,
	0x1c, 0x3b, 0xf6, 0xa5, 0xa7, 0x4e, 0xef, 0xbd, 0x74, 0x80, 0xc5, 0x3e, 0xb0, 0xdc, 0x25, 0xa9,
	0x78, 0x72, 0x21, 0xf7, 0x7b, 0x3f, 0xf1, 0xe1, 0x01, 0x37, 0xbf, 0xc2, 0x3e, 0x61, 0xb8, 0x61,
	0xfe, 0x08, 0xf3, 0xc4, 0xd9, 0x48, 0xe2, 0x5e, 0x40, 0x76, 0x46, 0x82, 0x4b, 0x8e, 0xd6, 0x23,
	0xca, 0x4e, 0xf4, 0xb7, 0xf5, 0x26, 0x1e, 0x52, 0xc6, 0x1b, 0xfa, 0x37, 0xe2, 0xd8, 0x7a, 0xdb,
	0xe3, 0xe1, 0x90, 0x87, 0x8d, 0x61, 0xd8, 0x6f, 0x4c, 0xee, 0xa8, 0x3f, 0x43, 0xb8, 0x1e, 0x11,
	0xba, 0x1a, 0x6a, 0x44, 0x80, 0x21, 0xd5, 0x8d, 0x4c, 0x0f, 0x87, 0xa4, 0x31, 0xb9, 0xd3, 0x23,
	0x12, 0xdf, 0x69, 0x78, 0x9c, 0x32, 0x43, 0xdf, 0xec, 0xf3, 0x3e, 0x8f, 0xe4, 0xd4, 0x97, 0xc1,
	0x6e, 0xd9, 0xce, 0x8e, 0xb0, 0xc0, 0xc3, 0x58, 0xe3, 0xfb, 0x36, 0x2d, 0x1c, 0x87, 0x23, 0xea,
	0x51, 0x3e, 0x0e, 0xbb, 0x52, 0x60, 0x16, 0x62, 0x4f, 0x52, 0x1e, 0x6b, 0x7f, 0x2f, 0xa7, 0x87,
	0xf8, 0x44, 0x84, 0x84, 0x75, 0x3d, 0x3e, 0x1c, 0x52, 0x69, 0x98, 0x6e, 0xd8, 0x4c, 0x3d, 0xca,
	0xfc, 0xae, 0x8f, 0x25, 0x36, 0xe4, 0x5c, 0xe2, 0x04, 0x66, 0x7d, 0xa2, 0x22, 0xe5, 0xa7, 0x86,
	0xe1, 0x87, 0x39, 0xf9, 0x6e, 0xb1, 0x99, 0x1c, 0xdb, 0xa4, 0x1b, 0x0e, 0xb0, 0x20, 0xdd, 0xbc,
	0xb9, 0xeb, 0xb9, 0xf0, 0x14, 0x93, 0x21, 0xfd, 0x38, 0x47, 0x22, 0x9e, 0x20, 0xd2, 0xa8, 0x19,
	0x09, 0x3a, 0xe9, 0x3e, 0x33, 0x8c, 0xef, 0xe6, 0x5c, 0x26, 0x1e, 0x9f, 0x10, 0xd1, 0xcd, 0xea,
	0xca, 0x65, 0xa6, 0x37, 0x0e, 0x9e, 0x75, 0x3d, 0x41, 0x7c, 0xc2, 0x24, 0xc5, 0x41, 0x71, 0x19,
	0x7a, 0xb4, 0x4f, 0x59, 0x1c, 0xce, 0xcd, 0x3e, 0xe7, 0xfd, 0x80, 0x34, 0x34, 0xd4, 0x1b, 0x9f,
	0x36, 0x24, 0x1d, 0x92, 0x50, 0xe2, 0xe1, 0x28, 0x62, 0x70, 0x7e, 0x02, 0x6f, 0x1e, 0xa6, 0x4d,
	0xd6, 0x91, 0x82, 0xb2, 0x3e, 0xda, 0x84, 0xe5, 0x27, 0x38, 0x18, 0x93, 0x5a, 0x65, 0xbb, 0x72,
	0xbb, 0xea, 0x46, 0x80, 0xf3, 0xbf, 0x65, 0xb8, 0x95, 0xe1, 0x6d, 0x06, 0x98, 0x0e, 0x9b, 0x89,
	0x33, 0x87, 0x2f, 0xa4, 0xc0, 0x6d, 0x2c, 0x86, 0x21, 0xda, 0x85, 0xb7, 0x0f, 0x99, 0x97, 0x92,
	0x5a, 0xec, 0x94, 0x3f, 0xe9, 0xa8, 0xb0, 0xb4, 0xc2, 0x2b, 0x6e, 0x19, 0x19, 0x7d, 0x09, 0xb5,
	0x22, 0xfc, 0x3e, 0x65, 0x7e, 0xed, 0xe2, 0x76, 0xe5, 0xf6, 0xe5, 0xbb, 0x37, 0x76, 0xac, 0x05,
	0xb0, 0x93, 0x32, 0x1c, 0x60, 0x89, 0xdd, 0x52, 0x71, 0xb4, 0x05, 0x6b, 0x5f, 0xe0, 0x20, 0x20,
	0xb2, 0x75, 0x50, 0x5b, 0xd2, 0x61, 0x25, 0x30, 0x3a, 0x82, 0x8d, 0xfb, 0x94, 0xf9, 0xa9, 0x6c,
	0xbb, 0x59, 0xbb, 0xa4, 0xcd, 0xd5, 0x73, 0xe6, 0xf6, 0xdb, 0xa6, 0x6b, 0x9a, 0xba, 0x69, 0xdc,
	0x29, 0x39, 0xf4, 0x00, 0x7e, 0x70, 0x4c, 0x9e, 0x5b, 0xaa, 0x96, 0x17, 0x52, 0x95, 0x17, 0x43,
	0x3f, 0xd5, 0xa5, 0x89, 0x9d, 0x34, 0x09, 0x5c, 0xd1, 0x09, 0x9c, 0x26, 0xa0, 0x47, 0x80, 0x6c,
	0x8c, 0x4e, 0xda, 0xea, 0x22, 0x49, 0x2b, 0x10, 0x9c, 0xaa, 0xe1, 0x03, 0x1c, 0x0e, 0x8c, 0x0b,
	0x6b, 0x05, 0x35, 0x4c, 0xc9, 0x76, 0x0d, 0x53, 0xbc, 0x76, 0xa7, 0x7a, 0xce, 0x1a, 0xda, 0xe2,
	0xe8, 0x57, 0xb0, 0xf2, 0x94, 0x08, 0xde, 0x6e, 0xd6, 0x40, 0x2b, 0xba, 0x9d, 0x53, 0x94, 0xe9,
	0xce, 0x5c, 0x72, 0x8d, 0x1c, 0xda, 0x85, 0x55, 0xdd, 0xb7, 0xed, 0x66, 0xed, 0xf2, 0x42, 0x55,
	0x89, 0xd9, 0x1d, 0x17, 0xea, 0x19, 0xf5, 0x7b, 0x63, 0x39, 0xe0, 0x82, 0x7e, 0x4d, 0xfc, 0x0e,
	0xed, 0x33, 0x2c, 0xb9, 0x38, 0x53, 0xab, 0xe6, 0x98, 0x33, 0x2f, 0x59, 0x35, 0x1a, 0xb0, 0xfa,
	0xee, 0xa2, 0xdd, 0x77, 0x8e, 0x0f, 0x9b, 0xd9, 0xc5, 0x37, 0x47, 0xd3, 0x26, 0x2c, 0x1f, 0x0e,
	0x31, 0x0d, 0x8c, 0x9a, 0x08, 0x40, 0xdb, 0x70, 0xb9, 0x3d, 0xe0, 0x8c, 0x1c, 0x8f, 0x87, 0x3d,
	0x22, 0x4c, 0x6b, 0x67, 0x51, 0xce, 0x9f, 0x96, 0x74, 0x2d, 0x63, 0x33, 0x91, 0xf5, 0xbd, 0x21,
	0x1f, 0x33, 0x59, 0x62, 0xe9, 0x16, 0xac, 0x9f, 0xa4, 0x53, 0x3a, 0x71, 0xdc, 0x46, 0xa2, 0x36,
	0xbc, 0x61, 0x27, 0x4b, 0x1b, 0x3f, 0x4f, 0x55, 0x72, 0xf2, 0x08, 0xc1, 0xa5, 0x63, 0x2e, 0x89,
	0x5e, 0x7b, 0x55, 0x57, 0x7f, 0xab, 0x55, 0xe0, 0x92, 0xaf, 0xc6, 0x54, 0x10, 0xbf, 0x43, 0x98,
	0x4f, 0x44, 0xbb, 0x75, 0xac, 0x57, 0x54, 0xd5, 0x9d, 0x26, 0xa8, 0xb6, 0xb5, 0x91, 0xf7, 0xa9,
	0x08, 0xe5, 0x31, 0x1e, 0x46, 0x2b, 0xa7, 0xea, 0x96, 0x91, 0xd1, 0x3d, 0xa8, 0xd9, 0xa4, 0x47,
	0xd4, 0xf7, 0x03, 0xa2, 0x45, 0x57, 0xb5, 0x68, 0x29, 0x1d, 0xfd, 0x02, 0xde, 0xb2, 0x69, 0x9f,
	0x61, 0x63, 0x74, 0x4d, 0x4b, 0x96, 0x50, 0x9d, 0xff, 0x56, 0xac, 0xa6, 0x6a, 0x13, 0x11, 0x72,
	0x16, 0x4d, 0xae, 0x03, 0x22, 0x31, 0x0d, 0x42, 0xf4, 0x0e, 0x54, 0xd3, 0x10, 0xa2, 0x22, 0xa5,
	0x08, 0x54, 0x07, 0xc8, 0xb8, 0x19, 0x55, 0x29, 0x83, 0x51, 0xcd, 0x97, 0xb8, 0x62, 0x86, 0x5e,
	0x0c, 0x2b, 0xcd, 0xfb, 0x54, 0xc8, 0x81, 0x8f, 0x93, 0x8c, 0xa7, 0x08, 0xd5, 0x56, 0x4d, 0x2a,
	0xe9, 0xd7, 0x84, 0x85, 0x03, 0x3a, 0x32, 0x09, 0xcf, 0xa2, 0x94, 0xbc, 0x4b, 0x42, 0xea, 0x13,
	0xe6, 0x9d, 0x99, 0xe4, 0xa6, 0x08, 0xf4, 0x16, 0xac, 0x7c, 0xaa, 0x83, 0x35, 0xc9, 0x33, 0x90,
	0xf3, 0xbb, 0x8a, 0xd5, 0x8c, 0xd9, 0x90, 0x4b, 0x9a, 0x71, 0x03, 0x96, 0x54, 0xc9, 0xa3, 0xe0,
	0xd4, 0x27, 0xfa, 0x14, 0x56, 0x4d, 0x7a, 0x4c, 0xc7, 0x7d, 0x38, 0xab, 0xe3, 0xa6, 0x72, 0xea,
	0xc6, 0xd2, 0xce, 0x27, 0xf0, 0x9e, 0xb5, 0xfe, 0x58, 0x3f, 0x20, 0x4d, 0xce, 0x24, 0xf6, 0x64,
	0xb6, 0x06, 0x35, 0x58, 0x35, 0x58, 0xe3, 0x59, 0x0c, 0x3a, 0x7f, 0xac, 0xc0, 0x3b, 0xb3, 0x34,
	0x2c, 0x1c, 0xd2, 0x67, 0xf9, 0x90, 0xee, 0x96, 0x87, 0x54, 0xe6, 0x67, 0x1a, 0xd7, 0x9f, 0xed,
	0xbe, 0x7a, 0x82, 0x03, 0xaa, 0x8a, 0x9a, 0xd9, 0xa8, 0xd0, 0x8f, 0xe0, 0x8d, 0x14, 0x3a, 0x39,
	0x1b, 0xc5, 0x1e, 0xe6, 0xb0, 0x05, 0xae, 0xee, 0xc3, 0x15, 0x6b, 0x77, 0x5b, 0x5a, 0x68, 0x8e,
	0x5a, 0x32, 0x8e, 0x80, 0x9b, 0xb3, 0xfd, 0x0b, 0xd1, 0x63, 0xb8, 0x9c, 0x01, 0x6b, 0x95, 0xed,
	0xa5, 0xd9, 0x85, 0x2e, 0x50, 0xe2, 0x66, 0x35, 0x38, 0xa7, 0xf0, 0x7e, 0xf6, 0xf4, 0x22, 0x08,
	0x96, 0x66, 0x16, 0x1e, 0xc6, 0x03, 0xd9, 0x3a, 0xc3, 0xac, 0xb6, 0xd5, 0xe9, 0xb1, 0xdd, 0xd4,
	0x89, 0x59, 0x60, 0xa3, 0x30, 0xec, 0xce, 0x5f, 0x2b, 0xb0, 0x3d, 0xcf, 0xd0, 0xf9, 0xf7, 0x0a,
	0xf4, 0x25, 0x40, 0xea, 0x9e, 0x49, 0xfa, 0xc7, 0xe5, 0xe9, 0x98, 0x13, 0x9f, 0x9b, 0x51, 0xe6,
	0x30, 0x6b, 0x49, 0x66, 0x25, 0x51, 0x07, 0xae, 0x1c, 0x84, 0xa9, 0x02, 0x93, 0x8b, 0xc6, 0x39,
	0xed, 0xba, 0x96, 0x12, 0xe7, 0xf7, 0xab, 0xf0, 0x41, 0x46, 0x44, 0xef, 0x2a, 0xa7, 0x44, 0xdc,
	0x1f, 0x33, 0x3f, 0x2c, 0xaa, 0xc5, 0x11, 0x6c, 0xec, 0x79, 0x1e, 0x19, 0xc9, 0x36, 0x0e, 0xc3,
	0xe7, 0x5c, 0xf8, 0x0b, 0x17, 0x65, 0x4a, 0x0e, 0xfd, 0x1c, 0xae, 0x3d, 0xc2, 0xd2, 0x1b, 0x24,
	0x33, 0x54, 0x1d, 0x31, 0x1e, 0x90, 0x17, 0x3a, 0xdf, 0x57, 0xdc, 0x62, 0xa2, 0x1a, 0xf0, 0x9a,
	0x90, 0x8e, 0xd6, 0x58, 0x6c, 0x49, 0x8b, 0x95, 0x50, 0xd1, 0x5d, 0xd8, 0xd4, 0x94, 0x78, 0xe8,
	0xc6, 0x52, 0x97, 0xb4, 0x54, 0x21, 0x0d, 0x9d, 0x42, 0xbd, 0x64, 0x8f, 0x6a, 0x0e, 0x88, 0xf7,
	0x6c, 0xe1, 0xf3, 0xe4, 0x1c, 0x2d, 0x33, 0xec, 0xc4, 0x8d, 0xbf, 0xf2, 0x5a, 0x76, 0x8c, 0x16,
	0x34, 0x80, 0x9b, 0x65, 0x1b, 0x67, 0x1c, 0xd0, 0xea, 0x42, 0x86, 0xe6, 0xa9, 0x99, 0x65, 0x29,
	0x0e, 0x69, 0xed, 0xf5, 0x2c, 0xc5, 0x31, 0xf9, 0x70, 0xa3, 0x78, 0x4b, 0x8f, 0x23, 0xaa, 0x2e,
	0x64, 0x67, 0xb6, 0x92, 0x72, 0x2b, 0x71, 0x34, 0xf0, 0x3a, 0x56, 0xe2, 0x79, 0xf5, 0xf7, 0x0a,
	0xbc, 0x3b, 0x77, 0x35, 0x7e, 0x87, 0x81, 0xf5, 0xb4, 0x60, 0x60, 0xdd, 0x2b, 0x1f, 0x1c, 0xf3,
	0xa6, 0x80, 0x35, 0xb1, 0xfe, 0x5d, 0x81, 0x5a, 0x99, 0x2c, 0x3a, 0x81, 0x8d, 0x07, 0xd4, 0xf7,
	0x09, 0x8b, 0xd1, 0xc9, 0xb8, 0x58, 0xfc, 0x64, 0x3a, 0xa5, 0x01, 0x9d, 0xe4, 0x26, 0x61, 0x74,
	0x1d, 0xfd, 0xe8, 0xbc, 0x01, 0xd9, 0xa3, 0x50, 0x1d, 0xb3, 0x1e, 0x8f, 0x64, 0x8b, 0xb9, 0x04,
	0x87, 0x9c, 0xc5, 0xa7, 0xf7, 0x0c, 0xca, 0xd9, 0xb7, 0xb6, 0x2d, 0x97, 0x78, 0x84, 0x4e, 0x48,
	0xe9, 0xa8, 0xdc, 0x84, 0xe5, 0x5f, 0x8f, 0x49, 0x7a, 0x73, 0xd7, 0x40, 0x7e, 0x4b, 0x2a, 0x54,
	0xf2, 0xfd, 0x6f, 0x49, 0x73, 0x7c, 0xb7, 0x0a, 0xfc, 0x04, 0x9c, 0xdc, 0xcd, 0xc8, 0x8d, 0x9e,
	0x47, 0x1e, 0x92, 0xb3, 0xd7, 0x70, 0x39, 0xb7, 0xd5, 0x65, 0x3d, 0x52, 0x5b, 0xdd, 0xe1, 0x68,
	0x70, 0x8e, 0xad, 0xae, 0x30, 0x1e, 0xd7, 0x52, 0xe2, 0xfc, 0xc3, 0x3e, 0x20, 0xee, 0x31, 0xce,
	0xec, 0x66, 0xfd, 0x2d, 0x6c, 0x9e, 0x70, 0x89, 0x83, 0xa4, 0xd3, 0x04, 0x1d, 0x92, 0xef, 0xd0,
	0xb0, 0x85, 0x5a, 0x50, 0x0b, 0xae, 0x69, 0xd4, 0x08, 0x0b, 0xc2, 0x64, 0x4c, 0xdd, 0xbf, 0x6f,
	0xba, 0xf7, 0x6a, 0x7e, 0x72, 0xb4, 0x98, 0x74, 0x8b, 0x25, 0x9c, 0xbf, 0xd9, 0x91, 0x1c, 0x76,
	0x92, 0x17, 0xbd, 0x99, 0x57, 0xc9, 0x4f, 0x60, 0xfd, 0xf3, 0xce, 0x41, 0x93, 0x53, 0x16, 0xb1,
	0x19, 0xcb, 0xd7, 0x77, 0xcc, 0xfb, 0x63, 0x0f, 0x87, 0x64, 0xc7, 0xbc, 0x38, 0xee, 0x28, 0x36,
	0xd7, 0xe6, 0x47, 0x1f, 0x03, 0x64, 0xa4, 0x97, 0xe6, 0x49, 0x67, 0x98, 0x9d, 0xdf, 0x58, 0xc5,
	0xee, 0x74, 0x5a, 0x07, 0x7b, 0xcc, 0x6f, 0x0b, 0x3a, 0x79, 0xa8, 0xae, 0x27, 0xed, 0x71, 0xef,
	0xa1, 0x29, 0x73, 0xd5, 0x35, 0x90, 0xba, 0x81, 0xaa, 0x2f, 0xd3, 0x37, 0xfa, 0x5b, 0x05, 0xa6,
	0x85, 0xcc, 0xea, 0x8c, 0x00, 0xe7, 0x97, 0x70, 0x2d, 0x5b, 0x0d, 0xca, 0x19, 0x21, 0xa2, 0x75,
	0x10, 0xaa, 0x3b, 0x59, 0x0a, 0xe9, 0x73, 0x6b, 0xd5, 0xcd, 0x60, 0x9c, 0x6f, 0x73, 0x89, 0x64,
	0x5e, 0x80, 0x27, 0xa4, 0xd3, 0x79, 0xfc, 0x9c, 0x11, 0xf1, 0x08, 0x8f, 0xd0, 0xe7, 0xb0, 0x66,
	0xd8, 0xe3, 0x63, 0xef, 0x8c, 0x45, 0x35, 0x25, 0xbe, 0x13, 0xcb, 0x1e, 0x32, 0x29, 0xce, 0xdc,
	0x44, 0xd5, 0x16, 0x86, 0x75, 0x8b, 0xa4, 0x8e, 0xf6, 0xcf, 0xc8, 0x99, 0x49, 0x80, 0xfa, 0x44,
	0xf7, 0x60, 0x79, 0xa2, 0xdf, 0xfd, 0xa2, 0x22, 0xdd, 0x9a, 0xd1, 0x7d, 0x49, 0x3c, 0x6e, 0x24,
	0x72, 0xef, 0xe2, 0x6e, 0xc5, 0xf9, 0x8b, 0x7d, 0xef, 0x30, 0xbe, 0xa9, 0x24, 0x36, 0xb1, 0x37,
	0x20, 0x2a, 0xb8, 0x63, 0x58, 0x56, 0x70, 0x1c, 0xd9, 0xee, 0xdc, 0xc8, 0xb2, 0xd2, 0x3b, 0x5a,
	0x34, 0x0a, 0x2c, 0x52, 0xb3, 0xb5, 0x0b, 0x90, 0x22, 0x0b, 0x42, 0xda, 0xcc, 0x86, 0x54, 0xcd,
	0x3a, 0xfb, 0x9f, 0x25, 0xcb, 0x59, 0xfd, 0xca, 0xe4, 0xc7, 0x46, 0xf5, 0x53, 0xb6, 0x12, 0x3e,
	0xc2, 0x22, 0x69, 0x92, 0x08, 0x40, 0xb7, 0x60, 0xfd, 0x08, 0x8b, 0x3d, 0x31, 0xe4, 0x22, 0xea,
	0x0b, 0xf3, 0x3a, 0x62, 0x21, 0xd5, 0x14, 0x3a, 0xc2, 0x22, 0xdb, 0x38, 0x09, 0xac, 0x2e, 0x94,
	0xea, 0x5b, 0x35, 0x5a, 0x74, 0xf1, 0x8e, 0x41, 0xb5, 0x1f, 0xb8, 0xa4, 0x3f, 0x0e, 0xb0, 0xe4,
	0xca, 0xae, 0xb9, 0x76, 0x67, 0x50, 0xe8, 0x23, 0xb8, 0x9a, 0x80, 0x19, 0x1f, 0xa2, 0x0b, 0x78,
	0x11, 0x49, 0x5d, 0xf5, 0x12, 0x74, 0xc4, 0x1c, 0x5d, 0xc9, 0x73, 0x58, 0x15, 0x57, 0x8a, 0x51,
	0xbe, 0x45, 0x8f, 0x17, 0x36, 0x12, 0x7d, 0x01, 0x1b, 0x9d, 0x4e, 0x8b, 0x49, 0x22, 0x26, 0x38,
	0xd0, 0x4d, 0x17, 0x9a, 0xd3, 0xce, 0x07, 0xe7, 0xe8, 0x52, 0x77, 0x4a, 0x09, 0xea, 0xc2, 0xd5,
	0x14, 0x97, 0x54, 0xdd, 0x9c, 0x71, 0x3e, 0x3c, 0x57, 0x9f, 0xb8, 0x45, 0x9a, 0xf6, 0x1b, 0xff,
	0x7c, 0x59, 0xaf, 0x7c, 0xf3, 0xb2, 0x5e, 0xf9, 0xd7, 0xcb, 0x7a, 0xe5, 0x0f, 0xaf, 0xea, 0x17,
	0xbe, 0x79, 0x55, 0xbf, 0xf0, 0xed, 0xab, 0xfa, 0x85, 0xa7, 0xd7, 0xcc, 0xd3, 0xf9, 0x8b, 0xf8,
	0x0d, 0x5d, 0x9e, 0x8d, 0x48, 0xd8, 0x5b, 0xd1, 0x4f, 0xe4, 0x3f, 0xfb, 0x7f, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x58, 0xa7, 0x45, 0x9c, 0x95, 0x19, 0x00, 0x00,
}

func (m *EncryptableString) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptableString) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptableString) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptableClaimCredentialExtraParms) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptableClaimCredentialExtraParms) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptableClaimCredentialExtraParms) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClaimPC != nil {
		{
			size, err := m.ClaimPC.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.ZeroPC != nil {
		{
			size, err := m.ZeroPC.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.CredentialHashVShareBind != nil {
		{
			size, err := m.CredentialHashVShareBind.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.EncCredentialHashVShare) > 0 {
		i -= len(m.EncCredentialHashVShare)
		copy(dAtA[i:], m.EncCredentialHashVShare)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.EncCredentialHashVShare)))
		i--
		dAtA[i] = 0x42
	}
	if m.WalletIDVShareBind != nil {
		{
			size, err := m.WalletIDVShareBind.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.EncWalletIDVShare) > 0 {
		i -= len(m.EncWalletIDVShare)
		copy(dAtA[i:], m.EncWalletIDVShare)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.EncWalletIDVShare)))
		i--
		dAtA[i] = 0x32
	}
	if m.NewCredentialPC != nil {
		{
			size, err := m.NewCredentialPC.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.FindCredentialPC != nil {
		{
			size, err := m.FindCredentialPC.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.WalletID) > 0 {
		i -= len(m.WalletID)
		copy(dAtA[i:], m.WalletID)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.WalletID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.CredentialInfoVShareBind != nil {
		{
			size, err := m.CredentialInfoVShareBind.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.EncCredentialInfoVShare) > 0 {
		i -= len(m.EncCredentialInfoVShare)
		copy(dAtA[i:], m.EncCredentialInfoVShare)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.EncCredentialInfoVShare)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptableAuthorizedSignatory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptableAuthorizedSignatory) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptableAuthorizedSignatory) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.WalletID) > 0 {
		i -= len(m.WalletID)
		copy(dAtA[i:], m.WalletID)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.WalletID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptableSignatory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptableSignatory) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptableSignatory) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PhoneNumber) > 0 {
		i -= len(m.PhoneNumber)
		copy(dAtA[i:], m.PhoneNumber)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.PhoneNumber)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Email) > 0 {
		i -= len(m.Email)
		copy(dAtA[i:], m.Email)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.Email)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptableWalletAmount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptableWalletAmount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptableWalletAmount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RequiredSenderLastName) > 0 {
		i -= len(m.RequiredSenderLastName)
		copy(dAtA[i:], m.RequiredSenderLastName)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.RequiredSenderLastName)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.RequiredSenderMiddleName) > 0 {
		i -= len(m.RequiredSenderMiddleName)
		copy(dAtA[i:], m.RequiredSenderMiddleName)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.RequiredSenderMiddleName)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.RequiredSenderFirstName) > 0 {
		i -= len(m.RequiredSenderFirstName)
		copy(dAtA[i:], m.RequiredSenderFirstName)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.RequiredSenderFirstName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.RequiredSenderPIN) > 0 {
		i -= len(m.RequiredSenderPIN)
		copy(dAtA[i:], m.RequiredSenderPIN)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.RequiredSenderPIN)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Note) > 0 {
		i -= len(m.Note)
		copy(dAtA[i:], m.Note)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.Note)))
		i--
		dAtA[i] = 0x22
	}
	if m.PedersenCommit != nil {
		{
			size, err := m.PedersenCommit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TransactionID) > 0 {
		i -= len(m.TransactionID)
		copy(dAtA[i:], m.TransactionID)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.TransactionID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptablePersonalInfoDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptablePersonalInfoDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptablePersonalInfoDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Gender) > 0 {
		i -= len(m.Gender)
		copy(dAtA[i:], m.Gender)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.Gender)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Residency) > 0 {
		i -= len(m.Residency)
		copy(dAtA[i:], m.Residency)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.Residency)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Citizenship) > 0 {
		i -= len(m.Citizenship)
		copy(dAtA[i:], m.Citizenship)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.Citizenship)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Birthdate) > 0 {
		i -= len(m.Birthdate)
		copy(dAtA[i:], m.Birthdate)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.Birthdate)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.LastName) > 0 {
		i -= len(m.LastName)
		copy(dAtA[i:], m.LastName)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.LastName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MiddleName) > 0 {
		i -= len(m.MiddleName)
		copy(dAtA[i:], m.MiddleName)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.MiddleName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FirstName) > 0 {
		i -= len(m.FirstName)
		copy(dAtA[i:], m.FirstName)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.FirstName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptablePersonalInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptablePersonalInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptablePersonalInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Details != nil {
		{
			size, err := m.Details.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PIN) > 0 {
		i -= len(m.PIN)
		copy(dAtA[i:], m.PIN)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.PIN)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptableSingleContactInfoDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptableSingleContactInfoDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptableSingleContactInfoDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Contact) > 0 {
		i -= len(m.Contact)
		copy(dAtA[i:], m.Contact)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.Contact)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptableSingleContactInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptableSingleContactInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptableSingleContactInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Details != nil {
		{
			size, err := m.Details.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PIN) > 0 {
		i -= len(m.PIN)
		copy(dAtA[i:], m.PIN)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.PIN)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptableValidatedCredential) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptableValidatedCredential) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptableValidatedCredential) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CredentialPC != nil {
		{
			size, err := m.CredentialPC.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PIN) > 0 {
		i -= len(m.PIN)
		copy(dAtA[i:], m.PIN)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.PIN)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CredentialType) > 0 {
		i -= len(m.CredentialType)
		copy(dAtA[i:], m.CredentialType)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.CredentialType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptableValidatedCredentials) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptableValidatedCredentials) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptableValidatedCredentials) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Credentials) > 0 {
		for iNdEx := len(m.Credentials) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Credentials[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEncryptable(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EncryptableCreateWalletEWalletIDExtraParms) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptableCreateWalletEWalletIDExtraParms) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptableCreateWalletEWalletIDExtraParms) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProofPC != nil {
		{
			size, err := m.ProofPC.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptableCreateWalletEWalletID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptableCreateWalletEWalletID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptableCreateWalletEWalletID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExtraParms != nil {
		{
			size, err := m.ExtraParms.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.WalletID) > 0 {
		i -= len(m.WalletID)
		copy(dAtA[i:], m.WalletID)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.WalletID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptableCreateWallet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptableCreateWallet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptableCreateWallet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DstEWalletID != nil {
		{
			size, err := m.DstEWalletID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptableTransferFundsEWalletIDExtraParms) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptableTransferFundsEWalletIDExtraParms) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptableTransferFundsEWalletIDExtraParms) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequiredSenderLastNameProofPC != nil {
		{
			size, err := m.RequiredSenderLastNameProofPC.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.RequiredSenderLastNameCheckPC != nil {
		{
			size, err := m.RequiredSenderLastNameCheckPC.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.RequiredSenderMiddleNameProofPC != nil {
		{
			size, err := m.RequiredSenderMiddleNameProofPC.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.RequiredSenderMiddleNameCheckPC != nil {
		{
			size, err := m.RequiredSenderMiddleNameCheckPC.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.RequiredSenderFirstNameProofPC != nil {
		{
			size, err := m.RequiredSenderFirstNameProofPC.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.RequiredSenderFirstNameCheckPC != nil {
		{
			size, err := m.RequiredSenderFirstNameCheckPC.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.MatchLastNameHashHex) > 0 {
		i -= len(m.MatchLastNameHashHex)
		copy(dAtA[i:], m.MatchLastNameHashHex)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.MatchLastNameHashHex)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MatchMiddleNameHashHex) > 0 {
		i -= len(m.MatchMiddleNameHashHex)
		copy(dAtA[i:], m.MatchMiddleNameHashHex)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.MatchMiddleNameHashHex)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MatchFirstNameHashHex) > 0 {
		i -= len(m.MatchFirstNameHashHex)
		copy(dAtA[i:], m.MatchFirstNameHashHex)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.MatchFirstNameHashHex)))
		i--
		dAtA[i] = 0x12
	}
	if m.AcceptPasswordPC != nil {
		{
			size, err := m.AcceptPasswordPC.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptableTransferFundsEWalletID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptableTransferFundsEWalletID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptableTransferFundsEWalletID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExtraParms != nil {
		{
			size, err := m.ExtraParms.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.WalletID) > 0 {
		i -= len(m.WalletID)
		copy(dAtA[i:], m.WalletID)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.WalletID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptableTransferFunds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptableTransferFunds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptableTransferFunds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OptInReason) > 0 {
		i -= len(m.OptInReason)
		copy(dAtA[i:], m.OptInReason)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.OptInReason)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DstEWalletID != nil {
		{
			size, err := m.DstEWalletID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.HiddenTransferPC != nil {
		{
			size, err := m.HiddenTransferPC.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptableReceiveFundsEWalletIDExtraParms) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptableReceiveFundsEWalletIDExtraParms) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptableReceiveFundsEWalletIDExtraParms) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Queue) > 0 {
		i -= len(m.Queue)
		copy(dAtA[i:], m.Queue)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.Queue)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptableReceiveFundsEWalletID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptableReceiveFundsEWalletID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptableReceiveFundsEWalletID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExtraParms != nil {
		{
			size, err := m.ExtraParms.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.WalletID) > 0 {
		i -= len(m.WalletID)
		copy(dAtA[i:], m.WalletID)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.WalletID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptableSignRecoverKeyEWalletID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptableSignRecoverKeyEWalletID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptableSignRecoverKeyEWalletID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.WalletID) > 0 {
		i -= len(m.WalletID)
		copy(dAtA[i:], m.WalletID)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.WalletID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptableReceiveFunds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptableReceiveFunds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptableReceiveFunds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EphEWalletID != nil {
		{
			size, err := m.EphEWalletID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptableAnonTransferFunds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptableAnonTransferFunds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptableAnonTransferFunds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransparentTransferBF != nil {
		{
			size, err := m.TransparentTransferBF.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TotalTransferPrimePC != nil {
		{
			size, err := m.TotalTransferPrimePC.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptableESuspiciousAmount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptableESuspiciousAmount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptableESuspiciousAmount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CoinAmount != nil {
		{
			size, err := m.CoinAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.USDCoinAmount != nil {
		{
			size, err := m.USDCoinAmount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptableSSIDAndPrivK) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptableSSIDAndPrivK) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptableSSIDAndPrivK) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PrivK) > 0 {
		i -= len(m.PrivK)
		copy(dAtA[i:], m.PrivK)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.PrivK)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PubK) > 0 {
		i -= len(m.PubK)
		copy(dAtA[i:], m.PubK)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.PubK)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PubKID) > 0 {
		i -= len(m.PubKID)
		copy(dAtA[i:], m.PubKID)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.PubKID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptablePioneerIDs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptablePioneerIDs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptablePioneerIDs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PioneerIDs) > 0 {
		for iNdEx := len(m.PioneerIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PioneerIDs[iNdEx])
			copy(dAtA[i:], m.PioneerIDs[iNdEx])
			i = encodeVarintEncryptable(dAtA, i, uint64(len(m.PioneerIDs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EncryptableEnclaveSSOwnerMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptableEnclaveSSOwnerMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptableEnclaveSSOwnerMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Pioneers) > 0 {
		for k := range m.Pioneers {
			v := m.Pioneers[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintEncryptable(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintEncryptable(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintEncryptable(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EncryptableEnclavePubKCacheMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptableEnclavePubKCacheMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptableEnclavePubKCacheMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PubKs) > 0 {
		for k := range m.PubKs {
			v := m.PubKs[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintEncryptable(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintEncryptable(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintEncryptable(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EncryptableSharedEnclaveParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptableSharedEnclaveParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptableSharedEnclaveParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SSIntervalPubKCache != nil {
		{
			size, err := m.SSIntervalPubKCache.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.SSIntervalOwners != nil {
		{
			size, err := m.SSIntervalOwners.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEncryptable(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.RegulatorPubK) > 0 {
		i -= len(m.RegulatorPubK)
		copy(dAtA[i:], m.RegulatorPubK)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.RegulatorPubK)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.RegulatorPrivK) > 0 {
		i -= len(m.RegulatorPrivK)
		copy(dAtA[i:], m.RegulatorPrivK)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.RegulatorPrivK)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.RegulatorArmorPrivK) > 0 {
		i -= len(m.RegulatorArmorPrivK)
		copy(dAtA[i:], m.RegulatorArmorPrivK)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.RegulatorArmorPrivK)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.RegulatorID) > 0 {
		i -= len(m.RegulatorID)
		copy(dAtA[i:], m.RegulatorID)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.RegulatorID)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.JarPubK) > 0 {
		i -= len(m.JarPubK)
		copy(dAtA[i:], m.JarPubK)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.JarPubK)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.JarPrivK) > 0 {
		i -= len(m.JarPrivK)
		copy(dAtA[i:], m.JarPrivK)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.JarPrivK)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.JarArmorPrivK) > 0 {
		i -= len(m.JarArmorPrivK)
		copy(dAtA[i:], m.JarArmorPrivK)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.JarArmorPrivK)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.JarID) > 0 {
		i -= len(m.JarID)
		copy(dAtA[i:], m.JarID)
		i = encodeVarintEncryptable(dAtA, i, uint64(len(m.JarID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEncryptable(dAtA []byte, offset int, v uint64) int {
	offset -= sovEncryptable(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EncryptableString) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	return n
}

func (m *EncryptableClaimCredentialExtraParms) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EncCredentialInfoVShare)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	if m.CredentialInfoVShareBind != nil {
		l = m.CredentialInfoVShareBind.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.WalletID)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	if m.FindCredentialPC != nil {
		l = m.FindCredentialPC.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	if m.NewCredentialPC != nil {
		l = m.NewCredentialPC.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.EncWalletIDVShare)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	if m.WalletIDVShareBind != nil {
		l = m.WalletIDVShareBind.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.EncCredentialHashVShare)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	if m.CredentialHashVShareBind != nil {
		l = m.CredentialHashVShareBind.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	if m.ZeroPC != nil {
		l = m.ZeroPC.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	if m.ClaimPC != nil {
		l = m.ClaimPC.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	return n
}

func (m *EncryptableAuthorizedSignatory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.WalletID)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	return n
}

func (m *EncryptableSignatory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	return n
}

func (m *EncryptableWalletAmount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.TransactionID)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	if m.PedersenCommit != nil {
		l = m.PedersenCommit.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.Note)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.RequiredSenderPIN)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.RequiredSenderFirstName)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.RequiredSenderMiddleName)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.RequiredSenderLastName)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	return n
}

func (m *EncryptablePersonalInfoDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.MiddleName)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.Birthdate)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.Citizenship)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.Residency)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.Gender)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	return n
}

func (m *EncryptablePersonalInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.PIN)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	if m.Details != nil {
		l = m.Details.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	return n
}

func (m *EncryptableSingleContactInfoDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Contact)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	return n
}

func (m *EncryptableSingleContactInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.PIN)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	if m.Details != nil {
		l = m.Details.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	return n
}

func (m *EncryptableValidatedCredential) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CredentialType)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.PIN)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	if m.CredentialPC != nil {
		l = m.CredentialPC.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	return n
}

func (m *EncryptableValidatedCredentials) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Credentials) > 0 {
		for _, e := range m.Credentials {
			l = e.Size()
			n += 1 + l + sovEncryptable(uint64(l))
		}
	}
	return n
}

func (m *EncryptableCreateWalletEWalletIDExtraParms) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProofPC != nil {
		l = m.ProofPC.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	return n
}

func (m *EncryptableCreateWalletEWalletID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.WalletID)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	if m.ExtraParms != nil {
		l = m.ExtraParms.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	return n
}

func (m *EncryptableCreateWallet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DstEWalletID != nil {
		l = m.DstEWalletID.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	return n
}

func (m *EncryptableTransferFundsEWalletIDExtraParms) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AcceptPasswordPC != nil {
		l = m.AcceptPasswordPC.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.MatchFirstNameHashHex)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.MatchMiddleNameHashHex)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.MatchLastNameHashHex)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	if m.RequiredSenderFirstNameCheckPC != nil {
		l = m.RequiredSenderFirstNameCheckPC.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	if m.RequiredSenderFirstNameProofPC != nil {
		l = m.RequiredSenderFirstNameProofPC.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	if m.RequiredSenderMiddleNameCheckPC != nil {
		l = m.RequiredSenderMiddleNameCheckPC.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	if m.RequiredSenderMiddleNameProofPC != nil {
		l = m.RequiredSenderMiddleNameProofPC.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	if m.RequiredSenderLastNameCheckPC != nil {
		l = m.RequiredSenderLastNameCheckPC.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	if m.RequiredSenderLastNameProofPC != nil {
		l = m.RequiredSenderLastNameProofPC.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	return n
}

func (m *EncryptableTransferFundsEWalletID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.WalletID)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	if m.ExtraParms != nil {
		l = m.ExtraParms.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	return n
}

func (m *EncryptableTransferFunds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HiddenTransferPC != nil {
		l = m.HiddenTransferPC.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	if m.DstEWalletID != nil {
		l = m.DstEWalletID.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.OptInReason)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	return n
}

func (m *EncryptableReceiveFundsEWalletIDExtraParms) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Queue)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	return n
}

func (m *EncryptableReceiveFundsEWalletID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.WalletID)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	if m.ExtraParms != nil {
		l = m.ExtraParms.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	return n
}

func (m *EncryptableSignRecoverKeyEWalletID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.WalletID)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	return n
}

func (m *EncryptableReceiveFunds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EphEWalletID != nil {
		l = m.EphEWalletID.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	return n
}

func (m *EncryptableAnonTransferFunds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalTransferPrimePC != nil {
		l = m.TotalTransferPrimePC.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	if m.TransparentTransferBF != nil {
		l = m.TransparentTransferBF.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	return n
}

func (m *EncryptableESuspiciousAmount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	if m.USDCoinAmount != nil {
		l = m.USDCoinAmount.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	if m.CoinAmount != nil {
		l = m.CoinAmount.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	return n
}

func (m *EncryptableSSIDAndPrivK) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PubKID)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.PubK)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.PrivK)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	return n
}

func (m *EncryptablePioneerIDs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PioneerIDs) > 0 {
		for _, s := range m.PioneerIDs {
			l = len(s)
			n += 1 + l + sovEncryptable(uint64(l))
		}
	}
	return n
}

func (m *EncryptableEnclaveSSOwnerMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Pioneers) > 0 {
		for k, v := range m.Pioneers {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovEncryptable(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovEncryptable(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovEncryptable(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *EncryptableEnclavePubKCacheMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PubKs) > 0 {
		for k, v := range m.PubKs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovEncryptable(uint64(len(k))) + 1 + len(v) + sovEncryptable(uint64(len(v)))
			n += mapEntrySize + 1 + sovEncryptable(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *EncryptableSharedEnclaveParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JarID)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.JarArmorPrivK)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.JarPrivK)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.JarPubK)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.RegulatorID)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.RegulatorArmorPrivK)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.RegulatorPrivK)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	l = len(m.RegulatorPubK)
	if l > 0 {
		n += 1 + l + sovEncryptable(uint64(l))
	}
	if m.SSIntervalOwners != nil {
		l = m.SSIntervalOwners.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	if m.SSIntervalPubKCache != nil {
		l = m.SSIntervalPubKCache.Size()
		n += 1 + l + sovEncryptable(uint64(l))
	}
	return n
}

func sovEncryptable(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEncryptable(x uint64) (n int) {
	return sovEncryptable(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EncryptableString) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEncryptable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptableString: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptableString: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEncryptable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEncryptable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptableClaimCredentialExtraParms) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEncryptable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptableClaimCredentialExtraParms: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptableClaimCredentialExtraParms: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncCredentialInfoVShare", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncCredentialInfoVShare = append(m.EncCredentialInfoVShare[:0], dAtA[iNdEx:postIndex]...)
			if m.EncCredentialInfoVShare == nil {
				m.EncCredentialInfoVShare = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialInfoVShareBind", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CredentialInfoVShareBind == nil {
				m.CredentialInfoVShareBind = &VShareBindData{}
			}
			if err := m.CredentialInfoVShareBind.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalletID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WalletID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FindCredentialPC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FindCredentialPC == nil {
				m.FindCredentialPC = &BPedersenCommit{}
			}
			if err := m.FindCredentialPC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewCredentialPC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewCredentialPC == nil {
				m.NewCredentialPC = &BPedersenCommit{}
			}
			if err := m.NewCredentialPC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncWalletIDVShare", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncWalletIDVShare = append(m.EncWalletIDVShare[:0], dAtA[iNdEx:postIndex]...)
			if m.EncWalletIDVShare == nil {
				m.EncWalletIDVShare = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalletIDVShareBind", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WalletIDVShareBind == nil {
				m.WalletIDVShareBind = &VShareBindData{}
			}
			if err := m.WalletIDVShareBind.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncCredentialHashVShare", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncCredentialHashVShare = append(m.EncCredentialHashVShare[:0], dAtA[iNdEx:postIndex]...)
			if m.EncCredentialHashVShare == nil {
				m.EncCredentialHashVShare = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialHashVShareBind", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CredentialHashVShareBind == nil {
				m.CredentialHashVShareBind = &VShareBindData{}
			}
			if err := m.CredentialHashVShareBind.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZeroPC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ZeroPC == nil {
				m.ZeroPC = &EncryptablePedersenCommit{}
			}
			if err := m.ZeroPC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimPC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClaimPC == nil {
				m.ClaimPC = &BPedersenCommit{}
			}
			if err := m.ClaimPC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEncryptable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEncryptable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptableAuthorizedSignatory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEncryptable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptableAuthorizedSignatory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptableAuthorizedSignatory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalletID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WalletID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEncryptable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEncryptable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptableSignatory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEncryptable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptableSignatory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptableSignatory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEncryptable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEncryptable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptableWalletAmount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEncryptable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptableWalletAmount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptableWalletAmount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PedersenCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PedersenCommit == nil {
				m.PedersenCommit = &EncryptablePedersenCommit{}
			}
			if err := m.PedersenCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Note = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredSenderPIN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequiredSenderPIN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredSenderFirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequiredSenderFirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredSenderMiddleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequiredSenderMiddleName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredSenderLastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequiredSenderLastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEncryptable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEncryptable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptablePersonalInfoDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEncryptable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptablePersonalInfoDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptablePersonalInfoDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MiddleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MiddleName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Birthdate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Birthdate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Citizenship", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Citizenship = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Residency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Residency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEncryptable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEncryptable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptablePersonalInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEncryptable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptablePersonalInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptablePersonalInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PIN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PIN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Details == nil {
				m.Details = &EncryptablePersonalInfoDetails{}
			}
			if err := m.Details.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEncryptable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEncryptable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptableSingleContactInfoDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEncryptable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptableSingleContactInfoDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptableSingleContactInfoDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contact", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contact = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEncryptable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEncryptable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptableSingleContactInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEncryptable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptableSingleContactInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptableSingleContactInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PIN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PIN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Details == nil {
				m.Details = &EncryptableSingleContactInfoDetails{}
			}
			if err := m.Details.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEncryptable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEncryptable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptableValidatedCredential) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEncryptable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptableValidatedCredential: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptableValidatedCredential: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CredentialType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PIN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PIN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialPC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CredentialPC == nil {
				m.CredentialPC = &BPedersenCommit{}
			}
			if err := m.CredentialPC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEncryptable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEncryptable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptableValidatedCredentials) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEncryptable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptableValidatedCredentials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptableValidatedCredentials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Credentials = append(m.Credentials, &EncryptableValidatedCredential{})
			if err := m.Credentials[len(m.Credentials)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEncryptable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEncryptable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptableCreateWalletEWalletIDExtraParms) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEncryptable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptableCreateWalletEWalletIDExtraParms: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptableCreateWalletEWalletIDExtraParms: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofPC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProofPC == nil {
				m.ProofPC = &BPedersenCommit{}
			}
			if err := m.ProofPC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEncryptable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEncryptable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptableCreateWalletEWalletID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEncryptable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptableCreateWalletEWalletID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptableCreateWalletEWalletID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalletID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WalletID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraParms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtraParms == nil {
				m.ExtraParms = &EncryptableCreateWalletEWalletIDExtraParms{}
			}
			if err := m.ExtraParms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEncryptable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEncryptable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptableCreateWallet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEncryptable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptableCreateWallet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptableCreateWallet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstEWalletID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstEWalletID == nil {
				m.DstEWalletID = &EncryptableCreateWalletEWalletID{}
			}
			if err := m.DstEWalletID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEncryptable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEncryptable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptableTransferFundsEWalletIDExtraParms) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEncryptable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptableTransferFundsEWalletIDExtraParms: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptableTransferFundsEWalletIDExtraParms: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptPasswordPC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AcceptPasswordPC == nil {
				m.AcceptPasswordPC = &BPedersenCommit{}
			}
			if err := m.AcceptPasswordPC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchFirstNameHashHex", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchFirstNameHashHex = append(m.MatchFirstNameHashHex[:0], dAtA[iNdEx:postIndex]...)
			if m.MatchFirstNameHashHex == nil {
				m.MatchFirstNameHashHex = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchMiddleNameHashHex", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchMiddleNameHashHex = append(m.MatchMiddleNameHashHex[:0], dAtA[iNdEx:postIndex]...)
			if m.MatchMiddleNameHashHex == nil {
				m.MatchMiddleNameHashHex = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchLastNameHashHex", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchLastNameHashHex = append(m.MatchLastNameHashHex[:0], dAtA[iNdEx:postIndex]...)
			if m.MatchLastNameHashHex == nil {
				m.MatchLastNameHashHex = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredSenderFirstNameCheckPC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequiredSenderFirstNameCheckPC == nil {
				m.RequiredSenderFirstNameCheckPC = &BPedersenCommit{}
			}
			if err := m.RequiredSenderFirstNameCheckPC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredSenderFirstNameProofPC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequiredSenderFirstNameProofPC == nil {
				m.RequiredSenderFirstNameProofPC = &BPedersenCommit{}
			}
			if err := m.RequiredSenderFirstNameProofPC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredSenderMiddleNameCheckPC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequiredSenderMiddleNameCheckPC == nil {
				m.RequiredSenderMiddleNameCheckPC = &BPedersenCommit{}
			}
			if err := m.RequiredSenderMiddleNameCheckPC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredSenderMiddleNameProofPC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequiredSenderMiddleNameProofPC == nil {
				m.RequiredSenderMiddleNameProofPC = &BPedersenCommit{}
			}
			if err := m.RequiredSenderMiddleNameProofPC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredSenderLastNameCheckPC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequiredSenderLastNameCheckPC == nil {
				m.RequiredSenderLastNameCheckPC = &BPedersenCommit{}
			}
			if err := m.RequiredSenderLastNameCheckPC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredSenderLastNameProofPC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequiredSenderLastNameProofPC == nil {
				m.RequiredSenderLastNameProofPC = &BPedersenCommit{}
			}
			if err := m.RequiredSenderLastNameProofPC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEncryptable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEncryptable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptableTransferFundsEWalletID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEncryptable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptableTransferFundsEWalletID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptableTransferFundsEWalletID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalletID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WalletID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraParms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtraParms == nil {
				m.ExtraParms = &EncryptableTransferFundsEWalletIDExtraParms{}
			}
			if err := m.ExtraParms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEncryptable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEncryptable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptableTransferFunds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEncryptable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptableTransferFunds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptableTransferFunds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HiddenTransferPC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HiddenTransferPC == nil {
				m.HiddenTransferPC = &EncryptablePedersenCommit{}
			}
			if err := m.HiddenTransferPC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstEWalletID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstEWalletID == nil {
				m.DstEWalletID = &EncryptableTransferFundsEWalletID{}
			}
			if err := m.DstEWalletID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptInReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptInReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEncryptable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEncryptable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptableReceiveFundsEWalletIDExtraParms) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEncryptable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptableReceiveFundsEWalletIDExtraParms: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptableReceiveFundsEWalletIDExtraParms: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEncryptable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEncryptable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptableReceiveFundsEWalletID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEncryptable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptableReceiveFundsEWalletID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptableReceiveFundsEWalletID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalletID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WalletID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraParms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtraParms == nil {
				m.ExtraParms = &EncryptableReceiveFundsEWalletIDExtraParms{}
			}
			if err := m.ExtraParms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEncryptable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEncryptable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptableSignRecoverKeyEWalletID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEncryptable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptableSignRecoverKeyEWalletID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptableSignRecoverKeyEWalletID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalletID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WalletID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEncryptable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEncryptable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptableReceiveFunds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEncryptable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptableReceiveFunds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptableReceiveFunds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EphEWalletID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EphEWalletID == nil {
				m.EphEWalletID = &EncryptableReceiveFundsEWalletID{}
			}
			if err := m.EphEWalletID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEncryptable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEncryptable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptableAnonTransferFunds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEncryptable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptableAnonTransferFunds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptableAnonTransferFunds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalTransferPrimePC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TotalTransferPrimePC == nil {
				m.TotalTransferPrimePC = &EncryptablePedersenCommit{}
			}
			if err := m.TotalTransferPrimePC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransparentTransferBF", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransparentTransferBF == nil {
				m.TransparentTransferBF = &BInt{}
			}
			if err := m.TransparentTransferBF.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEncryptable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEncryptable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptableESuspiciousAmount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEncryptable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptableESuspiciousAmount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptableESuspiciousAmount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field USDCoinAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.USDCoinAmount == nil {
				m.USDCoinAmount = &types.Coin{}
			}
			if err := m.USDCoinAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CoinAmount == nil {
				m.CoinAmount = &types.Coin{}
			}
			if err := m.CoinAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEncryptable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEncryptable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptableSSIDAndPrivK) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEncryptable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptableSSIDAndPrivK: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptableSSIDAndPrivK: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubK", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubK = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivK", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivK = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEncryptable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEncryptable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptablePioneerIDs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEncryptable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptablePioneerIDs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptablePioneerIDs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PioneerIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PioneerIDs = append(m.PioneerIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEncryptable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEncryptable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptableEnclaveSSOwnerMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEncryptable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptableEnclaveSSOwnerMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptableEnclaveSSOwnerMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pioneers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pioneers == nil {
				m.Pioneers = make(map[string]*EncryptablePioneerIDs)
			}
			var mapkey string
			var mapvalue *EncryptablePioneerIDs
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEncryptable
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEncryptable
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthEncryptable
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthEncryptable
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEncryptable
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthEncryptable
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthEncryptable
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &EncryptablePioneerIDs{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipEncryptable(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthEncryptable
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Pioneers[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEncryptable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEncryptable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptableEnclavePubKCacheMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEncryptable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptableEnclavePubKCacheMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptableEnclavePubKCacheMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PubKs == nil {
				m.PubKs = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEncryptable
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEncryptable
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthEncryptable
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthEncryptable
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEncryptable
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthEncryptable
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthEncryptable
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipEncryptable(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthEncryptable
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PubKs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEncryptable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEncryptable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptableSharedEnclaveParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEncryptable
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptableSharedEnclaveParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptableSharedEnclaveParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JarID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JarID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JarArmorPrivK", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JarArmorPrivK = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JarPrivK", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JarPrivK = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JarPubK", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JarPubK = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegulatorID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegulatorID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegulatorArmorPrivK", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegulatorArmorPrivK = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegulatorPrivK", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegulatorPrivK = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegulatorPubK", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegulatorPubK = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSIntervalOwners", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SSIntervalOwners == nil {
				m.SSIntervalOwners = &EncryptableEnclaveSSOwnerMap{}
			}
			if err := m.SSIntervalOwners.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSIntervalPubKCache", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEncryptable
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEncryptable
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SSIntervalPubKCache == nil {
				m.SSIntervalPubKCache = &EncryptableEnclavePubKCacheMap{}
			}
			if err := m.SSIntervalPubKCache.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEncryptable(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEncryptable
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEncryptable(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEncryptable
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEncryptable
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEncryptable
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEncryptable
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEncryptable
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEncryptable        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEncryptable          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEncryptable = fmt.Errorf("proto: unexpected end of group")
)
